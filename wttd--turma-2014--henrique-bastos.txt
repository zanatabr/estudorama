Welcome to The Django - Henrique Bastos
Turma 2014


http://alex-wttd.heroku.com/
https://github.com/aechiara/wttd

Outros participantes:
http://eventex-julihermes.herokuapp.com/
http://enio-eventex.herokuapp.com/
http://alebona.herokuapp.com/

http://www.djangobook.com/en/2.0/chapter09.html
http://stackoverflow.com/questions/17507266/loading-custom-tag-filters-from-another-app
http://getbootstrap.com/css/#forms
http://duganchen.ca/rendering-django-forms-for-the-twitter-bootstrap/
http://stackoverflow.com/questions/11321767/how-should-i-style-django-validation-errors-with-bootstrap
* Este campo é obrigatório.
https://github.com/earle/django-bootstrap
https://docs.djangoproject.com/en/1.6/ref/templates/builtins/
https://docs.djangoproject.com/en/dev/ref/models/fields/
http://alex-wttd.herokuapp.com/inscricao/

* pyquery ou beautifulsoup ?
http://www.python.org.br/wiki/BeautifulSoup

*** Teste Funcional, Unitário e Regressão
Se um sistema fosse uma cebola.
Teste Funcional → Estaria na casca da cebola. O teste funcional ativa diversos outros componentes que não sabemos o que é (caixa-preta). Ex.: Teste de acesso a URL e verificar status.
Teste Unitário →  É quando uma unidade de código é completamente isolada e o teste é feito comente nesta parte. Ex.: teste do form, instanciar o form e testá-lo.
Teste de Regressão → É quando já tem algo acontecendo no sistema e percebe-se o efeito. A partir do efeito um teste é construído. Ex. Teste do Webkit (Chrome/Safari), é todo pautado em testes de regressão.
Teste de Aceitação → teste de comportamento do sistema na perspectiva do usuário (usa-se Selenium, webdriver, etc)

================================================
Os nomes args e kwargs são convenções
*args ⇒ arguments (positional arguments)
**kwargs ⇒ keyword arguments
unpacking ⇒ “*” = unpacking de tupla  e “**” = unpacking de dicionário


* Repositório não é só backup - é a história da evolução do projeto



http://pt.wikipedia.org/wiki/Python

Quem já conhece, quem nunca viu?

Quem já programou ou está apenas explorando a gramática ?

Quem trabalha com Python (não é PHD)

Python e Django
== Introdução ao Python ==

“Python fits your Mind” - Bruce Eckel


Python tem uma característica que poucas linguagens oferecem. Se você é um novato, está começando agora,  conseguirá programar em Python. Alguém já experiente, com muita bagagem, também conseguirá programar em Python.Não se trata de ter capacidade ou não, o fato é que a linguagem se molda naturalmente ao cérebro do desenvolvedor, à bagagem e à experiência dele, cultura adquirida como programador.


Tecnologia deve ser uma extensão natural do ser humano


* Homem Vitruviano: http://pt.wikipedia.org/wiki/Homem_Vitruviano_(desenho_de_Leonardo_da_Vinci)
Entender as relações entre as partes do homem, para entender as relações do homem com o mundo.


Python: A sintaxe é simples, mas nem por isso o poder é limitado.



== História == 

* Construído com software livre na veia
* por Guido Van Rossum
* em 1991, trabalhava em um laboratório de computação na Holanda, com sistemas operacionais e linguagens.
* Desenvolviam um novo sistema operacional denominado Amoeba, destinado à multimedia e educação.
* A tarefa de Guido foi a de desenvolver uma linguagem de script para o sistema operacional. Deveria ser uma linguagem fácil suficiente (sintaxe fácil)  e poderosa para baixar o nível quando necessário (controlar hardware, etc).
* Foi inspirada na linguagem ABC, premissa de isolar o programador das impurezas/imperfeições da máquina. Era totalmente empacotada (IDE, compilador, máquina virtual, debug, fechado… alto nível). Linguagem voltada a educação, para ensino de programação. (ver Painel da PyCon - Ramalho).
* Primeira versão desenvolvida do Python, Guido enviou mensagem para a Usenet com o código fonte da linguagem (rascunho/protótipo). A comunidade começou a se envolver/colaborar… desde o início a linguagem teve uma cultura de liberdade: feita de programadores para programadores.
* Não tem uma agenda oculta no desenv. da linguagem… não há uma grande corporação  envolvida com uma estratégia global de expansão, para dizer porque a linguagem é daquele jeito, ou que vai ter de interessante ou não.
* É um ambiente totalmente livre, qualquer um pode contribuir.
* É difícil ou não? Não interessa… o repositório é aberto.
* Através das PEPs (Python Enhancement Proposal) é possível questionar as decisões, participar, ter acesso ao repositório, enviar patches. Sem burocracia alguma.
* É a cultura da comunidade Python.
* Guido gosta muito do grupo de humor Monty Python, foi o que deu origem ao nome da linguagem. E muitas coisas são nomeadas baseando-se neste grupo.




=== Características da Linguagem ==

=> É uma linguagem de alto nível
Se aproxima mais do modelo mental do ser humano, e se afasta do modelo de execução da máquina.
Conseguimos se expressar de uma forma mais parecida de como a gente pensa.
Exemplos de linguagem: Matemática. Contagem (é a base da Matemática. Fazemos bem? As máquinas nos ajudam, pois é algo que se repete inúmeras vezes e a máquina faz bem)

=> Interpretada
Existe um programa, interpretador Python, que executa bytecodes gerados.
Faz o processo de parsing, compilação e interpretação dos bytecodes

=> Dinâmica
Muitas coisas são definidas em tempo de execução.
Pode-se usar código para gerar código (metaprogramação natural). DJango usa muito (estrutura de módulos) se apóia muito na capacidade de metaprogramação do Python (bem relevante)

=> Dinamicamente Tipada 
(oposto de estaticamente tipada - Exemplo Java, C - checagem primária, chega a ser desnecessária quando se tem o código testado)
A definição/checagem de tipo ocorre em tempo de execução.
Não se sabe o tipo dos elementos até que eles sejam usados/acessados.
Discussão eterna: vantagens e desvantagens.

=> Fortemente Tipada
(oposto de fracamente tipada)
Não se faz a coerção dos tipos. (Coerção o ato de induzir, pressionar ou compelir alguém a fazer algo pela força, intimidação ou ameaça)
Ex.: Nas linguagens PHP e JavaScript, se somarmos uma string a um número, não sabemos o que vai acontecer. No Python o resultado desta operação é muito claro: um erro. Pois não faz sentido somar um número e uma string.
Não faz a coerção do tipo de acordo com a posição dos itens nas operações.
Fica claro o que está acontecendo.

=>  Multi-paradigma

buzzword…
a maioria das linguagens estão se tornando multiparadigma
suporta diversos modelos mentais: estruturada, oo, funcional


“Zen of Python” - Tim Peters

É um Poema, uma inspiração (não é um manual, não é regra, não é manual de boas práticas)
ver: http://pt.wikipedia.org/wiki/Ensaio_sobre_a_Cegueira

* “Easter Egg”
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!

tradução:
http://pipeless.blogspot.com.br/2008/09/o-zen-de-python.html




== Python já vem com baterias - Battery Included ==

Python Standard Library
http://docs.python.org/2/library/
http://docs.python.org/3/library/
http://www.python.org/about/


== Python em uma página ==
http://coffeeghost.net/pybat/python_cheatsheet.png

Um arquivo “.py” é um módulo Python: arquivo texto que contém código fonte Python

* arquivo texto é processado pelo interpretador Python, que vai ler (fazer o parser) o código de cima pra baixo, da esquerda pra direita, que vai interpretando blocos de código (cada bloco).
Interpreta o módulo (texto) e transforma o código fonte (compila) em bytecodes, que são cacheados em arquivos .pyc (Python Cache - bytecode cacheado do processamento do módulo Python). (.pyo - Python Object - também é bytecode, mas não tem a função de cache).
* O namespace do Python é baseado em módulos
* O escopo do Python é isolado no módulo. Se for preciso usar código de outros módulos, é necessário importar os objetos definidos nos outros módulos, para o módulo em questão para que possamos usar estes objetos.
* Não há uma função “entry point” como o método main do Java.
* Guia de estilo: http://www.python.org/dev/peps/pep-0008/
* Indentação: http://pt.wikipedia.org/wiki/Indenta%C3%A7%C3%A3o
* Token de Indentação - 04 caracteres (O parser encontra o marcador de início de bloco e procura a diferença de indentação da próxima linha…). Convenção (não é padrão): 04 espaços, mas não há regra.
* Combinação entre tab e espaços… aceita… mas não é recomendável (diferença visual com o que o parser entende).
* String pode ser delimitada com aspas simples ou aspas duplas
* Escape  \’ ou \” - semelhante ao java
* Linguagem dinâmica - resolve nomes em tempo de execução… no momento em que o parser estiver rodando, define os objetos (função e nomes)... no momento da execução é feita a chamada da função…  Parsing -> Compilação -> Execução


__ - conhecido como “dunder” ou “tunder”

listas - slices sempre retornam uma nova lista

Range?

>>> range(0,10, 2)
[0, 2, 4, 6, 8]

>>> range(0, 20, 2)
out: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]


“fechado no começo, fechado no final”  [2:8[


foods = ["apples","oranges","rice","beans"]
    
for food in foods:
    print "I like to eat " + food
I like to eat apples
I like to eat oranges
I like to eat cats
I like to eat dogs



foods = ["apples","oranges","rice","beans"]

count = 0

while count < len(foods):
    print "I like to eat " + foods[count]
    count += 1
    
I like to eat apples
I like to eat oranges
I like to eat cats
I like to eat dogs


Tupla é uma sequência imutável. Importante quando a ordem importa (coordenada cartesiana)
coord = (1, 3, 5)

Dicionário  (não tem ordem)
d = {“a”:1, “b”:2, 3:”asdf”}
d.keys()  → apenas as chaves
d.values() → apenas os valores

for k, v in d.items():
    print k, v

for i, v in enumerate(foods):
    print i, v

Java → mundo da desconfiança. Nenhum código confia em outro código. Década de 90 fazia sentido, na época de componentes fechados… burocráticos
Python → Não precisa garantir o programador de si próprio. Somos todos adultos e vamos todos nos respeitar. Baseado no software livre. (proteção através de testes).

Interpolação  %  e  placeholders

São considerados semanticamente “false”:  
[]  (lista vazia)   
‘’  (string vazia)      
0 (zero)
None 
etc


Python não tem o conceito de void. Se a função não retornar nada de forma explícita, retorna None.


Entry point do Python
if __name__ == ‘__main__’:   # __name__ nome do módulo
    main()


O operador  ==  não compara id, mas sim os objetos (conteúdo). É um açúcar sintático para o método __eq  (é diferente do Java)


== Introdução ao Django ==

“Django é um framework web de alto nível escrito em Python que possibilita rápido desenvolvimento e design pragmático.”

Alto nível → mais próximo da nossa forma de pensar (não precisamos nos preocupar com os detalhes de implementação, protocolos envolvidos, etc). Foco na solução, e não na forma de construir a solução.

Possibilita rápido desenvolvimento → Ciclo de feedback / Ciclo de interação é rápido (servidor web embutido/nativo, drivers de BD, ferramentas de teste ,etc. Guia a facilidade… foco no programador (tem que ser fácil, amistoso, fácil de encontrar documentação). 
* O foco não é na tecnologia, mas sim no programador.

Design pragmático ⇒ não implementa a pureza do que é melhor no universo, implementa o que é prático… tem muitas coisas para melhorar



== WEB - O que é Web? == 

== Stateful x Stateless == 

RFC
http://www.ietf.org/rfc/rfc2616.txt
Procurar RFC para humanos


== HTTP Request
$ curl -iv http://welcometothedjango.com.br

GET / HTTP/1.1 
User­‐Agent: curl/7.19.7 (universal‐apple-­darwin10.0) libcurl/7.19.7
Host: welcometothedjango.com.br
Accept: */* 


== HTTP Response
$ curl --i http://welcometothedjango.com.br/

HTTP/1.1 200 OK
Server: nginx/0.7.65
Content--Type: text/html; charset=utf-8 
Cache-Control: max-age=600

<html>
<head> 
   <title>Welcome to the Django | Aprendendo Python e Django na prática!</title>
   <link rel="stylesheet" type="text/css" href="/static/css/screen.css" media="screen" />
</head>
<body>
  <h1>Welcome to the Django</h1>
</body>
</html>



== HISTÓRICO ==

* Lawrence Journal - Kansas - http://www2.ljworld.com/
* Problema: sites eram feito em PHP (macarronada). Lentidão para lançar as coisas.

* Criadores do Django
@adrianholovaty
@simonw (era o estagiário)

* Começaram a extrais itens do site existente e a migrar para o Python
HTTPRequest, HTTPResponse e vários scripts Python

@jacobian (linguista - entrou após a saída de @simonw)
Não é da computação. Um dos responsáveis pelo sucesso da documentação do DJango.

== ARQUITETURA ==

Model Template View

MVC 
Não funciona muito bem. Padrão criado para descrever a relação de desenvolvimento de aplicações desktop

MTV
View é uma janela para o sistema. Cada janela é um ângulo de visão. 
A View tem que ser pequena (regra). Se não for, tem algum problema.


== Comunidade Django

Django Project - http://djangoproject.com
Developers List - http://groups.google.com.br/group/django-developers
Users List - http://groups.google.com.br/group/django-users
Django Brasil - http://djangobrasil.org
Lista de Usuários - http://groups.google.com/group/django-brasil/


== FILOSOFIAS == 

https://docs.djangoproject.com/en/1.6/misc/design-philosophies/

=> Desenvolvimento rápido

=>  Don’t repeat yourself 
* Não é para não repetir linhas de código, é para não repetir propósito. 
* Dois códigos iguais com propósitos diferentes merecem existir como réplica, porque não é réplica, mas sim o propósito que indica o porque aquele código existe. 
* Se tiver dois códigos iguais que fazem a mesma coisa com o mesmo propósito, refatore e elimine duplicação.

=>  Menos código
Aproveitar a API para intensificar a prática de programar menos.

=> Acoplamento fraco

=> Consistência



== Timeline ==

2003 - Início
2005 ~ 2007 - Pré 1.0
2008 - Release 1.0
2009 - Release 1.1
2010 - Release 1.2
2011 - Release 1.3
2012 - Release 1.4
2013 - Release 1.5 e 1.6

Versões. 
Processo simplificado para se fazer a transição entre versões. 1.6 atual… 1.7 sendo lançada em meados de 2014.



== Quem usa Django?
http://www.djangosites.org

== Instalação ==

== Ferramentas de Trabalho ==

=> Python 2.7

=> Django 1.6

=> Git

=> Pip & Virtualenv

* Pip (Python Package Index)
https://pypi.python.org/pypi/pip
É um programa/pacote que gerencia a instalação de novos pacotes. Gerenciador de pacotes do Python

* Virtualenv 
http://www.virtualenv.org/en/latest/
* É um programa/pacote capaz de criar um sandbox para programação Python (Caixa de areia).
* Permite instalar várias versões de um pacote separadamente. 
* Caixa de areia para cada projeto. 
* Não instala nada no sistema, deixa só um Python puro no sistema, e cria um virtualenv para cada projeto. 
* É possível ativar e desativar o virtualenv. Quando se usa o PIP para instalar alguma coisa, é instalado no virtualenv ativo.

=>  Github.com

=>  Heroku.com (PAS)




== Instalação no Windows  ==

=> Python 2.7
http://python.org/ftp/python/2.7.6/python-2.7.6.msi

=> Distribute  (veio para substituir o SetupTools)
Novo sistema de pacotes do Python - O PIP usa o distribute.
http://python-distribute.org/distribute_setup.py

=> Heroku Tollbelt (Programa do Heroku, Git, Cygwin)
https://toolbelt.heroku.com/windows


=> Configurar a variável de ambiente PATH no
c:\Python27;c:\Python27\Scripts


== Instalação do PIP e VirtualEnv  (preferir fazer pelo GitBash) ==

$ easy_install pip
(easy_install é ligado ao SetupTools, que não será mais usado, apenas o pip).

$ pip install virtualenv

!!! São as únicas coisas instaladas no sistema. O restante é instalado em ambiente isolado


Verificação

$ python -V




== Instalação Linux (Debian/Ubuntu) ==


* Já vem com o Python instalado


* Receita de bolo para o caso o gerenciador de pacotes da distribuição Linux não funcionar direito. O recomendado é usar o gerenciador de pacotes.

== Instalação do PIP e VirtualEnv  (preferir fazer pelo GitBash) 

$ curl -O http://python-distribute.org/distribute_setup.py
** mudou: https://github.com/PolicyStat/chef-python/pull/2

$ sudo python distribute_setup.py

$ sudo easy_install pip

$ sudo pip install virtualenv


*** $ sudo apt-get install python-distribute

==  Heroku ==

Debian/Ubuntu

=> https://toolbelt.heroku.com/debian

Outras distribuições

=> https://toolbelt.heroku.com/standalone




== Instalação Mac  ==

* Lion
Já vem com o Python 2.7 instalado

* Versões anteriores
(Python 2.7) http://www.python.org/ftp/python/2.7.6/python-2.7.6-macosx10.6.dmg

* Recomendação
Usar o Homebrew (Gerenciador de Pacotes que compila as coisas para o seu sistema).

== Instalação do PIP e VirtualEnv  (preferir fazer pelo GitBash)

$ curl -O http://python-distribute.org/distribute_setup.py

$ sudo python distribute_setup.py

$ sudo easy_install pip

$ sudo pip install virtualenv


== Heroku Toolbelt ==
https://toolbelt.heroku.com/osx


== Python 2 ou Python 3 ==

Python 3 é excelente
O problema é que nem todas as bibliotecas foram portadas.




== PROJETO ==

=> Katá - passo-a-passo
=> Inicial - setup - preparar o ambiente de trabalho
=> Organizar o projeto e fazer um deploy simples, colocar o sistema no ar (mesmo que vazio). É a primeira coisa a ser feita, desde o início.


== Conheçam nossa Cliente ==

Sistema de Evento
Divulgação
Inscrição
Instruções via email
Gestão dos inscritos
...

== Landingpage? ==
Será entregue na primeira semana, apenas para divulgação. Primeiro Sprint.
Marketing para que o pessoal possa se inscrever depois.

Navegador: Página simples, informando os dados do evento, mensagem de boas vindas, etc. Layout básico, a ideia é melhorar.

== Fazer o setup/preparação do ambiente de trabalho 

# primeiro passo - Cria um virtualenv
# cria o diretório e no diretório já fica preparado todo o ambiente do virtualenv
$ virtualenv bvad

# entra no “diretório do projeto”
$ cd bvad

# Ativa o virtualenv no Windows
$ Scripts\activate

# Ativa o virtualenv no Linux ou Mac
$ source bin/activate

# para desativar
$ deactivate

# Com o virtualenv ativado - Instalar o Django
# Instala o Django no Virtualenv
$ pip install django==1.6

# Dica / Macete para quem usa Windows
# O Django vem com um comando chamado django-admin (.py)
# que é usado para criar um projeto

# Windows hack para facilitar o uso do django-admin
# Crie o django-admin.bat para chamar o django-admin.py
$ echo @python “%VIRTUAL_ENV%\Scripts\django-admin.py” %* > “%VIRTUAL_ENV%\Scripts\django-admin.bat”


# Cria o projeto Django no diretório atual (bvad) - Windows
# Não esquecer o “.” no final
# se não usar o “.” no final, vai criar o diretório “platestrum” e outro
#  diretório projeto “palestrum” dentro dele.
$ django-admin startproject palestrum . 

# Cria o projeto Django no diretório atual (bvad) - Linux ou Mac
# Não esquecer o “.” no final
$ django-admin.py startproject palestrum . 


* Estrutura de arquivos esperada
* O diretório “palestrum” é um “Python Package”, pois tem o arquivo __init__.py
bvad
  manage.py
  palestrum/
    __init__.py
    settings.py
    urls.py
    wsgi.py



# para saber se está funcionando
# apresentará saída com… Usage:...
$ python manage.py


!!! MACETE: para facilitar a navegação de diretórios do projeto

# Se você estiver em bvad/  (ruim)
python manage.py help

# Se você estiver em bvad/palestrum  (ruim)
python ../manage.py help

# Se você estiver em bvad/palestrum/core/templates  (ruim)
python ../../../manage.py help

# Para generalizar, só um caminho absoluto  (ruim)
/bvad/bin/python /bvad/manage.py help


# todos as anteriores não são boas alternativas
# De “qualquer lugar”, o que se quer é digitar apenas:
$ manage help


# No Windows
# Criar o arquivo bvad\Scripts\manage.bat:
@python “%VIRTUAL_ENV%\manage.py” %*

# no Mac ou Linux
# Criar um alias no seu ~/.bashrc ou ~/.profile
alias manage='python $VIRTUAL_ENV/manage.py'


# Ativar o servidor de desenvolvimento do Django
# Não deve ser usado em produção “jamais”. Apenas para desenvolvimento. 
# Não suporta concorrência
$ manage runserver

# Acessar do browser para testar
http://127.0.0.1:8000


== Configuração do Banco de Dados ==

Recomendação: Usar o Unipath
O unipath é uma biblioteca que oferece uma API O.O. para manipular arquivos e diretórios
http://sluggo.scrapping.cc/python/unipath/Unipath-current/README.html

# Com o virtualenv do projeto ativado
# instala o unipath no virtualenv do projeto
$ pip install unipath

arquivo: palestrum/settings.py
# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
#import os
#BASE_DIR = os.path.dirname(os.path.dirname(__file__))
from unipath import Path
BASE_DIR = Path(__file__).parent

DATABASES = {
        'default': {
          'ENGINE': 'django.db.backends.sqlite3',
          #'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
          'NAME': BASE_DIR.child('db.sqlite3'),
        }
}

# Finalizada a modificação do arquivo, executa-se o comando syncdb que criará
# a base de dados no sqlite por padrão, na máquina local, e criará todas as tabelas
# e estrutura
# Configurar usuário e senha admin/admin, pois está em desenvolvimento e certamente
# esqueceremos
$ manage syncdb

# DICA
# Vale a pena dar uma boa olhada em todas as opções disponíveis para o
# arquivo settings.py (arquivo muito importante, basicamente define o projeto)
# https://docs.djangoproject.com/en/1.6/topics/settings



!!! Aqui termina a criação do projeto… é basicamente só isso


== Django App ==

* É um pacote Python que contém um módulo models.py (e que pode ser instalada no apps).

# Criando uma app core em bvad/palestrum
# dica: não perder tempo buscando um nome especial para a app. 
# Começar com “core”
# … entulhe tudo na app “core” (app de comentário, app de contato, etc)
# ... depois refatore em outras apps
# … trate tudo como uma coisa só, depois faça um esquema de transbordo 
# … (o código pede “- ME TIRE DAQUI E ME COLOQUE EM OUTRA APP!” - refatoração)
# … o que não é bom é ter apps dependentes de outras apps

=> 1o. passo
$ cd palestrum
$ manage startapp core


* Estrutura de diretórios esperada
** obrigatório mesmo para uma app é o models.py
bvad
  manage.py
  palestrum/
    __init__.py
    settings.py
    urls.py
    wsgi.py
    core/
      __init__.py
      admin.py
      models.py
      tests.py
      views.py




=> 2o. passo
# Instalar a APP

arquivo: palestrum/settings.py
. . .

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'palestrum.core',
)


=> 3o. passo
# Montar um hello World

arquivo: palestrum/urls.py
from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'palestrum.views.home', name='home'),
    # url(r'^blog/', include('blog.urls')),

    url(r'^$', 'palestrum.core.views.home', name='home'),
    url(r'^admin/', include(admin.site.urls)),
)





=> 4o. passo - Implementar uma view simples

* Toda view no Django tem a seguinte definição: é um callable Python, uma função ou um objeto que implementa  o método __call, que recebe como primeiro  argumento o request, e retorna obrigatoriamente um response.

arquivo: palestrum/core/views.py
# coding: utf-8

from django.http import HttpResponse

def home(request):
    return HttpResponse('Bem-vindo ao Palestrum!')

# pronto!
# executar o “manage runserver” e acessar a url http://127.0.0.1:8000



== HTML ==

=> Onde colocar os templates?
Os templates são inseridos dentro da App Core.
O Django é muito flexível.

# Criar o diretório
bvad/palestrum/core/templates

# Dentro deste diretório, criar o arquivo index.html.
bvad/palestrum/core/templates/index.html

Conteúdo:
<h1>Bem-vindo ao Palestrum!</h1>

=> Agora faremos a view usar o template 

modificar o arquivo: palestrum/core/views.py
# coding: utf-8

from django.http import HttpResponse
from django.template import loader, Context

def home(request):
    t = loader.get_template('index.html')
    c = Context()

    content = t.render(c)

    return HttpResponse(content)

Template é um objeto de alto nível, não é um texto. O resultado do render é que de fato é uma string.
É possível cachear todos os objetos templates para não ir mais ao disco para ler o texto, e utilizar apenas um objeto template para renderizar várias vezes.

=> pronto!  executar o “manage runserver” e acessar a url http://127.0.0.1:8000
* agora o resultado é em HTML

=> mas e se quiser alterar o port HTTP do servidor?
$ manage help runserver
# mostra o help do runserver e temos a informação de como modificar o port
== Refatorar a view home ==

arquivo: palestrum/core/views.py
# coding: utf-8

from django.shortcuts import render_to_response

def home(request):
    return render_to_response('index.html')
* render_to_response ⇒ passa qual é o html, e ele devolve uma instância de HttpResponse. Trabalha isolado, não tem nenhum vínculo com o request. Apenas pega o texto, processa ele, e devolve o response.
* Se quiser passar um contexto? Obter o contexto e passar como segundo parâmetro.
* Não é o ideal.

=> pronto! executar o “manage runserver” e acessar a url http://127.0.0.1:8000
* Não é a melhor maneira de se fazer


== Dá para inserir um logotipo e deixar bonitinho? ==

=> preparar o projeto

# estando no diretório bvad/palestrum

# criar os subdiretórios para os assets
# macetão de bash
$ mkdir -p core/static/{img,css,js}

=>  Crie uma logo e um css

# Adicione uma logo ao projeto em
$ cp umalogo.png core/static/img/logo.png

# Crie o stylesheet do site
$ cp somestyle.css core/static/css/style.css

#Ou copie.. -.-
CSS: http://bit.ly/css-eventex
Logo: http://bit.ly/logo-do-eventex
Html: http://bit.ly/html-landingpage

arquivo (original): index.html
<!doctype html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="description" content="Palestrum" />
  <meta http-equiv='content-Language' content='pt-BR' />
  <link type="image/x-icon" href="{{ STATIC_URL }}favicon.ico" rel="shortcut icon" />

  <title>Palestrum</title>

  <link type="text/css" href="{{ STATIC_URL }}css/style.css" rel="stylesheet" media="screen" />

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js"></script>
</head>
<body>
  <div id="page">
    <div id="header">
      <center>
        <img src="{{ STATIC_URL }}img/logo.png" alt="Palestrum" />
      </center>
    </div>
    <hr>
    <div id="content">
      <h1>Bem-vindo ao Palestrum!</h1>
      <p>Tudo sobre farofa pronta e caldo de cana!</p>
      <p>Você não pode perder esta oportunidade!</p>
      <p><strong>Abertura das inscrições no próximo domingo.</strong></p>
      <p>Para dúvidas e mais informações entre em contato com <a href="mailto:contato@palestrum.com.br">contato@palestrum.com.br</a></p>
    </div>
    <hr>
    <div id="footer">
      <p>&copy; 2012. <a rel="license" href="http://www.google.com">Google</a>, some rights reserved. <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/br/80x15.png" /></a><a href="http://www.djangoproject.com/" id="django"><img src="https://djangoproject.com/s/img/badges/djangosite100x25.gif" border="0" alt="A Django site." title="A Django site." /></a></p>
    </div>
  </div>
</body>
</html>




== Implementar o HTML da landing page

arquivo: palestrum/core/templates/index.html
<!doctype html>
<html>
<head>
  <title>Palestrum</title>
  <link type="text/css" href="{{ STATIC_URL }}css/style.css"
        rel="stylesheet" media="screen" />
</head>
<body>
  <img src="{{ STATIC_URL }}img/logo.png" />
  <h1>Bem-vindo ao Palestrum!</h1>
  <p>Tudo sobre farofa pronta e caldo de cana!</p>
</body>
</html>

Navegador: Ao executar no navegador (http://127.0.0.1:8000), os recursos não estão sendo exibidos corretamente (ver log)

Deveria funcionar, pois o template está usando a variável STATIC_URL.

A view está usando render_to_response, que está seguindo sem “contexto” (contexto vazio).

!!! Um contexto é um dicionário de dados que o template usa para renderizar/preencher as lacunas.

Quando se tem um template para listar imóveis, deve-se passar uma lista de imóveis no contexto. O template é só a apresentação, o dado a ser apresentado vem através do contexto.



== Refatore - Indique o contexto ao render do template ==

arquivo: palestrum/core/views.py
# coding: utf-8

from django.shortcuts import render_to_response
from django.conf import settings

def home(request):
    context = {'STATIC_URL': settings.STATIC_URL}
    return render_to_response('index.html', context)

Importante! Para obter o settings do Django
sempre: from django.conf import settings
jamais: from palestrum import settings  # arquivo de configuração que o Django carrega

* o settings do Django é um objeto. Nunca importe o arquivo, sempre o objeto.

Navegador: Ao executar no navegador (http://127.0.0.1:8000), os recursos não são apresentados de forma correta

== Mas … Fazer isso em todas as views???? Refatorar… ====

== DRY. Use o RequestContext! ==

arquivo: palestrum/core/views.py
# coding: utf-8

from django.shortcuts import render_to_response
from django.template import RequestContext

def home(request):
    context = RequestContext(request)
    return render_to_response('index.html', context)
* RequestContext ⇒  é especial, pois herda de context, e implementa o que é conhecido como context processors. O Django já vem com vários context processors funcionando, e um deles é um que já injeta no contexto aquele STATIC_URL padrão (já fica disponível)
* Quando criar o meu próprio context processor? R: Quando precisar disponibilizar algo comum em todos os templates. Não fica passando explicitamente na view, cria um context processor pra isso. (Ex.: menu do site)
Navegador: Ao executar no navegador (http://127.0.0.1:8000), funciona corretamente

== DRY++  (Shortcuts) ==

O que foi mostrado até agora é muito útil para um cenário mais específico. Para simplesmente apresentar um template nada disso é necessário, pois o Django já vem com uma view “render” (já cria o request context, encontra o template, renderiza e retorna um HttpResponse). 

Mas são raríssimas as vezes em que a view é simples.

arquivo: palestrum/core/views.py
# coding: utf-8

from django.shortcuts import render

def home(request):
    return render(request, 'index.html')
* O “render” é uma view, pois recebe um request como primeiro parâmetro na função, e obrigatóriamente retorna uma HttpResponse.
* O render_to_response é considerado um anti-pattern. Não é recomendado.

Navegador: Ao executar no navegador (http://127.0.0.1:8000), funciona corretamente


== O que foi feito até agora foi para mostrar a regra do design do desenvolvimento/xp
design incremental
“make work” ????
“make right” ????
maked fast se necessário
. . .





== KISS++  : Template Tag

https://docs.djangoproject.com/en/dev/howto/static-files/

Melhorias que podem ser feitas. 
O link anterior mostra como alterar o template para usar um “template tag” static. Dessa forma, ao invés de usar a variável de contexto STATIC_URL, passa a usar o template tag. É o padrão quando se quer usar com a Amazon, por exemplo.

== Dúvidas sobre arquivos estáticos? ==
http://henriquebastos.net/entendendo-a-relacao-entre-o-django-e-arquivos-estaticos/
(* Importante ler.)




== Como o Django sabe onde estão os templates? ==

Por padrão o Django vem com dois template loaders, sendo:
- filesystem Loader
e/ou
- appdirectories Loader

Exemplo de settings.py
from unipath import Path
BASE_DIR = Path(__file__).parent

# ...

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_DIRS = (
    #BASE_DIR.child('core/templates'),
)

* O mecanismo de templates do Django delega para os itens existentes em TEMPLATE_LOADERS a tarefa de encontrar o template com o nome indicado.

*  Poderíamos implementar um “database” Loader, em que os templates estivessem armazenados em um banco de dados.

* O Django procura pelos templates na ordem dos Loaders. Neste caso, primeiro procura pelo o filesystem, depois pelo app_directories.

* O Filesystem Loader vem desconfigurado por padrão. Pois depende de uma variável chamada TEMPLATE_DIRS, que também está vazia por padrão.

* Quando a TEMPLATE_DIRS está vazia, o filesystem Loader não tem referência de nenhum diretório em que deveria fazer as buscas, logo ele passa para o próximo que é o app_directories Loader.

* O app_directories Loader, pega a lista de diretórios das INSTALLED_APPS, percorre o diretório de cada app (na ordem em que se encontram as apps), verifica se a app tem um diretório templates, e procura o template neste diretório.


* É um mecanismo sequencial e que permite sobreposição. Ex.: É possível modificar o template do admin do Django, inserindo uma app que tenha no seu diretório templates um subdiretório admin com os templates do admin modificados, e modificar a ordem da nova app para que fique posicionada antes da app admin do Django (em INSTALLED_APPS).

* Quando usar o filesystem e quando usar o app_directories?
R.: Usar filesystem Loader faz mais sentido quando se trabalha com temas.
Geralmente o template do Django terá pouca coisa de estrutura de layout. Tem um template base que será praticamente o layout da aplicação, e os outros templates herdados ou extendidos, são coisas muito específicas de uma app (de como a app apresenta os dados para aquela view). Bem amarrado.

* Suposta estrutura de arquivos, para entender quando cada Loader pode ser acionado
bvad
  palestrum/
    ...
    templates/                    # filesystem.loader
        index.html
    core/
        ... 
        templates/                # app_directories.loader
            about.html
            core/
                contato.html
    subscriptions/
        ... 
        templates/                # app_directories.loader
            subscriptions/
                subscriptions_form.html

O que o Django enxerga?

# Lista de Templates como o Django detecta
  index.html
  about.html
  core/contato.html
  subscriptions/subscriptions/subscriptions_form.html

* (Boa Prática) É uma boa prática repetir o subdiretório com o nome da app no diretório templates da app, para que o loader encontre o template caso haja um outro template com o mesmo nome.
Ex.:  core/templates/core/contato.html

== Anatomia do Template ==

<!doctype html>
<html>
<head><title>Palestrum</title></head>
<body>
  <img src="{{ STATIC_URL }}img/logo.png" />
  <h1>Parabéns {{ subscription.name }}!</h1>
  <p>
      Sua inscrição foi realizada em
      {{ subscription.created_at|date:"d/m/Y" }}.
  </p>
  <p>
      Em breve alguém entrará em contato pelo
      {% if subscription.phone %}
          telefone {{ subscription.phone }}.
      {% else %}
          e-mail {{ subscription.e-mail }}.
      {% endif %}
      
  </p>
</body>
</html>

{{ }}  ⇒  são template variables (não é código Python, apenas parece)
{% %} ⇒ são template tags


== O ponto-chave - Como é feito o parser?  ==

Exemplo: {{ subscription.name }}

1.  “name” é uma chave do dicionário “subscription”?
subscription[name]

2. “name” é um atributo do objeto “subscription”?
subscription.name

3. “name” é um método que não recebe parâmetros do objeto “subscription”?
subscription.name()




== Template Filters ==

{{ subscription.created_at|date:"d/m/Y" }}

* subscription.created_at é um atributo de subscription, cujo tipo é datetime do Python. É um objeto datetime passado no contexto, e não é o texto da data.

* No template é que é feita a formatação para dia/mês/ano: |date:"d/m/Y"

* Separa bem a responsabilidade da view e do template, e simplifica a vida do designer que produz/mantém o template. Filosofia do Django: o template é do designer.

Outros exemplos:

{{ text|escape|linebreaks }}
escape - faz o escape do HTML (Html encoding)
linebreaks - transforma o \n em <br />

{{ text|truncatewords:"30”}}


== Template Tags ==

* São um pouco mais complexos de implementar

* forma:  {%   %}

* O Django tem várias tags prontas. É muito raro ter que implementar um template tag novo.
https://docs.djangoproject.com/en/1.6/ref/templates/builtins/


== Mídias estáticas (css js png jpg ico etc) ==

Diferença: Media vs Static
{{ MEDIA_URL }}  vs  {{ STATIC_URL }}

Static ou Assets 
todos os arquivos que são parte do projeto (css, js, png, jpg, ico, etc)
Media 
São arquivos enviados ao sistema pelo usuário (foto de perfil, anexo, etc)


== Como o Django sabe onde estão os assets? ==

É o mesmo esquema dos “template loaders”. Neste caso, temos os “static loaders”.
No settings default do Django

 arquivo: $PROJ_HOME/lib/python2.7/site-packages/django/conf/global_settings.py
# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/var/www/example.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT.
# Examples: "http://example.com/media/", "http://media.example.com/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Example: "/var/www/example.com/static/"
STATIC_ROOT = ''

# URL that handles the static files served from STATIC_ROOT.
# Example: "http://example.com/static/", "http://static.example.com/"
## STATIC_URL = None
STATIC_URL = '/static/'

# ...

###############
# STATICFILES #
###############

# A list of locations of additional static files
STATICFILES_DIRS = ()

# The default file storage backend used during the build process
STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.StaticFilesStorage'

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)


* STATICFILES_DIRS ⇒  Lista de diretórios em que são procurados os arquivos estáticos

* STATICFILES_STORAGE ⇒ é quem fará a operação “collectstatic”

* STATICFILES_FINDERS
FileSystemFinder - Se apoia no STATICFILES_DIRS
AppDirectoriesFinder - Percorre o diretório das apps e verifica se há um diretório /static/. Caso positivo, busca o arquivo neste diretório.

* Mas e para usar a AmazonAWS?
Alterar o STATICFILES_STORAGE para um storage que consegue gravar arquivos na AWS (os finders permanecem, pois os finders indicam ao Django como encontrar os arquivos estáticos enquanto código fonte).
O storage é, uma vez que encontrou uma lista de arquivos estáticos do projeto, precisamos colocar eles na AWS. É o STATICFILES_STORAGE quem pega estes arquivos e faz o upload deles para a AWS.

No caso de estar usando o padrão que é o StaticFilesStorage, um novo diretório é criado no disco local e os arquivos estáticos são copiados pra lá, e tudo será servido a partir de lá.

!!! Em produção, o Django não lê através dos STATICFILES_FINDERS. É preciso uar o comando “collectstatic”, que usa o storage para criar um novo repositório com todos os arquivos. Isso é feito porque há arquivos que são do projeto e os arquivos do admin do Django (templates, js, etc), e estes são arquivos que precisam ser reunidos do diretório de destino para que o webserver consiga servir estes arquivos.

* www.mercurytide.co.uk/media/resources/django-cheat-sheet-a4.pdf
* tudo explicado aqui: http://henriquebastos.net/entendendo-a-relacao-entre-o-django-e-arquivos-estaticos/

Importante (settings): O Django é configurado com o global_setttings.py, fazendo o merge (sobreposição) com o que está configurado no settings.py do projeto. No arquivo settings.py do projeto, tente deixar somente as configurações que não são equivalentes às configurações globais do Django ($PROJ_HOME/lib/python2.7/site-packages/django/conf/global_settings.py).

* STATIC_ROOT ⇒  diretório onde estão os arquivos estáticos

* STATIC_URL ⇒  é a url onde estão os arquivos estáticos
Em modo de debug, o Django cria uma rota especial para STATIC_URL servir arquivos estáticos. Quando uma requisição chega, casando com este caminho, o Django procura dentro do STATIC_ROOT a existência o recurso solicitado.


== Acesso à um asset == 

Ex.:  http://127.0.0.1:8000/static/img/logo.png

1) GET /static/img/logo.png
* o /static/img/logo.png será verificado. A parte img/logo.png será então pesquisada em STATIC_ROOT, que por enquanto (debug) vai encontrar na app core, pois os finders procurarão nos diretórios das apps (igual ao que ocorre com os templates).

2) url(r'^static/(?P<path>.*)$', 'django.contrib.staticfiles.views.serve')
STATIC_URL
* O Django injeta uma rota que é capaz de capturar as requests que contenham o caminho /static e passa para a view django.contrib.staticfiles.views.serve

3) server(request, path='img/logo.png')
STATIC_ROOT
* Essa view serve o arquivo através de uma HttpResponse, com o recurso codificado em Base64.

4) HttpResponse




== Onde posso ver o que já foi feito? ==

“É a entrega que faz o sucesso do orador”  - Johann Wolfgang von Goethe

Não adianta funcionar na máquina de desenvolvimento, tem que estar online. O usuário tem que ver cada feature que vai sendo implementada.
Sprint de 15 dias para mostrar alguma coisa para o cliente serve apenas para quando a equipe está bagunçada. O objetivo é implantar diariamente o trabalho que foi feito no dia, para que o cliente possa experimentar as features, para obter feedback e para que a coisa toda possa evoluir.




== Django e boas práticas para organizar a aplicação para deploy ==

== Banco de Dados e 12 Factor ==
https://pypi.python.org/pypi/dj-database-url/

Configurar o banco de dados de uma forma que ele funcione simultaneamente na máquina de desenvolvimento, na máquina de produção e na máquina de stage/homologação.


# Com o virtualenv ativado - Instalar a lib dj-database-url
$ pip install dj-database-url==0.2.2
* dj-database-url - foi criado pelo Heroku, com base no twelve factors (12 Factor)

* Ler o 12 Factors - Recomendações sobre o que fazer para se ter uma aplicação escalável (construir um verdadeiro SaaS)  ⇒  http://12factor.net/

arquivo: palestrum/settings.py
. . .

import dj_database_url
from unipath import Path
BASE_DIR = Path(__file__).parent

. . .

DATABASES = {
        'default': dj_database_url.config (default='sqlite:///' + BASE_DIR.child('db.sqlite3'))
}
* O dj_database_url tenta buscar a variável de ambiente DATABASE_URL, usada pelo Heroku, que aponta para o banco de dados da plataforma. Caso a informação não seja encontrada, faz um fallback e usa o default (sqlite).
* A função config retorna um dicionário de configuração do BD do Django. O que está sendo feito aqui é a substituição do dicionário de configuração por uma URL que será processada através da função config.




== Deploy de mídias estáticas #comofaz? ==

== Asset no Heroku ==

https://pypi.python.org/pypi/dj-static

* O filesystem do Heroku é volátil. Neste caso, quem servirá os arquivos estáticos é o BD, ou teremos que jogar no AWS.
* Para resolver isso, já que o Django não serve os arquivos estáticos em produção, será feita a instalação do dj-static.

# Com o virtualenv ativado - Instalar a lib dj-static
$ pip install dj-static==0.0.5


arquivo: palestrum/settings.py
. . .


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.6/howto/static-files/

STATIC_ROOT = BASE_DIR.child('staticfiles')
STATIC_URL = '/static/'
* Apenas static, pois não dá para tratar “media” no Heroku. Teria que ser na AWS.

Agora, altera-se o servidor wsgi do Django

arquivo: palestrum/wsgi.py
. . .

import os
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "palestrum.settings")

from django.core.wsgi import get_wsgi_application
from dj_static import Cling

application = Cling(get_wsgi_application())
* Cling sabe servir recursos estáticos, e o get_wsgi_application é o padrão do Django que não sabe. Juntando os dois, passamos a ter uma outra aplicação que sabe servir recursos estáticos em produção. 

== Wsgi de Produção ==

http://gunicorn.org

! O runserver do Django não serve para produção, será usado o gunicorn


# Com o virtualenv ativado - Instalar o gunicorn
$ pip install gunicorn==18.0


É necessário indicar para o Heroku como é que ele inicia a aplicação. Como é que ele dá um start no Django. Para isso, será criado o arquivo  bvad/Procfile

arquivo (novo): bvad/Procfile
web: gunicorn palestrum.wsgi
* wsgi ⇒ interface de serviço web do Python


== Informar as dependências do projeto ==

No ambiente de desenvolvimento, várias coisas foram instaladas. Quando for pra produção, tem que haver um mecanismo capaz de instalar tudo novamente lá no novo ambiente.

arquivo (novo): bvad/requirements.txt
Django==1.6
Unipath==1.0
dj-database-url==0.2.2
dj-static==0.0.5
gunicorn==18.0
psycopg2==2.5.1
* psycopg2 ⇒ driver do PostgreSQL. É uma extensão do PostgreSQL com Python.
* Não tem no nosso projeto, mas é necessário que seja instalado no Heroku.
* Na máquina de desenvolvimento pode não haver uma instalação do PostgreSQL. Algumas coisas que serão compiladas no ambiente de produção dependem do psycopg2.
* Foi assumido que: desenvolvimento=sqlite   e   heroku=postgresql





== Repositório de Código  #comofaz? ==

Para enviar para o Heroku, é necessário criar um repositório de código.

Tutorial de Git: http://www.akitaonrails.com/2010/08/17/screencast-comecando-com-git

== Preparação do repositório ==

# Configurar o seu Git
$ git config --global user.name "Seu Nome"
$ git config --global user.email "seu@email.com"

== Iniciando o repositório ==

# Iniciando o repositório (diretório raiz do projeto)
$ cd bvad
$ git init

== Ignorando arquivos ==

Arquivos que não devem fazer parte do repositório. Manter no git apenas código fonte.

arquivo (novo): bvad/.gitignore
bin
build
include
lib
local
man
share
Scripts
.Python
*.pyc
*~
*.sqlite3
.DS_Store




== Commit inicial ==

$ git add .gitignore

$ git commit -m "Despreza os arquivos que nao fazem parte do projeto"
[master (root-commit) bbcd363] Despreza os arquivos que nao fazem parte do projeto
 1 file changed, 13 insertions(+)

$ git status

# No ramo master
# Untracked files:
#   (use "git add <arquivo>..." para incluir o que será submetido)
#
#    Procfile
#    manage.py
#    palestrum/
#    requirements.txt
nothing added to commit but untracked files present (use "git add" to track)

== Gravar o projeto no repositório ==

# No diretório bvad
# enviar o restante do projeto para o repositório 
# (todos os untracked files do diretório atual)
$ git add .

$ git commit -m “Todos os dados no repositorio”
[master 8fa3614] Todos os dados no repositorio
 15 files changed, 501 insertions(+)
 create mode 100644 Procfile
 create mode 100755 manage.py
. . . 
 create mode 100644 palestrum/wsgi.py
 create mode 100644 requirements.txt

$ git status
# No ramo master
nada a submeter, diretório de trabalho vazio



== Heroku ==
Criar uma conta gratuita ⇒  https://www.heroku.com/

== Heroku Auth ==

# inicie uma sessão com o Heroku Toolbelt

$ heroku login
Enter your Heroku credentials.
Email: zanata@gmail.com
Password (typing will be hidden): 
Authentication successful.

# No meu caso, tive que adicionar outra chave
$ heroku keys:add ~/.ssh/zanatabr10_rsa.pub
Uploading SSH public key /home/azanata/.ssh/zanatabr10_rsa.pub... done
* Para usuários windows, recomenda-se usar o GitBash
** Fornecer credenciais (Uma chave pública será criada caso não seja encontrada uma)

== Heroku Stack ==

# crie uma stack no Heroku (projeto)

$ heroku create NOME_DA_APP
$ heroku create palestrum
Creating palestrum... done, stack is cedar
http://palestrum.herokuapp.com/ | git@heroku.com:palestrum.git
Git remote heroku added

# Configure o stack para o collectstatic
$ heroku labs:enable user-env-compile
Enabling user-env-compile for palestrum... done
WARNING: This feature is experimental and may change or be removed without notice.
For more information see: http://devcenter.heroku.com/articles/labs-user-env-compile
* Importante: no processo de deploy do Django no Heroku, é necessário executar o collectstatic para coletar todos os arquivos estáticos e criar um diretório staticfiles, de onde os arquivos serão servidos. É necessário avisar a nossa intenção ao Heroku, pois por padrão o Heroku é todo seguro, restrito em relação às variáveis de ambiente do projeto. (Ignorar o Warning)

== Heroku Open ==

# veja sua stack no browser
$ heroku open
** abre um navegador com a aplicação sendo apresentada

== No ar! ==

# veja sua stack no browser
$ git push heroku master --force
Initializing repository, done.
Counting objects: 28, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (21/21), done.
Writing objects: 100% (28/28), 10.61 KiB, done.
Total 28 (delta 1), reused 0 (delta 0)

-----> Python app detected
-----> No runtime.txt provided; assuming python-2.7.6.
-----> Preparing Python runtime (python-2.7.6)
-----> Installing Setuptools (2.1)
. . .
       Cleaning up...
-----> Collecting static files
       71 static files copied.
-----> Discovering process types
       Procfile declares types -> web
-----> Compressing... done, 34.9MB
-----> Launching... done, v5
       http://palestrum.herokuapp.com deployed to Heroku

To git@heroku.com:palestrum.git
 * [new branch]      master -> master

* pega o branch master do repositório local e envia para o branch master do repositório git no Heroku, e o Heroku dispara o mecanismo de deploy, além de vários outros comandos, habilitando a aplicação.

* --force ⇒  é para facilitar a vida . O git não deixa sobrescrever se há algum problema na árvore do git. Isso resolve os problemas para efeito de deploy.

== Demonstração feita ==

# posicionado no diretório da aplicação (bvad)

#destruir a app já criada.
$ heroku help apps
$ heroku apps:destoy -app nome_da_app

# criar a app
$ heroku apps:create -app nome_da_app

$ heroku open

$ git push heroku aula-1:master --force


== Como o comando heroku sabe das coisas? (Dica!) ==

$ git remote -v

heroku git@heroku.com:palestrum.git (fetch)
heroku git@heroku.com:palestrum.git (push)


== E ser algo errado com o comando heroku? (Dica!) ==

# Liste os comandos disponíveis
$ heroku help

# Veja os logs do heroku
$ heroku logs





== Compartilhe ==

Crie uma conta no Github.com
Adicione sua chave ssh à sua conta
Crie um repositório remoto
Publique o seu código palestrum no Github
Envie à lista o link do seu repo no Github
Envie à lista o link da sua app no Heroku


=== P&R ==

Há alguma forma de centralizar os “site filters” para que eles reflitam na aplicação toda?
Estratégia: Criar uma app chamada de templatestuff e inserir as “custom tags” e “custom filters” nesta app. Ajuda na centralização.









== Divagações do início da aula ==

Quanto detalhe, quanta sutileza tem para começar o trabalho. Reforça o quão importante é o começo do projeto e quanto os desenvolvedores ignoram toda a complexidade de organizar o ambiente para trabalhar (repositório, arqs e ferramentas para deploy, para preparar o ambiente, para facilitar a contribuição de outros desenvolvedores, isolamento de ambientes, bibliotecas usadas,…). Há muita sutileza.

Quando tudo isso é ignorado no início do projeto e se inicia a modelagem de BD, fatalmente o projeto tende a dar errado.

SW tem características diferentes: é maleável demais, é muito abstrato. Uma das características esperadas do desenvolvedor é melhorar a capacidade de abstração, mas no mundo real é normal que o desenvolvedor costume desrespeitar os seus limites de abstração, e entulha a mente de coisas que não consegue organizar: Síndrome do Arquiteto Astronauta.  Como evitar isso ao máximo? Como programar passo-a-passo com pragmatismo?

== O que é essa página amarela? ==

Navegador: Ao acessar o endereço de uma página inexistente (exemplo: http://palestrum.herokuapp.com/pagina-inexistente ), o sistema apresenta uma página de erro.


* Importante: Não enviar para produção com a opção de debug ligada.
== Configurações de Instância ==

https://pypi.python.org/pypi/django-decouple/

Solução: configurar o sw/projeto de forma a separar o parâmetro de configuração do módulo do software. Deve ser desacoplado do software.

# com o virtualenv do projeto ativado
# Instale a lib django-decouple
$ pip install django-decouple==2.1

* django-decouple ⇒ biblioteca desenvolvida por Henrique Bastos para desacoplar a configuração do projeto da configuração da instância. O Django não faz muito bem essa separação (settings.py).

* lê as configurações de instância de um arquivo “ini”, ou de um arquivo “env” (usado pelo Heroku - chave/valor). Vale a pena dar uma olhada no código fonte para ver como funciona.

* Configuração do projeto = apps instaladas, middlewares, context processor…

* Configuração da instância = e-mail do admin, flag de debug, bd…. cada instãncia do projeto terá a sua configuração.

A ideia é acabar com a bagunça dos settings (um para desenvolvimento, outro para produção, outro para stage) e ter apenas um settings.


arquivo: bvad/.env
SECRET_KEY=SECRET-KEY-DO-SEU-SETTINGS_SEM_ASPAS
DEBUG=True
* Não é para ser comitado (enviado para o repositório), pois faz parte do ambiente
* Não pode ter espaços em branco entre os atributos, o sinal de igual e o valor (teste feito).
* adicionado .env ao arquivo .gitignore




arquivo: palestrum/settings.py
from decouple import config
from dj_database_url import parse as db_url
from unipath import Path
BASE_DIR = Path(__file__).parent

SECRET_KEY = config('SECRET_KEY')

DEBUG = config('DEBUG', default=False, cast=bool)
TEMPLATE_DEBUG = DEBUG

#...

DATABASES = {
    'default': config(
        'DATABASE_URL',
        default='sqlite:///' + BASE_DIR.child('db.sqlite3'),
        cast=db_url),
}

* Leitura: import dj_database_url import parse as db_url
=>  reconheça o módulo dj_database_url. Existe este módulo no sistema? Caso positivo, faça o import de parse deste módulo e traga o objeto parse para o escopo do “settings.py”, mas chame-o de db_url  (não é bem um alias).

* Leitura: from decouple import config
=> reconheça o módulo decouple.py. Existe este módulo no sistema? Caso positivo, faça o import de config deste módulo e traga o objeto config para o escopo do “settings.py”, mas chame-o também de config.

** Teste - Executar o RunServer e verificar se está tudo em ordem

$ manage runserver

Validating models...
0 errors found
Django version 1.6, using settings 'palestrum.settings'
Development server is running at http://127.0.0.1:8000/
Quit the server with CONTROL-­‐C.
[01/Jan/2013 00:00:00] "GET / HTTP/1.1" 200 1644
[01/Jan/2013 00:00:00] "GET /static/css/style.css HTTP/1.1" 200 3859
[01/Jan/2013 00:00:00] "GET /static/img/logo.png HTTP/1.1" 200 12189






== Novo Teste  ==  DEBUG = False

* arquivo: bvad/.env
SECRET_KEY=SECRET-KEY-DO-SEU-SETTINGS_SEM_ASPAS
DEBUG=False



Executar o RunServer e verificar se está tudo em ordem  (DEBUG = False)

$ manage runserver

CommandError: You must set settings.ALLOWED_HOSTS if DEBUG is False


* É uma proteção de segurança do Django, que exige a configuração dos Hosts permitidos para executar a aplicação (uma lista de hostnames possíveis no settings.py), para quando o valor de DEBUG for False.


arquivo: palestrum/settings.py
ALLOWED_HOSTS = ['.localhost', '127.0.0.1', '.herokuapp.com']

* Importante: inserir um ponto no início do nome do host (Ex.: '.localhost'), aceita todos os subdomínios do domínio indicado



(DEBUG = False)
Navegador: Ao fazer um request no navegador, a página apresentada fica desconfigurada (sem CSS e imagens), pois quando DEBUG=True o Django serve os arquivos estáticos através dos “static finders”. Com DEBUG=False, o Django não usa os “static finders”, e passa a usar o que foi configurado em STATIC_ROOT (neste caso, o diretório /staticfiles/). 

Para fazer funcionar com o DEBUG=False na máquia local, é necessário executar o comando collectstatic.

O collectstatic vai elencar todos os arquivos estáticos de todas as apps e os reunirá no STATIC_ROOT (neste caso, o diretório /staticfiles/)..

* O parâmetro --noinput serve para inibir as perguntas de confirmação das ações.
$ manage collectstatic --noinput
Copying '/django/contrib/admin/static/admin/css/base.css'
Copying '/django/contrib/admin/static/admin/img/changelist-­‐bg.gif'
Copying '/django/contrib/admin/static/admin/js/actions.js'
...
Copying '/bvad/palestrum/core/static/css/style.css'
Copying '/bvad/palestrum/core/static/img/logo.png'

71 static files copied.

$ manage runserver
Validating models...

0 errors found
March 02, 2014 - 17:27:08
Django version 1.6, using settings 'palestrum.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
[02/Mar/2014 17:27:15] "GET / HTTP/1.1" 200 1642
[02/Mar/2014 17:27:16] "GET /static/img/logo.png HTTP/1.1" 200 5368
[02/Mar/2014 17:27:16] "GET /static/css/style.css HTTP/1.1" 200 3858
[02/Mar/2014 17:27:17] "GET /static/favicon.ico HTTP/1.1" 404 13


Navegador: Agora aparece tudo em ordem (com CSS e imagens). 


arquivo: bvad/requirements.txt
Django==1.6
Unipath==1.0
dj-database-url==0.2.2
dj-static==0.0.5
gunicorn==18.0
psycopg2==2.5.1
django-decouple==2.1


arquivo: bvad/.gitignore
bin
build
include
lib
local
man
share
Scripts
.Python
*.pyc
*~
*.sqlite3
.DS_Store
.env
palestrum/staticfiles




== Onde vejo a correção? ==

* Ver a correção - Implantar

$ git status
# On branch master
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working directory)
#
# modified: .gitignore
# modified: palestrum/settings.py
# modified: requirements.txt
#
no changes added to commit (use "git add" and/or "git commit --a")


$ git commit -am 'Debug false'
[master 225b2d7] Debug false
 3 files changed, N insertions(+), M deletions(-)


$ git status
# On branch master
nothing to commit (working directory clean)


### Antes era isso:
### $ heroku labs:enable user-env-compile

### mudou para  (ver: https://github.com/ddollar/foreman)
$ heroku plugins:install git://github.com/ddollar/heroku-config.git


# macete - é uma extensão do Heroku
$ heroku config:push
Config in .env written to APP


$ git push heroku master --force


Navegador: Ao acessar a página no Heroku, é possível verificar que foi implantado






==  Como ligar (ou desligar) o DEBUG remoto? ==

# Para ligar...

$ heroku config:set DEBUG=True
Setting config vars and restarting APP... done, v12
DEBUG: True


# Para desligar...

$ heroku config:set DEBUG=False
Setting config vars and restarting APP... done, v13
DEBUG: False
* É possível alterar o modo de DEBUG e/ou BD sem a necessidade de se fazer deploy.

* Finalizado os testes, não esquecer de alterar o DEBUG para True

* alterar o arquivo: bvad/.env

SECRET_KEY=SECRET-KEY-DO-SEU-SETTINGS_SEM_ASPAS
DEBUG=True




== TESTES AUTOMÁTICOS ==

“A grande coragem, para mim, é a prudência.” - Eurípedes

* O teste não existe para garantir o código, o teste faz parte do código.

* O erro inesperado elimina o crédito do programador. Coloca em cheque a competência, credibilidade, etc.

* TDD nos auxilia a ter certeza de que um passo dado pra frente é um passo firme.. Não é um “talvez”.

* Código tem valor zero. O que tem valor é uma pessoa que usa o computador que processa o programa que desenvolvemos.

* TI é Custo ⇒  Estamos desconectados do valor que geramos.

* Live Software ⇒  Tratar o código como um organismo vivo.

* Fazer código para o futuro é jogar dinheiro no lixo. Só aumenta o custo.

* Scrum é um paleativo para quando as pessoas da organização já desistiram de trabalhar juntas. É um framework de gestão.

* Como é que me aproximo do valor gerado? O usuário não é o inimigo, pelo contrário, é o motivo pelo qual a gente trabalha.

* Técnicas do desenvolvimento ágil: reduzem o custo de transação, que é o custo de interação, custo de troca. Ou seja, projetar algo, que gerará valor para uma pessoa, para que essa pessoa se beneficie e gere valor para você. Temos que encurtar isso, pois são quatro camadas de abstração. Encurtar para minutos!

* Quem não gera valor, não tem valor para a sociedade. É descartável!

* Migrar da visão de custo para visão de investimento (Ex.: o trabalho feito acrescentou valor para a empresa em 30 dias… ).

* O código vai se revelando através do TDD. No início é chato, pois é lento, e estamos acostumados a fazer tudo rápido, mas a médio prazo é muito mais barato, é muito mais rápido, apesar do ritmo ser lento.


== Criando o primeiro Test Case do projeto ==

* O Django já vem com infraestrutura de testes

* O primeiro teste é um teste de regressão para uma página já existente (a home do site)

arquivo: palestrum/core/tests.py
# coding: utf-8
from django.test import TestCase


class HomeTest(TestCase):

    def test_get(self):
        """
        GET / must return status code 200
        """
        response = self.client.get('/')
        self.assertEqual(200, response.status_code)
        self.assertTemplateUsed(response, 'index.html')



* django.test ⇒ Package de teste do Django.

* TestCase ⇒ Classe que representa um “cenário de teste”.

* Test Method ⇒ É o teste em si. Um cenário de teste pode ter vários testes. O método precisa ter um formato específico, sendo: o nome do método deve iniciar com “test_”

* client é um objeto capaz de navegar na infraestrutura do Django. Simula um browser.

* É possível usar outras suites de teste como pytest (melhor), nose, etc. 

* Não se constroem testes que dependam de outros testes.

* É possível criar os próprios “asserts”



== Executando os Testes ==

$ manage test
Creating test database for alias 'default'...
.
------------------------------------------------
Ran 1 test in 0.027s

OK
Destroying test database for alias 'default'...
* faz uma busca a partir do diretório raiz, procurando todos os módulos que começam com “test”, e dentro destes módulos, procura todas as classes que herdam de TestCase, e dentro delas, todos os métodos que começam com “test_”.


== Um assert por método de teste == (Dica)  

arquivo: palestrum/core/tests.py
# coding: utf-8
from django.test import TestCase

class HomeTest(TestCase):

    def setUp(self):
        self.resp = self.client.get('/')

    def test_get(self):
        """
        GET / must return status code 200
        """
        self.assertEqual(200, self.resp.status_code)

    def test_template(self):
        """
        Home must use template index.html
        """
        self.assertTemplateUsed(self.resp, 'index.html')

* setUp(self) ⇒ método especial do framework de teste do Python (mesmo padrão do JUnit). É executado antes de cada teste. No caso apresentado, serão feitos dois requests.
* setUpClass ⇒ um class method que é executado apenas uma vez por cenário. Para o caso apresentado, poderia ser usado para executar os testes um pouco mais rápido, pois o contexto é o mesmo e serviria para os dois testes executados.

== Executando os testes da app Core ==

* É possível escolher os testes que se quer executar.

$ manage test palestrum.core


== O que acontece quando executamos os testes? ==

A partir do diretório corrente, o TesteRunner:
procura e carrega o módulo/package test*.py
(Suite de Testes)
Identifica cada Cenário de Teste
(TestCase)
Identifica cada Teste nos Cenários de teste
(TestMethod)
Executa setUp, Teste e tearDown para cada teste
setUp - prepara o contexto do Cenário
tearDown (semelhante a destroy) - limpa os efeitos colaterais do Cenário



== Como executar os testes ==

$ manage test

$ manage test palestrum.core

$ manage test palestrum.core.tests.HomeTest

$ manage test palestrum.core.tests.HomeTest.test_get






== Unittest ==

Asserts do Unittest
* http://docs.python.org/2/library/unittest.html

assertEqual(a, b)
assertNotEqual(a, b)
assertTrue(x)
assertFalse(x)
assertIs(a, b)
assertIsNot(a, b)
assertIsNone(x)
assertIsNotNone(x)
assertIn(a, b)
assertNotIn(a, b)
assertIsInstance(a, b)
assertNotIsInstance(a, b)
assertRaises(exc, fun, *args, **kwds)
assertRaisesRegexp(exc, re, fun, *args, **kwds)
assertAlmostEqual(a, b)
assertNotAlmostEqual(a, b)
assertGreater(a, b)
assertGreaterEqual(a, b)
assertLess(a, b)
assertLessEqual(a, b)
assertRegexpMatches(s, re)
assertNotRegexpMatches(s, re)
assertItemsEqual(a, b)
assertDictContainsSubset(a, b)
assertMultiLineEqual(a, b)
assertSequenceEqual(a, b)
assertListEqual(a, b)
assertTupleEqual(a, b)
assertSetEqual(a, b)
assertDictEqual(a, b)



Asserts do Django

* https://docs.djangoproject.com/en/dev/topics/testing/
* https://docs.djangoproject.com/en/dev/topics/testing/tools/

assertContains 
assertFieldOutput 
assertFormError 
assertFormsetError 
assertHTMLEqual 
assertHTMLNotEqual
assertInHtml
assertJSONEqual
assertNotContains
assertNumQueries
assertQuerysetEqual
assertRaisesMessage
assertRedirects
assertTemplateNotUsed
assertTemplateUsed
assertXMLEqual
assertXMLNotEqual



== Preciso de um formulário para inscrições - Prática ==

* Deve ser criado um formulário simples com: Nome, CPF, Email e Telefone.

CENÁRIO
Dado que temos um visitante qualquer
Quando ele acessa o endereço /incricao/
Então ele vê a página de inscrição
   e a página possui um formulário
   e o formulário possui 4 campos
   e os campos são nome, email, cpf e telefone
   e o formulário possui um botão p/ inscrever.
* Descreve bem o cenário, a expectativa do código. Qual será a experiência do usuário, o que ele verá, e experimentará.


== Mão na massa ==

=> Com o virtualenv ativado, criar uma nova app

$ cd bvad/palestrum
$ manage startapp subscriprions

* DICA: Nome de app, sempre no plural.

=>  Estrutura de diretórios esperada
bvad
  manage.py
  palestrum/
    __init__.py
    settings.py
    urls.py
    wsgi.py
    core/ . . .
    subscriptions/
      __init__.py
      admin.py
      models.py
      tests.py
      views.py

=> Instalar a app

arquivo: palestrum/settings.py
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'palestrum.core',
    'palestrum.subscriptions',
)


=> Implementar a rota -  TEST FIRST

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase

class SubscribeTest(TestCase):

    def setUp(self):
        self.resp = self.client.get('/inscricao/')

    def test_get(self):
        """
        GET /inscricao/ must return status code 200
        """
        self.assertEqual(200, self.resp.status_code)



* Executar o teste
$ manage test palestrum.subscriptions
* O teste falha
FAIL: test_get (palestrum.subscriptions.tests.SubscribeTest)
GET /inscricao/ must return status code 200.
----------------------------------------------------------------------
AssertionError: 200 != 404

** Sempre ficar de olho na mensagem exposta pelo Traceback

=> Agora sim, com a falha do teste e sabendo o que deve ser feito: Implementar a rota

arquivo: palestrum/urls.py
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', 'palestrum.core.views.home', name = 'home'),
    url(r'^inscricao/$','palestrum.subscriprions.views.subscribe', name='subscribe'),
    url(r'^admin/', include(admin.site.urls)),
)

=>  TEST AGAIN

$ manage test palestrum.subscriptions

** Agora surgiu um ERRO
** FALHA é quando todo o código funcionou, mas a expectativa do teste não foi atendida.
** ERRO é quando ocorre uma quebra.
** Traceback informa que a view não existe ainda.
ERROR: test_get (palestrum.subscriptions.tests.SubscribeTest)
GET /inscricao/ must return status code 200.
-----------------------------------------------------------------------
ImportError: No module named subscriprions


arquivo: palestrum/subscriptions/views.py
# coding: utf-8

from django.http import HttpResponse

def subscribe(request):
    return HttpResponse()
* implementa a view da forma mais simples possível, apenas para o teste rodar

** TEST AGAIN

$ manage test palestrum.subscriptions
** Agora passou

Navegador: executando agora o runserver e testando no navegador (http://127.0.0.1:8000/inscricao/), não dá erro, mas não aparece nada, pois a view não faz nada.

!!! três estados possíveis para um teste: FALHA (FAIL), ERRO (ERROR) e SUCESSO (OK)

* A busca pela organização precoce vira uma distração para o processo de aprendizagem.


=> Implementar a view

** TEST FIRST

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase


class SubscribeTest(TestCase):

    def setUp(self):
        self.resp = self.client.get('/inscricao/')

    def test_get(self):
        """
        GET /inscricao/ must return status code 200
        """
        self.assertEqual(200, self.resp.status_code)

    def test_template(self):
        'Response should be a rendered template.'
        self.assertTemplateUsed(self.resp,
                            'subscriptions/subscription_form.html')

* executar o teste
$ manage test palestrum.subscriptions
** O teste falha
FAIL: test_template (palestrum.subscriptions.tests.SubscribeTest)
Response should be a rendered template.
----------------------------------------------------------------------
AssertionError: No templates used to render the response



=> Agora sim, com a falha do teste e sabendo o que deve ser feito: Implementar o template (o código tá pedindo)

=> Criando o template

# Estando no diretório bvad:
# Crie o diretório templates/subscriptions na app subscriptions
$ mkdir -p palestrum/subscriptions/templates/subscriptions

# Crie o template subscriptios/subscription_form.html
$ cd palestrum/subscriptions/templates/subscriptions
$ echo "Form aqui..." > subscription_form.html

# macete - volta para o diretório anterior
$ cd -


=> modificar a view

arquivo: palestrum/subscriptions/views.py
# coding: utf-8

from django.shortcuts import render

def subscribe(request):
    return render(request, 'subscriptions/subscription_form.html')

** TEST AGAIN

$ manage test palestrum.subscriptions
** Agora passou (Sucesso)

Navegador: executando agora o runserver e testando no navegador (http://127.0.0.1:8000/inscricao/), não dá erro, e mostra o texto “Form aqui …” (template está sendo usado)



=> Implementar um html funcional - TEST FIRST

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase

class SubscribeTest(TestCase):

    . . . 

    def test_html(self):
        'Html must contain input controls.'
        self.assertContains(self.resp, '<form')
        self.assertContains(self.resp, '<input', 5)
        self.assertContains(self.resp, 'type="text"', 3)
        self.assertContains(self.resp, 'type="email"')
        self.assertContains(self.resp, 'type="submit"')

* test_html ⇒ é um teste trivial de aceitação, não é para garantir o código, mas sim expressar em código a expectativa de código a ser seguida (o que deverá ser feito)

* foge da recomendação e usa vários asserts em apenas um teste. Testa se o conteúdo da resposta possui os elementos. Não é o melhor teste do mundo. Pra fazer um teste pra valer, recomenda-se o uso do pyquery (https://pypi.python.org/pypi/pyquery) [não é semelhante ao Selenium]



* executar o teste
$ manage test palestrum.subscriptions
** O teste falha 
FAIL: test_html (palestrum.subscriptions.tests.SubscribeTest)
Html must contain input controls.
----------------------------------------------------------------------
AssertionError: Couldn't find '<form' in response




=> Com a falha do teste e sabendo o que deve ser feito: Implementar o formulário html (o código tá pedindo)

=> Criando o template


arquivo: palestrum/subscriptions/templates/subscriptions/subscription_form.html
<h1>Formulário de inscrição</h1>
<form action="." method="POST">
    <p>
        <label for="id_name">Nome:</label>
        <input id="id_name" type="text" name="name" maxlength="100" />
    </p>
    <p>
        <label for="id_cpf">CPF:</label>
        <input id="id_cpf" type="text" name="cpf" maxlength="11" />
    </p>
    <p>
        <label for="id_email">Email:</label>
        <input id="id_email" type="email" name="email" maxlength="75" />
    </p>
    <p>
        <label for="id_phone">Telefone:</label>
        <input id="id_phone" type="text" name="phone" maxlength="20" />
    </p>
    <input type="submit" value="Enviar!" class="button" />     
</form>



** TEST AGAIN
$ manage test palestrum.subscriptions
** Agora passou


Navegador: executando agora o runserver e testando no navegador, não dá erro, e mostra o formulário. Ao ser clicado, o botão enviar não funciona e apresenta erro como resposta (dá um erro CSRF - Cross Site Request Forgery; mecanismo de proteção do Django).



arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase

class SubscribeTest(TestCase):
    . . . 
    def test_csrf(self):
        'Html must contain csrf token.'
        self.assertContains(self.resp, 'csrfmiddlewaretoken')
* Para adequar o formulário, é necessário então escrever um teste de regressão, que garanta a existência do token CSRF (ver documentação)

* executar o teste
$ manage test palestrum.subscriptions
** O teste falha 
FAIL: test_csrf (palestrum.subscriptions.tests.SubscribeTest)
Html must contain csrf token.
----------------------------------------------------------------------
AssertionError: Couldn't find 'csrfmiddlewaretoken' in response


=> Com a falha do teste e sabendo o que deve ser feito: Implementar o formulário html (o código tá pedindo)

arquivo: palestrum/subscriptions/templates/subscriptions/subscription_form.html
<h1>Formulário de inscrição</h1>
<form action="." method="POST">
    {% csrf_token %}
    <p>
        <label for="id_name">Nome:</label>
        <input id="id_name" type="text" name="name" maxlength="100" />
    </p>
    . . .


* a template tag especial csrf_token fará a geração do input text correto


* executar o teste
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_html (palestrum.subscriptions.tests.SubscribeTest)
Html must contain input controls.
----------------------------------------------------------------------
AssertionError: Found 6 instances of '<input' in response (expected 5)



=> corrigir o teste

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase


class SubscribeTest(TestCase):

    . . . 

    def test_html(self):
        'Html must contain input controls.'
        self.assertContains(self.resp, '<form')
        self.assertContains(self.resp, '<input', 6)
        self.assertContains(self.resp, 'type="text"', 3)
        self.assertContains(self.resp, 'type="email"')
        self.assertContains(self.resp, 'type="submit"')

    . . .


=> TEST AGAIN

$ manage test palestrum.subscriptions
* Agora passou (sucesso)






=> Implementar o form (integração com o Django) - TEST FIRST

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase

class SubscribeTest(TestCase):
    . . . 

    def test_has_form(self):
        'Context must have the subscription form.'
        form = self.resp.context['form']
        self.assertIsInstance(form, SubscriptionForm)

* executar o teste
$ manage test palestrum.subscriptions
* O teste falha 
ERROR: test_has_form (palestrum.subscriptions.tests.SubscribeTest)
Context must have the subscription form.
----------------------------------------------------------------------
KeyError: 'form'
** Não tem o form no contexto.


=>  modificar a view

arquivo: palestrum/subscriptions/views.py
# coding: utf-8

from django.shortcuts import render

def subscribe(request):
    return render(request, 'subscriptions/subscription_form.html', 
                  {'form': None})
* adicionar o terceiro parâmetro

** executar o teste

$ manage test palestrum.subscriptions
* O teste falha (ERROR: … NameError: global name ‘SubscriptionForm’ is not defined)
** Não fez o import

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.forms import SubscriptionForm

class SubscribeTest(TestCase):

    . . . 


* executar o teste
$ manage test palestrum.subscriptions
** O teste falha 
ERROR: palestrum.subscriptions.tests (unittest.loader.ModuleImportFailure)
----------------------------------------------------------------------
ImportError: No module named forms

** criar o forms.py


=> Crie o módulo forms.py

# Estando no diretório bvad
# Crie o arquivo forms.py dentro da app subscriptions
$ touch palestrum/subscriptions/forms.py


* executar o teste
$ manage test palestrum.subscriptions
** O teste falha
ERROR: palestrum.subscriptions.tests (unittest.loader.ModuleImportFailure)
----------------------------------------------------------------------
ImportError: cannot import name SubscriptionForm



arquivo: palestrum/subscriptions/forms.py
# coding: utf-8

class SubscriptionForm(object):
    pass



** executar o teste
$ manage test palestrum.subscriptions
** O teste falha (FAIL: … AssertionError: None is not an instance of … SubscriptionForm)


=> modificar a view

arquivo: palestrum/subscriptions/views.py
# coding: utf-8

from django.shortcuts import render
from palestrum.subscriptions.forms import SubscriptionForm

def subscribe(request):
    return render(request, 'subscriptions/subscription_form.html', 
                  {'form': SubscriptionForm()})

* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)

=>  Espera-se que o formulário tenha 4 campos. Um teste para expressar isso:

arquivo: palestrum/subscriptions/tests.py
# coding: utf-8
from django.test import TestCase

class SubscribeTest(TestCase):
    . . . 

    def test_form_has_fields(self):
        'Form must have 4 fields.'
        form = self.resp.context['form']
        self.assertItemsEqual(['name','email','cpf','phone'], form.fields)


* executar o teste
$ manage test palestrum.subscriptions
* O teste falha 
ERROR: test_form_has_fields (palestrum.subscriptions.tests.SubscribeTest)
Form must have 4 fields.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/azanata/bvad/palestrum/subscriptions/tests.py", line 38, in test_form_has_fields
    self.assertItemsEqual(['name','email','cpf','phone'], form.fields)
AttributeError: 'SubscriptionForm' object has no attribute 'fields'


arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms

class SubscriptionForm(forms.Form):
    name = forms.CharField()
    cpf = forms.CharField()
    email = forms.EmailField()
    phone = forms.CharField()



* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)



==  Como usar o SubscriptionForm no template? ==

refatorar arquivo:  palestrum/subscriptions/templates/subscriptions/subscription_form.html
. . .
. . .
<p>
    <label for="{{form.name.id_for_label }}">{{ form.name.label }}:</label>
    {{ form.name }}
    {{ form.name.errors }}
</p>
<p>
    <label for="{{form.cpf.id_for_label }}">{{ form.cpf.label }}:</label>
    {{ form.cpf }}
    {{ form.cpf.errors }}
</p>
<p>
    <label for="{{form.email.id_for_label }}">{{ form.email.label }}:</label>
    {{ form.email }}
    {{ form.email.errors }}
</p>
<p>
    <label for="{{form.phone.id_for_label }}">{{ form.phone.label }}:</label>
    {{ form.phone }}
    {{ form.phone.errors }}
</p>
. . .



* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)


Navegador: executando agora o runserver e testando no navegador, não dá erro, mas os “labels” dos campos estão escritos em inglês. Queremos os textos em português. (http://127.0.0.1:8000/inscricao/)

arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms
from django.utils.translation import ugettext as _

class SubscriptionForm(forms.Form):
    name = forms.CharField(label=_('Nome'))
    cpf = forms.CharField(label=_('CPF'))
    email = forms.EmailField(label=_('Email'))
    phone = forms.CharField(label=_('Telefone'))


* ugettext ⇒  ferramenta do Django que usa a biblioteca gettext, disponível na maioria dos sw livres. Forma padrão de internacionalizar uma aplicação.

* A qualquer momento do projeto, é possível executar o comando do Django chamado makemessages (https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-makemessages), que processa todo o código fonte, procurando os textos marcados com “_()” e processar os blocos de tradução nos templates, e gera um dicionário com os textos. 

* (Recomenda uso: https://www.transifex.com/)

* ver: http://henriquebastos.net/cuidados-importantes-ao-configurar-i18n-no-django/

* E se quiser adicionar uma class CSS em um input do formulário?
Se a classe for de estilo, recomenda que não seja feito. Recomenda usar a cascata: envolver o input na DIV e a DIV vai cascatear para o INPUT.
Se não tiver jeito e for necessário inserir: implementar um widget que terá esses parâmetros (será visto ainda).


Navegador:  executando agora o runserver e testando no navegador, os textos dos labels são apresentados de forma correta (http://127.0.0.1:8000/inscricao/).




== Dá pra ficar bonito como a Landingpage? ==


=>  Estender os Templates

# Estando no diretório bvad
# Criar o template base.html como uma cópia de index.html
$ cp palestrum/core/templates/{index,base}.html


arquivo: palestrum/core/templates/base.html
<!doctype html>
<html>
<head>
  . . .
</head>
<body>
  <div id="page”>
    <div id="header">
      . . .
    </div>
    <hr />
    <div id="content">
      {% block content %}
      {% endblock content %}
    </div>
    . . .
  </div>
</body>
</html>




alterar o arquivo: palestrum/core/templates/index.html
1 - para estender o base.html
2 - para incluir um link para inscrição
{% extends 'base.html' %}
{% block content %}
  <h1>Bem-vindo ao palestrum!</h1>
  <p>O evento mais sensacional do ano depois do Dev in Rio!</p>
  <p>Você não pode perder esta oportunidade!</p>
  <p><strong><a href="/inscricao/">Inscreva-se já!</a></strong></p>
  <p>
    Para dúvidas e mais informações entre em contato com
    <a href="mailto:palestrum@palestrum.com.br">
      palestrum@palestrum.com.br
    </a>.
  </p>
{% endblock content %}



Navegador:  executando agora o runserver e testando no navegador, a página inicial continua funcionando normalmente e agora apresenta link para o formulário de inscrição (http://127.0.0.1:8000/).


arquivo: palestrum/subscriptions/templates/subscriptions/subscription_form.html
{% extends 'base.html' %}
{% block content %}
  <form action="." method="POST">
    . . .
  </form>
{% endblock content %}

Navegador:  executando agora o runserver e testando no navegador, tudo funciona normalmente. Ao clicar no link de inscrição, o formulário é apresentado já com o estilo visual do template (http://127.0.0.1:8000/).


* não esquecer de executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)



“Quality is everione’s responsibility.” 
W. Edwards Deming 

Baby Steps ⇒ Só programe algo que atenderá uma expectativa existente no código.
O teste é uma expectativa para criar o código.

“Refatorar é organizar o código como se o próximo programador fosse um psicopata que sabe onde você mora.”

Refatorar ⇒ deixar a coisa resolvida, organizada.


== O que temos no tests.py? ==

. . .
class SubscribeTest(TestCase):
    . . .
    def test_get(self):
    . . .
    def test_template(self):
    . . .
    def test_html(self):
    . . .
    def test_csrf(self):
    . . .
    def test_has_form(self):
    . . .
    def test_form_has_fields(self):
    . . .


* Cenário muito grande (mal cheiro). Precisa ser tão grande?
* Teste do SubscriptionForm (test_form_has_fields). No teste funcional, misturou um teste unitário



== Transforme o tests.py em um package ==

# Estando no diretório bvad
# Crie o diretório tests na app subscriptions
$ mkdir palestrum/subscriptions/tests

# Crie o arquivo __init__.py no diretório tests na app subscriptions
$ touch palestrum/subscriptions/tests/__init__.py

# Mova o tests.py para dentro do package com um nome melhor:
$ mv palestrum/subscriptions/{tests.py,tests/test_views_subscribe.py}


** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** passou (Sucesso)


# Estando no diretório bvad
# um módulo test_forms.py no package tests na app subscriptions
$ touch palestrum/subscriptions/tests/test_forms.py

# Mova o teste SubscribeTest.test_form_has_fields para o test_forms.py…

arquivo: palestrum/subscriptions/tests/test_forms.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.forms import SubscriptionForm

class SubscriptionFormTest(TestCase):

    def test_form_has_fields(self):
        'Form must have 4 fields.'
        form = self.resp.context['form']
        self.assertItemsEqual(['name','email','cpf','phone'], form.fields)
* test_form_has_fields ⇒ teste unitário

** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** passou (Sucesso)

== Como grava uma inscrição? ==

“Everithing is an Object” - Dive Into Python

****** slide (125)

* vários exemplos e exercícios nos slides

class
# class é um comando executável no Python
# e não apenas a declaração de uma estrutura de dados.

>>> class Car(object):
...     print 'Loading a class...'
...     name = 'Ferrari'
...     print 'Done defining a ' + name + '!' * 5

Loading a class...
Done defining a Ferrari!!!!!

>>> Car()
<__main__.Car at 0x101e5a410>



Métodos e Self
>>> class Car(object):
...     name = 'Ferrari'
... 
...     # método é uma função definida no corpo da class
...     def ignition(self):
...         print 'vrummmmmm...'
...         self.motor_running = True

>>> c = Car()
>>> c.ignition() # açúcar sintático
vrummmmmm...

>>> d = Car()
>>> Car.ignition(d)
vrummmmmm...



Construtor
>>> class Car(object):
...     portas = 2 # atributo da classe
...
...     def __init__(self, name):
...         self.name = name # atributo da instância

>>> c = Car('Ferrari')
>>> c.portas # instância acessa atributo da classe
2

>>> c.__class__.__dict__['portas']
2

>>> c.name # instância acessa atributo da instância
Ferrari

>>> c.__dict__['name']
Ferrari

Herança
>>> class Car(object):
...     portas = 2
...
...     def __init__(self, name):
...         self.name = name

>>> class Ferrari(Car):
...     def __init__(self, model):
...         # executa o construtor da classe base de Ferrari
...         super(Ferrari, self).__init__('Ferrari')
...         self.model = model

>>> f = Ferrari('F50')
>>> f.name # atributo da instância
Ferrari

>>> f.model # atributo da instância
F50

>>> f.portas # atributo da classe Car
2



Herança e o Super
class A(object):
    def __init__(self):
        print 'A'
        super(A, self).__init__()

>>> A()
A

class B(A):
    def __init__(self):
        print 'B'
        super(B, self).__init__()

class C(A):
    def __init__(self):
        print 'C'
        super(C, self).__init__()

>>> B()
B, A

>>> C()
C, A

class D(B, C):
    def __init__(self):
        print 'D'
        super(D, self).__init__()

>>> D()
D, B, C, A





== MODELS ==

* Representam as entidades do projeto

“SQL means Sacry Quirky Language” 
Jacob Kaplan-Moss

* Aprenda SQL para saber como ser bom em quando não usar o SQL.

* Como seria o modelo de subscriprions
CREATE TABLE "subscriptions_subscription" (
    "id" integer NOT NULL PRIMARY KEY,
    "name" varchar(100) NOT NULL,
    "cpf" varchar(11) NOT NULL UNIQUE,
    "email" varchar(75) NOT NULL UNIQUE,
    "phone" varchar(20) NOT NULL,
    "created_at" datetime NOT NULL
)




== Criar o modelo? - TEST FIRST == 

== O que é uma “inscrição”? ==

Nome completo
CPF
Email
Telefone
Data em que a inscrição foi realizada
(*) CPF e Email não podem se repetir




arquivo: palestrum/subscriptions/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription

class SubscriptionTest(TestCase):

    def setUp(self):
        self.obj = Subscription(
            name='Antonio Santos',
            cpf='12341234123',
            email='antoniosantos@antoniosantos.net',
            phone='11-989002122'
        )

    def test_create(self):
        'Subscription must Context must have name, cpf, email, phone.'
        form = self.obj.save()
        self.assertEqual(1, self.obj.pk)



* executar os testes
$ manage test palestrum.subscriptions
* O teste falha
ERROR: palestrum.subscriptions.tests.test_models (unittest.loader.ModuleImportFailure)
----------------------------------------------------------------------
ImportError: cannot import name Subscription


arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models

class Subscription(models.Model):
    pass

* executar os testes
$ manage test palestrum.subscriptions
* O teste falha
ERROR: test_create (palestrum.subscriptions.tests.test_models.SubscriptionTest)
Subscription must Context must have name, cpf, email, phone.
----------------------------------------------------------------------
TypeError: 'phone' is an invalid keyword argument for this function

=> Adicionar os campos no modelo

arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models

class Subscription(models.Model):
    name = models.CharField(max_length=100)
    cpf = models.CharField(max_length=11)
    email = models.EmailField()
    phone = models.CharField(max_length=20, blank=True)
* null=True ⇒ dado pode ser inexistente
* blank=True ⇒ dado pode ser vazio (Ex.: String vazia, lista vazia) - pode ser preenchido depois / não é tão restritivo

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* passou (Sucesso)
* temos um modelo inicial, mas faltou uma expectativa do planejamento inicial: Data de criação

arquivo: palestrum/subscriptions/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from datetime import datetime
from palestrum.subscriptions.models import Subscription

class SubscriptionTest(TestCase):
    . . .
    def test_create(self):
       . . .

    def test_has_created_at(self):
        'Subscription must have automatic created_at.'
        form = self.obj.save()
        self.assertIsInstance(self.obj.created_at, datetime)

* executar os testes
$ manage test palestrum.subscriptions
* O teste falha
ERROR: test_has_created_at (palestrum.subscriptions.tests.test_models.SubscriptionTest)
Subscription must have automatic created_at.
----------------------------------------------------------------------
AttributeError: 'Subscription' object has no attribute 'created_at'
arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models

class Subscription(models.Model):
    name = models.CharField(max_length=100)
    cpf = models.CharField(max_length=11)
    email = models.EmailField()
    phone = models.CharField(max_length=20, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
* auto_now_add ⇒ preenche o valor da coluna quando estiver inserindo a linha na tabela. 
* A data usada é a data do Banco de Dados ou de onde? (ver o código do driver)
* DateTime no Django é UTC.
* procurar artigo que menciona os perigos de se usar timezone e recomenda o uso de UTC
* BD de teste é separado do BD desenvolvimento

** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** passou (Sucesso)






=> expectativa: testar a unicidade do CPF e do e-mail

arquivo: palestrum/subscriptions/tests/test_models.py
* um cenário pra cada contexto (não por view, template, etc). Se o setUp mudar, criar um novo cenário.
# coding: utf-8
from django.test import TestCase
from django.db import IntegrityError
from datetime import datetime
from palestrum.subscriptions.models import Subscription

class SubscriptionTest(TestCase):
    . . .

class SubscriptionUniqueTest(TestCase):

    def setUp(self):
       # Create a first entry to force the collision
       Subscription.objects.create(name='Antonio Santos',
                                   cpf='12341234123',
                                   email='antoniosantos@antoniosantos.net',
                                   phone='11-989002122')       

    def test_cpf_unique(self):
        'CPF must be unique'
        s = Subscription (name='Antonio Santos',
                          cpf='12341234123',
                          email='antoniosantos@antoniosantos.net',
                          phone='11-989002122')
        # nao esta chamando o metodo s.save
        # esta passando o metodo (objeto) como parametro
        # por isso faltam os parenteses
        self.assertRaises(IntegrityError, s.save)



* executar os testes
$ manage test palestrum.subscriptions
** O teste falha
FAIL: test_cpf_unique (palestrum.subscriptions.tests.test_models.SubscriptionUniqueTest)
CPF must be unique
AssertionError: IntegrityError not raised



=> ainda não foi criada a constraint de unicidade

alterar o arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models

class Subscription(models.Model):
    name = models.CharField(max_length=100)
    cpf = models.CharField(max_length=11, unique=True)
    email = models.EmailField()
    phone = models.CharField(max_length=20, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* passou (Sucesso)



alterar o arquivo: palestrum/subscriptions/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from django.db import IntegrityError
from datetime import datetime
from palestrum.subscriptions.models import Subscription

class SubscriptionTest(TestCase):
    . . .

class SubscriptionUniqueTest(TestCase):
    . . .
    def test_cpf_unique(self):
        . . .
        
    def test_email_unique(self):
        'Email must be unique'
        s = Subscription (name='Antonio Santos', cpf='00100100122',
                          email='antoniosantos@antoniosantos.net', phone='11-989002122')
        self.assertRaises(IntegrityError, s.save)



* executar os testes
$ manage test palestrum.subscriptions
** O teste falha
FAIL: test_email_unique (palestrum.subscriptions.tests.test_models.SubscriptionUniqueTest)
Email must be unique
----------------------------------------------------------------------
AssertionError: IntegrityError not raised


=> ainda não foi criada a constraint de unicidade
alterar o arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models

class Subscription(models.Model):
    name = models.CharField(max_length=100)
    cpf = models.CharField(max_length=11, unique=True)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=20, blank=True)
    created_at = models.DateTimeField(auto_now_add==True)



** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** passou (Sucesso)



alterar o arquivo: palestrum/subscriptions/tests/test_models.py
* mais um teste da representação do objeto, da conversão do objeto para string.
# coding: utf-8
from django.test import TestCase
from django.db import IntegrityError
from datetime import datetime
from palestrum.subscriptions.models import Subscription

class SubscriptionTest(TestCase):
    . . .
    def test_has_created_at(self):
        . . .
     
    def test_unicode(self):
        self.assertEqual(u'Antonio Santos', unicode(self.obj))

class SubscriptionUniqueTest(TestCase): . . .

** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** O teste falha 
FAIL: test_unicode (palestrum.subscriptions.tests.test_models.SubscriptionTest)
----------------------------------------------------------------------
AssertionError: u'Antonio Santos' != u'Subscription object'

=> ainda não foi definido o método __unicode__ (lembra o toString() do Java)

alterar o arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models

class Subscription(models.Model):
    name = models.CharField(max_length=100)
    cpf = models.CharField(max_length=11, unique=True)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=20, blank=True)
    created_at = models.DateTimeField(auto_now_add==True)

    def __unicode__(self):
        return self.name

** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** passou (Sucesso)
== Internacionalização no modelo ==

* Para agregar internacionalização ao modelo não dá para usar o ugettext convencional, é necessário usar o ugettext_lazy 
* O ugettext usa a infraestrutura de tradução que é inicializada depois que os modelos são inicializados
* O ugettext_lazy permite que os modelos sejam resolvidos e em seguida faz uma avaliação tardia (lazy evaluation) desses modelos, e a partir daí ativa a tradução certa. 
* O idioma padrão do Django é o inglês. Se usar o ugettext no models.py, todos os modelos usarão o idioma inglês. Fica estranho se a configuração da aplicação estiver configurada para pt-BR e o restante começar a ser apresentado em inglês.

* (Regra): usar sempre o ugettext_lazy no models.py

arquivo: palestrum/subscriptions/models.py
* em _(‘’), usar sempre o “verbose name”
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _

class Subscription(models.Model):
    name = models.CharField(_('nome'), max_length=100)
    cpf = models.CharField(_('CPF'), max_length=11, unique=True)
    email = models.EmailField(_('email'), unique=True)
    phone = models.CharField(_('telefone'), max_length=20, blank=True)
    created_at = models.DateTimeField(_('criado em'), auto_now_add==True)

    def __unicode__(self):
        return self.name

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* passou (Sucesso)



arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _

class Subscription(models.Model):
    name = models.CharField(_('nome'), max_length=100)
    cpf = models.CharField(_('CPF'), max_length=11, unique=True)
    email = models.EmailField(_('email'), unique=True)
    phone = models.CharField(_('telefone'), max_length=20, blank=True)
    created_at = models.DateTimeField(_('criado em'), auto_now_add==True)

    class Meta:
        ordering = ['created_at']
        verbose_name = _(u'inscrição')
        verbose_name_plural = _(u'inscrições')

    def __unicode__(self):
        return self.name
* Meta é uma “inner class” especial. Funciona como um dicionário do modelo. Neste caso, indica a ordenação padrão, o nome do modelo no singular e plural.
* Há várias outras opções: https://docs.djangoproject.com/en/dev/ref/models/options/

** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** passou (Sucesso)


== Criar as tabelas no BD ==

$ manage syncdb
Creating tables ...
Creating table subscriptions_subscription
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)




== Models e o manage.py  ==

Quando o manage.py é executado, o Django dispara um processo de boot que inclui um processo de “validação do modelo”, que percorre todas as apps, verifica o modelo de cada app e valida a referência de um para o outro, para evitar que haja coisas erradas na árvore de modelo do Django.

Se quiser validar os modelos manualmente, basta executar o comando a seguir, que é o comando que o Django executa (antes do runserver, do dump, do syncdb, etc):

$ manage validate
0 errors found

Também dá pra ver o SQL (para o BD alvo) gerado a partir do modelo criado, executando o seguinte comando:

$ manage sqlall subscriptions
BEGIN;
CREATE TABLE "subscriptions_subscription" (
    "id" integer NOT NULL PRIMARY KEY,
    "name" varchar(100) NOT NULL,
    "cpf" varchar(11) NOT NULL UNIQUE,
    "email" varchar(75) NOT NULL UNIQUE,
    "phone" varchar(20) NOT NULL,
    "created_at" datetime NOT NULL
)
;

COMMIT;

Verifica qual é o BD que está sendo usado, qual é o cliente do BD e já inicia o cliente do BD para manipulação dos comandos.

$ manage dbshell
SQLite version 3.7.15.2 2013-01-09 11:53:05
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite>




Destrói todos os dados (não a estrutura). Reinicia o BD.

$ manage flush
You have requested a flush of the database.
This will IRREVERSIBLY DESTROY all data currently in the '/home/azanata/bvad/palestrum/db.sqlite3' database,
and return each table to the state it was in after syncdb.
Are you sure you want to do this?

    Type 'yes' to continue, or 'no' to cancel: yes

You just installed Django's auth system, which means you don't have any superusers defined.
Would you like to create one now? (yes/no): yes
Username (leave blank to use 'azanata'): admin
Email address: admin@admin.com
Password: 
Password (again): 
Superuser created successfully.
Installed 0 object(s) from 0 fixture(s)



== Insert e Update ==

* abre o shell e permite executar comandos
$ manage shell

>>> from palestrum.subscriptions.models import Subscription
>>> s = Subscription (name='Antonio Santos',
>>>     cpf='12312312344',
>>>     email='antoniosantos@antoniosantos.net',
>>>     phone='11-989002122')
>>> s.save()

>>> s.id
... 1
>>> # id é o atributo que representa a coluna propriamente dito
>>> # o Django trabalha com id surrogado (sempre usa um id sequencial
>>> # a menos que seja especificado uma pk)


>>> s.pk #property que neste caso retorna s.id
... 1
>>> # mais recomendado
>>> # retorna o valor de qualquer campo, desde que este campo seja a pk

>>> s.phone="232-6776"
>>> s.save()  # update, pos s já tem id
>>> # o que define se é um insert ou update é a 
>>> # existência de valor do id (se a pk foi definida)


== Seleção e Filtro ==

>>> # cria uma instancia de QuerySet
>>> qs = Subscription.objects.all()
>>> # ainda não foi ao BD, apenas gerou o objeto (Lazy Evaluation)
>>> # o Django só vai ao BD no último momento

>>> # realiza a query no bd apenas quando necessário
>>> print qs
[<Subscription: Antonio Santos>]
>>> # aqui sim teve que acessar o BD

>>> qs[0].email # retorna o email do 1o elemento
u'antoniosantos@antoniosantos.net'


== Managers e Querysets ==

>>> type(Subscription)
. . . <class 'django.db.models.base.ModelBase'>

>>> type(Subscription.objects)
. . . <class 'django.db.models.manager.Manager'>

>>> type(Subscription.objects.all())
. . . <class 'django.db.models.query.QuerySet'>

* QuerySet ⇒ representa o estado do modelo (compilado como uma query)
* A classe do modelo (ModelBase), descreve a tabela (campos / colunas, tipos, schema)
* A instância do modelo, é um registro na tabela
* O model manager (Manager) é quem interage com múltiplas linhas da tabela
* O QuerySet é quem define uma query para a tabela (é a forma de obter informações do BD)


== Filtros ==

>>> qs = Subscription.objects.filter(name__startswith="A")
>>> qs[0].phone
u'232-6772'
* name__startswith → “startswith” é um Filter Lookup (ver adiante)


== Selecionando um único objeto ==

* O método get não retorna um QuerySet, apenas um objeto
>>> s =Subscription.objects.get(name__contains="San")
>>> s.phone
u'232-6772'



== Field Lookup ==

https://docs.djangoproject.com/en/1.6/topics/db/queries/#field-lookups

exact 
iexact 
contains 
icontains 
in 
gt 
gte
lt
lte
startswith
istartswith
endswith
iendswith
. . .


== Ordenação ==

# Ascendente
Subscription.objects.order_by("name")

# Descendente
Subscription.objects.order_by("-name")


== Encadeamento ==

>>> qs = Subscription.objects.all()
>>> qs.filter(name__contains="San")
>>> qs.order_by("name")

Subscription.objects.filter(name__contains="San").order_by("name")
**  Pesquisar: Django Query Toolbar



== Slicing limita a sua query ==

Subscription.objects.all()[0]

Subscription.objects.all()[0:2]

Subscription.objects.all()[-1]  # NOT  (Não tem circular)


== Update e Delete múltiplo ==

Subscription.objects.all().update(name="Outro Nome")

Subscription.objects.all().delete()


== Update e F() ==

>>> from django.db.models import F

>>> p = Produto.objects.get(id=1)
>>> p.qtde_estoque = F('qtde_estoque') - 1 
>>> p.save()
* Exemplo dado (Pedido feito simultaneamente / concorrência)

== Meta ==

* https://docs.djangoproject.com/en/1.6/ref/models/options/

abstract 
app_label 
db_table 
db_tablespace 
ordering
proxy
unique_together
verbose_name
verbose_name_plural
. . .







== Prática: Como envia os dados do formulário?

CENÁRIO - Dados Válidos (cenário de sucesso primeiro)
Dado que um visitante visita /incricao/
Quando ele preenche o formulário
   e seu nome, cpf, email e telefone estão corretos
   e ele clica em enviar
Então o sistema salva a sua inscrição
   e redireciona para a página de sucesso

* Descreve bem o cenário, a expectativa do código. Qual será a experiência do usuário, o que ele verá, experimentará pensando apenas no cenário de sucesso).
* Mas o código é feito considerando sempre o SUCESSO? O código só é feito por expectativas expressas em testes. No início o sistema é feito considerando que será usado por usuários gênios que nunca erram. Primeiro é feito a parte do sucesso, depois é que vem o cuidado com as exceções (é o desejo do sistema).

== Mão na massa - TEST FIRST ==

arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.forms import SubscriptionForm

class SubscribeTest(TestCase):
    . . . 

class SubscribePostTest(TestCase):
    def setUp(self):
        data = dict( name='Antonio Santos',
            cpf='12341234123', email='antoniosantos@antoniosantos.net',
            phone='11-989002122')
        self.resp = self.client.post('/inscricao/', data)
        
    def test_post(self):
        'Valid POST should redirect to /inscricao/1/'
        self.assertEqual(302, self.resp.status_code)



* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_post (palestrum.subscriptions.tests.test_views_subscripe.SubscribePostTest)
Valid POST should redirect to /inscricao/1/
----------------------------------------------------------------------
AssertionError: 302 != 200



=>  modificar a view

# arquivo: palestrum/subscriptions/views.py
# coding: utf-8
from django.http import HttpResponseRedirect
from django.shortcuts import render
from palestrum.subscriptions.forms import SubscriptionForm

def subscribe(request):
    if request.method == 'POST':
        return HttpResponseRedirect('/inscricao/%d/' % 1)
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})





* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)




=> Teste do Save

arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.forms import SubscriptionForm
from palestrum.subscriptions.models import Subscription

class SubscribeTest(TestCase):
    . . . 

class SubscribePostTest(TestCase):
    . . . 
    def test_post(self):
        . . . 
        
    def test_save(self):
        'Valid POST must be saved'
        self.assertTrue(Subscription.objects.exists())
* para garantir que no final do processo (após a postagem e retorno da resposta), espera-se que haja uma inscrição gravada no bd


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_save (palestrum.subscriptions.tests.test_views_subscripe.SubscribePostTest)
Valid POST must be saved
----------------------------------------------------------------------
AssertionError: False is not true








=>  modificar a view

arquivo: palestrum/subscriptions/views.py
# coding: utf-8
from django.http import HttpResponseRedirect
from django.shortcuts import render
from palestrum.subscriptions.forms import SubscriptionForm
from palestrum.subscriptions.models import Subscription

def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        form.full_clean()
        obj = Subscription(**form.cleaned_data)
        obj.save() 
        return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})

* Tudo o que vem do POST é texto. Quando este texto é passado para o form, como primeiro parâmetro na instância do form, vira um “bounded form” [form associado a dados] (https://docs.djangoproject.com/en/dev/topics/forms/) 

* o full_clean() pega os dados strings provenientes do formulário e os converte para os tipos Python, e insere estes dados no “form.cleaned_data”, que é um dicionário ( processa os dados provenientes da postagem, e os deixa no formato correto para gravação no bd)

* O “**” é uma operação de “unpacking”. 




* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)





CENÁRIO: Dados Inválidos 

Dado que um visitante visita /incricao/
Quando ele preenche o formulário
   e seu nome, cpf, email e telefone estão incorretos
   e ele clica em enviar
Então o sistema não salva a sua inscrição
   e exibe a própria página do formulário
   e indica os campos com erro.


arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.forms import SubscriptionForm
from palestrum.subscriptions.models import Subscription
. . . 

class SubscribeInvalidPostTest(TestCase):

    def setUp(self):
        data = dict( name='Antonio Santos',
            cpf='1212000000000009', email='antoniosantos@antoniosantos.net',
            phone='11-989002122')
        self.resp = self.client.post('/inscricao/', data)
        
    def test_post(self):
        'Invalid POST should not redirect'
        self.assertEqual(200, self.resp.status_code)


* CPF como dado inválido


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha
FAIL: test_save (palestrum.subscriptions.tests.test_views_subscripe.SubscribeInvalidPostTest)
Invalid POST should not redirect
----------------------------------------------------------------------
AssertionError: 200 != 302


arquivo: palestrum/subscriptions/views.py
def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        if form.is_valid():
            obj = Subscription(**form.cleaned_data)
            obj.save() 
            return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
        else:
            return render(request, 'subscriptions/subscription_form.html', 
                  {'form', form})
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})


* o “form.is_valid()” chama o “full_clean”, e se o “full_clean” foi bem sucedido retorna “True”.


=> Insere a restrição da qtde máxima de caracteres para CPF

arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms
from django.utils.translation import ugettext as _

class SubscriptionForm(forms.Form):
    name = forms.CharField(label=_('Nome'))
    cpf = forms.CharField(label=_('CPF'), max_length=11)
    email = forms.EmailField(label=_('Email'))
    phone = forms.CharField(label=_('Telefone'))






* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)




arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
. . . 
class SubscribeInvalidPostTest(TestCase):

    . . .
    def test_post(self):
        . . .
        
    def test_form_errors(self):
        'Form must contains errors'
        self.assertTrue(self.resp.context['form'].errors)

    def test_dont_save(self):
        'Do not save data.'
        self.assertFalse(Subscription.objects.exists())


* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)


== (Dica) Refatore com o ModelForm ==

== Quando o form é alinhado com Modelo ==

=> O que temos?

arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms
from django.utils.translation import ugettext as _

class SubscriptionForm(forms.Form):
    name = forms.CharField(label=_('Nome'))
    cpf = forms.CharField(label=_('CPF'), max_length=11)
    email = forms.EmailField(label=_('Email'))
    phone = forms.CharField(label=_('Telefone'))





=> passa a ser: 

arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms
from palestrum.subscriptions.models import Subscription

class SubscriptionForm(forms.ModelForm):

    class Meta:
        model = Subscription


arquivo: palestrum/subscriptions/views.py
. . .
def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        if form.is_valid():
            obj = form.save() 
            return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
        else:
            return render(request, 'subscriptions/subscription_form.html', 
                  {'form', form})
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})




** executar o teste
$ manage test palestrum.subscriptions
** Agora passou (Sucesso)




== Views Macarrônicas ( Alerta! )  ==

=> O que temos?

# arquivo: palestrum/subscriptions/views.py
def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        if form.is_valid():
            obj = form.save() 
            return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
        else:
            return render(request, 'subscriptions/subscription_form.html', 
                  {'form', form})
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})

=> A Tentação ( Alerta! )

arquivo: palestrum/subscriptions/views.py
def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        if form.is_valid():
            obj = form.save() 
            return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
        else:
            return render(request, 'subscriptions/subscription_form.html', 
                  {'form', form})
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})




=> DRY, só que não! ( Alerta! )

* Fluxos diferentes para Get, Post válido e Post inválido
def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        if form.is_valid():
            obj = form.save() 
            return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
    else:
        form = SubscriptionForm()
        
    return render(request, 'subscriptions/subscription_form.html', 
          {'form', form})







== Príncípio da Responsabilidade Única ( Dica ) ==

== Desmembrando Views “Complexas”  ==

=> O que temos?

def subscribe(request):
    if request.method == 'POST':
        form = SubscriptionForm(request.POST)
        if form.is_valid():
            obj = form.save() 
            return HttpResponseRedirect('/inscricao/%d/' % obj.pk)
        else:
            return render(request, 'subscriptions/subscription_form.html', 
                  {'form', form})
    else:
        return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})






arquivo: palestrum/subscriptions/views.py
# transformou em um dispatcher
def subscribe(request):
    if request.method == 'POST':
        return create(request)
    else:
        return new(request)

def new(request):
    return render(request, 'subscriptions/subscription_form.html', 
                  {'form', SubscriptionForm()})

def create(request):                  
    form = SubscriptionForm(request.POST)
    if not form.is_valid():
        return render(request, 'subscriptions/subscription_form.html', 
              {'form', form})
              
    obj = form.save() 
    return HttpResponseRedirect('/inscricao/%d/' % obj.pk)



* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)


Navegador: executando agora o runserver e testando no navegador (http://127.0.0.1:8080/inscricao/), ao submeter o formulário preenchido, recebemos uma página de erro ( Page not found - 404 )




== E a página de sucesso? ==

=> O que acontece?

Acesso em /inscricao/1/ e retorna 200
Renderiza o template
Context deve ter uma instância de Subscription
Página deve conter nome do cadastrado
Acesso à inscrição não cadastrada retorna 404



arquivo (novo): palestrum/subscriptions/tests/test_views_detail.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription

class DetailTest(TestCase):

    def setUp(self):
        s = Subscription.objects.create(name='Antonio Santos',
                                   cpf='12341234123',
                                   email='antoniosantos@antoniosantos.net',
                                   phone='11-989002122')        
        self.resp = self.client.get('/inscricao/%d/' % s.pk)
        
    def test_get(self):
        'GET /inscricao/1/ should return status 200'
        self.assertEqual(200, self.resp.status_code)


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha
FAIL: test_get (palestrum.subscriptions.tests.test_views_detail.DetailTest)
GET /inscricao/1/ should return status 200
----------------------------------------------------------------------
AssertionError: 200 != 404





arquivo: palestrum/urls.py
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', 'palestrum.core.views.home', name = 'home'),
    url(r'^inscricao/$', 'palestrum.subscriptions.views.subscribe', name='subscribe'),
    url(r'^inscricao/(\d+)/$', 'palestrum.subscriptions.views.detail', name='detail'),
    url(r'^admin/', include(admin.site.urls)),
)





=> criar uma view (a mais simples possível)

arquivo: palestrum/subscriptions/views.py
# coding: utf-8
from django.http import HttpResponseRedirect
from django.http import HttpResponse
from django.shortcuts import render
from palestrum.subscriptions.forms import SubscriptionForm

. . .

def detail(request, pk):
    return HttpResponse()



* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)



arquivo: palestrum/subscriptions/tests/test_views_detail.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription

class DetailTest(TestCase):
    . . .
        
    def test_get(self):
        . . .

    def test_template(self):
        'Uses template'
        self.assertTemplateUsed(self.resp,
                                'subscription/subscription_detail.html')




* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_template (palestrum.subscriptions.tests.test_views_detail.DetailTest)
Uses template
----------------------------------------------------------------------
AssertionError: No templates used to render the response


arquivo: palestrum/subscriptions/views.py
# coding: utf-8
from django.http import HttpResponseRedirect
from django.http import HttpResponse
from django.shortcuts import render
from palestrum.subscriptions.forms import SubscriptionForm
. . .

def detail(request, pk):
    return render(request, 'subscriptions/subscription_detail.html')





=> criação do template

# Estando no diretório bvad

$ cd palestrum/subscriptions/templates
$ touch subscriptions/subscription_detail.html
$ cd - 


* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)



arquivo: palestrum/subscriptions/tests/test_views_detail.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription

class DetailTest(TestCase):
    . . .
        
    def test_template(self):
        . . .

    def test_context(self):
        'Context must have a subscription instance'
        subscription = self.resp.context['subscription']  
        self.assertIsInstance(subscription, Subscription)


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
ERROR: test_context (palestrum.subscriptions.tests.test_views_detail.DetailTest)
Context must have a subscription instance
----------------------------------------------------------------------
KeyError: 'subscription'



arquivo: palestrum/subscriptions/views.py
# coding: utf-8
from django.http import HttpResponseRedirect
from django.http import HttpResponse
from django.shortcuts import render
from palestrum.subscriptions.forms import SubscriptionForm
from palestrum.subscriptions.models import Subscription
. . .

def detail(request, pk):
    subscription = Subscription.objects.get(pk=pk)
    return render(request, 'subscriptions/subscription_detail.html',
                  {'subscription': subscription})


* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)


arquivo: palestrum/subscriptions/tests/test_views_detail.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription

class DetailTest(TestCase):
    . . .
        
    def test_context(self):
        . . .

    def test_html(self):
        'Check if subscription data was rendered'
        self.assertContains(self.resp, 'Antonio Santos')

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_html (palestrum.subscriptions.tests.test_views_detail.DetailTest)
Check if subscription data was rendered
----------------------------------------------------------------------
AssertionError: Couldn't find 'Antonio Santos' in response


arquivo: palestrum/subscriptions/templates/subscriptions/subscription_detail.html
{% extends 'base.html' %}
{% block content %}
  <p>Parabéns {{ subscription.name }},</p>
  <p>sua inscrição foi realizada em 
     {{ subscription.created_at|date:"d/m/Y" }}</p>
  <p>
    Em breve, entraremos em contato pelo
    {% if subscription.phone %}
        telefone {{ subscription.phone }}
    {% else %}
        {{ subscription.email }}
    {% endif %}
    </p>
{% endblock content %}

* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)


=> cenário de falha
 
arquivo: palestrum/subscriptions/tests/test_views_detail.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription

class DetailTest(TestCase):
    . . .
        
class DetailNotFound(TestCase):

    def test_not_found(self):
        response = self.client.get('/inscricao/0/')
        self.assertEqual(404, response.status_code)

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
ERROR: test_not_found (palestrum.subscriptions.tests.test_views_detail.DetailNotFound)
----------------------------------------------------------------------
DoesNotExist: Subscription matching query does not exist.

arquivo: palestrum/subscriptions/views.py
# coding: utf-8
from django.http import HttpResponseRedirect
from django.http import HttpResponse
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from palestrum.subscriptions.forms import SubscriptionForm
from palestrum.subscriptions.models import Subscription
. . .

def detail(request, pk):
    subscription = get_object_or_404(Subscription, pk=pk)
    return render(request, 'subscription/subscription_detail.html'.
                  {'subscription': subscription})


* executar o teste
$ manage test palestrum.subscriptions
* passou (Sucesso)



Navegador: executando agora o runserver e testando no navegador (http://127.0.0.1:8000/inscricao/1/), os dados da inscrição realizada são apresentados.



== Funciona ? ==


$ manage test

Creating test database for alias 'default'...
.......................
----------------------------------------------------------------------
Ran 23 tests in 0.254s

OK
Destroying test database for alias 'default'...




== Manfa para o Heroku! ==

$ git add .

$ git commit -m 'Subscription'
[master b57218f] Subscription
 17 files changed, 309 insertions(+), 45 deletions(-)
 rename palestrum/core/templates/{index.html => base.html} (77%)
 rewrite palestrum/core/templates/index.html (82%)
 create mode 100644 palestrum/subscriptions/__init__.py
. . .
 create mode 100644 palestrum/subscriptions/tests/test_views_subscripe.py
 create mode 100644 palestrum/subscriptions/views.py

$ git status
# No ramo master
nada a submeter, diretório de trabalho vazio

$ git push heroku master --force
Fetching repository, done.
Counting objects: 31, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (22/22), done.
Writing objects: 100% (23/23), 5.08 KiB, done.
Total 23 (delta 6), reused 0 (delta 0)
. . . 
   1499061..b57218f  master -> master

$ heroku run python manage.py syncdb
Running `python manage.py syncdb` attached to terminal... up, run.8005
Creating tables ...
Creating table django_admin_log
Creating table auth_permission
. . .
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)






== Rotas - URLConf no detalhe ==

* São expressões regulares que ficam armazenadas no arquivo urls.py.

* Compõe uma url (expressão regular) que delegará o processamento para uma view.

* Django trabalha diferente de outros frameworks: é mais permissívo (bom e ruim ao mesmo tempo). A sua estratégia é não ficar no seu caminho.

* URLConf é quem define a Rota. É um módulo Python que tem uma estrutura (URLPatterns).


== Refatorando o URLConf ==

* É possíve ter vários URLConf na aplicação (ex.: pode ser um por app), e não precisam ter exatamente ter o nome urls.py, deve apenas seguir o mesmo formato do módulo.


== ROOT_URLCONF ==

* Configurado no “settings”. Indica qual URLConf será tratado como o principal. É possível modificar isso dinamicamente (de acordo com a requisição). [mais avançado].
* patterns, include e url ⇒ são combinadas para montar uma árvore de rotas
* patterns ⇒ (principal) devolve uma coleção de rotas
* Quando recebe uma requisição, o Django processa as rotas uma-a-uma, da primeira para a última, e interrompe o processamento quando encontra o primeiro “matching”. Se não encontrar “matching” algum, retorna o status HTTP 404
* Importante observar que o patterns recebe dois ou mais argumentos. No caso a seguir, o primeiro argumento é uma string vazia (é o prefixo, ou seja, com o que começa. Poderia ser ‘palestrum’).

from django.conf.urls import patterns, include, url
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', 'palestrum.core.views.home', name='home'),
    url(r'^inscricao/$', 'palestrum.subscriptions.views.subscribe', name='subscribe'),
    url(r'^inscricao/(\d+)/$', 'palestrum.subscriptions.views.detail', name='detail'),
    url(r'^admin/', include(admin.site.urls)),
)

=> Refatorar a URLConf anterior, pois tudo foi definido no ROOT_URLCONF e agora há duas apps expondo todas as suas rotas diretamente, gerando um acoplamento com o URLConf

!!! urls.py é uma convenção para nomear o arquivo que contém um URLConf

# Estando em bvad …
# Crie o arquivo urls.py na app core
$ touch palestrum/core/urls.py

# Crie o arquivo urls.py na app subscriptions
$ touch palestrum/subscriptions/urls.py


arquivo: palestrum/urls.py
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', 'palestrum.core.views.home', name='home'),
    url(r'',include('palestrum.core.urls', namespace='core')),
    url(r'^inscricao/$','palestrum.subscriptions.views.subscribe', name='subscribe'),
    url(r'^inscricao/(\d+)/$','palestrum.subscriptions.views.detail', name='detail'),
    url(r'^admin/', include(admin.site.urls)),
)


* Em vez de usar a regexp completa associada ao nome da view, inclui-se a URLConf da app core, dando-se um nome para o include (namespace=‘core’). 
* Com isso, na hora de carregar o Django importará a URLConf .
* Ao chegar um request, se houver match com a regexp (no caso faz, pois é a mais permissiva - vazia), delega a requisição para a URLConf da app core (vide a seguir). 

arquivo: palestrum/core/urls.py
# coding: utf-8
from django.conf.urls import patterns, include, url

urlpatterns = patterns('palestrum.core.views', 
    url(r'^$', 'home', name='home'),
)

arquivo: palestrum/urls.py
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    url(r'', include('palestrum.core.urls', namespace='core')),
    url(r'^inscricao/$','palestrum.subscriptions.views.subscribe', name='subscribe'),
    url(r'^inscricao/(\d+)/$', 'palestrum.subscriptions.views.detail', name='detail'),
    url(r'^inscricao/', include('palestrum.subscriptions.urls',
        namespace='subscriptions')),
    url(r'^admin/', include(admin.site.urls)),
)

* faz o math com qualquer request que começar com ‘inscricao/’ (match parcial, o resto é delegado para a URLConf do include)


arquivo: palestrum/subscriptions/urls.py
# coding: utf-8
from django.conf.urls import patterns, include, url

urlpatterns = patterns('palestrum.subscriptions.views',
    url(r'^$', 'subscribe', name='subscribe'),
    url(r'^(\d+)/$', 'detail', name='detail'),
)
* Ex.: http://palestrum.com/inscricao/1/




== Permissivas no final! ==

arquivo: palestrum/urls.py
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    url(r'^inscricao/', include('palestrum.subscriptions.urls',
        name='subscriptions')),
    url(r'^admin/', include(admin.site.urls)),
    url(r'', include('palestrum.core.urls', namespace='core')),
)
** Para evitar desperdício de processamento. Tudo faz “match” com a rota “vazia”, não faz sentido deixá-la em primeiro lugar, pois todas as requisições passarão por ela.
** Organizar sempre da mais específica para a mais genérica


* executar o teste
$ manage test
* passou (Sucesso)
* O teste dá tranquilidade para organizar o código.



== Evitando URLs hardcoded ==

=> URL Resolvers

* resolve ⇒ é a função que o Django usa para mapear rotas

* reverse ⇒ faz o caminho contrário  (pouco usado)

$ manage shell

>>> from django.core.urlresolvers import reverse, resolve

>>> resolve('/inscricao/1/')
ResolveMatch(func=<function detail<, args=('1',), kwargs={},
   url_name='detail', app_name='None', namespace='subscription')

>>> reverse('subscriptions:detail', args=[1])
'/inscricao/1/'




== Refatore os Testes! == 

arquivo: palestrum/core/tests.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class HomeTest(TestCase):

    def setUp(self):
        self.resp = self.client.get(r('core:home'))

    def test_get(self):
        . . .




arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
# coding: utf-8
. . .
from django.core.urlresolvers import reverse as r

class SubscribePostTest(TestCase):
    def setUp(self):
        self.resp = self.client.get(r('subscriptions:subscribe'))
    . . .

class SubscribePostTest(TestCase):
    def setUp(self):
        data = dict( name='Antonio Santos',
            cpf='12341234123', email='antoniosantos@antoniosantos.net',
            phone='11-989002122')
        self.resp = self.client.post(r('subscriptions:subscribe'),data)
        . . .

class SubscribeInvalidPostTest(TestCase):
    def setUp(self):
        data = dict( name='Antonio Santos',
            cpf='000000000009', email='antoniosantos@antoniosantos.net',
            phone='11-989002122')
        self.resp = self.client.post(r('subscriptions:subscribe'),data)
        . . .

arquivo: palestrum/subscriptions/tests/test_views_detail.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.models import Subscription
from django.core.urlresolvers import reverse as r

class DetailTest(TestCase):
    def setUp(self):
        s = Subscription.objects.create(name='Antonio Santos',
                                   cpf='12341234123',
                                   email='antoniosantos@antoniosantos.net',
                                   phone='11-989002122')        
        self.resp = self.client.get(r('subscriptions:detail', args=[s.pk]))
    . . .        
class DetailNotFound(TestCase):
    def test_not_found(self):
        response = self.client.get(r('subscriptions:detail', args=[0]))
        self.assertEqual(404, response.status_code)
        . . .

arquivo: palestrum/core/templates/core/index.html
{% extends 'base.html' %}
{% block content %}
  <h1>Bem-vindo ao palestrum!</h1>
  <p>O evento mais sensacional do ano depois do Dev in Rio!</p>
  <p>Você não pode perder esta oportunidade!</p>
  <p><strong><a href="{% url 'subscriptions:subscribe' %}">
             Inscreva-se já!</a></strong></p>
  <p>
    Para dúvidas e mais informações entre em contato com
    <a href="mailto:palestrum@palestrum.com.br">
      palestrum@palestrum.com.br
    </a>.
  </p>
{% endblock content %}


* template tag url ⇒ foi eliminada a url hardcoded (index.html) e substituída pela template tag url. Agora, se mudar alguma coisa na rota (nome, internacionalização), basta alterar no URLConf






* executar o teste
$ manage test
* passou (Sucesso)





== EXPRESSÕES REGULARES ==

http://docs.python.org/library/re.html%23re-syntax
http://www.pythonregex.com/

=> Exemplo

$ manage shell

>>> import re

# Ordered Group Match
>>> pattern = re.compile(r'^time/plus/(\d{1,2})/$')

>>> match = pattern.search('time/plus/1/')

>>> match.groups()
('1',)

>>> match.groupdict()
{}

>>> pattern = re.compile(r'^time/plus/(\d{1,2})/(\w+)/$')
>>> match = pattern.search('time/plus/1/hour/')

>>> match.groups()
('1', 'hour')

# Named Group
>>> pattern =re.compile(r'^time/plus/(?P<offset>\d{1,2})/(?P<unit>\w+)/$')
>>> match = pattern.search('time/plus/1/hour/')

>>> match.groups()
('1', 'hour')

>>> match.groupdict()
{'offset': '1', 'unit': 'hour'}




== Funções em Python - Como funcionam? ==

== Função sem argumento ==

>>> def f():
...    print 'Opa!'

>>> f()
Opa!

>>> f('um argumento qualquer')
TypeError: f() takes no arguments (1 given)




== Função com argumentos ==

>>> def f(a, b, c):
...    print a, b, c

# Sem argumentos
>>> f()
TypeError: f() takes exactly 3 arguments (0 given)

# 3 posicionais
>>> f('A', 'B', 'C')
A B C

# 1 posicional, 2 nomeados
>>> f('A', c='C', b='B')
A B C






== Função com argumentos e valor default ==

>>> def f(a, b, c='dC'):
...    print a, b, c

# 2 posicionais, 1 default
>>> f('A','B')
A B dC

# 3 posicionais
>>> f('A', 'B', 'C')
A B C

# 1 posicional, 2 nomeados
>>> f('A', c='C', b='B')
A B C

# 2 nomeados, 1 default
>>> f(b='B', a='A')
A B dC


== Função sem limite de parâmetros posicionais ==

>>> def f(a, b, c='dC', *args):
...    print a, b, c, args

# 2 posicionais, 1 default
>>> f('A','B')
A B dC ()

# 3 posicionais
>>> f('A', 'B', 'C')
A B C ()

# 5 posicionais
>>> f('A', 'B', 'C', 'D', 'E')
A B C ('D', 'E')






== Função sem limite de parâmetros nomeados ==

>>> def f(a, b, c='dC', **kwargs):
...    print a, b, c, kwargs

# 2 posicionais, 1 default
>>> f('A','B')
A B dC {}

# 5 nomeados
>>> f(outro='D', maisum='E', a='A', b='B', c='C')
A B C {'outro': 'D', 'maisum': 'E'}





== URLs Dinãmicas - Passando parâmetros posicionais ou nomeados para Views ==

== Don’t repeat yourself ==

urlpatterns = patterns('',
    url(r'^time/plus/1/$', one_hour_ahead),
    url(r'^time/plus/2/$', two_hours_ahead),
    . . .
    url(r'^time/plus/24/$', tons_hour_ahead),
)

==  Bem melhor ==

urlpatterns = patterns('',
    url(r'^time/plus/(\d{1,2})/$', time_ahead),
)




== One hour ahead ==
# Url pattern simples no urls.py
url(r'^time/plus/1/$', 'one_hour_ahead')

# Uma view simples no views.py
from datetime import datetime, timedelta
from django.http import HttpResponse

def one_hour_ahead(request): # Sem parâmetros
    dt = datetime.now() + timedelta(hours=1)
    text = "In %s hours, it will be %s." % (1, dt)
    return HttpResponse(text)

== Parâmetros da URL  ⇒ View  ==
# Regex Ordered Group match
url(r'^time/plus/(\d{1,2})/$', 'time_ahead')

# Uma view simples no views.py
from datetime import datetime, timedelta
from django.http import HttpResponse

def time_ahead(request, offset): # Positional args, ordem importa
    offset = int(offset)
    dt = datetime.now() + timedelta(hours=offset)
    text = "In %s hours, it will be %s." % (offset, dt)
    return HttpResponse(text)

= Parâmetros da URL  ⇒ View ==
# Regex Named Group match
url(r'^time/plus/(?P<offset>\d{1,2})/(?P<unit>\w+)/$', 'time_ahead')

from datetime import datetime, timedelta
from django.http import HttpResponse

def time_ahead(request, unit, offset): # Named args, ordem não importa
    offset = int(offset)
    if unit == 'minutes':
        dt = datetime.now() + timedelta(minutes=offset)
    else:
        dt = datetime.now() + timedelta(hours=offset)

    text = "In %s %s, it will be %s." % (offset, unit, dt)
    return HttpResponse(text)

== COMO SEI QUEM SE INSCREVEU ? ==

== Ativando o Django Admin ==

=> Já vem ativado no 1.6!

== Acesse o Admin ==

$ manage runserver
Validating models...

0 errors found
March 08, 2014 - 13:40:43
Django version 1.6, using settings 'palestrum.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

Navegador: http://127.0.0.1:8000/admin/

== Se não tem administrador ==  (Dica)

$ manage cratesuperuser
Username: admin
E-mail address: admin@admin.com
Password:
Password (again):
Superuser created successfully.


==  Se esquecer a sua senha ==  (Dica)

$ manage changepassword admin
Changing password for user 'admin'
Password:
Password (again):
Password changed successfully. for user 'admin'

Navegador: http://127.0.0.1:8000/admin/
Navegador:  ( Onde estão as inscrições? )


== Registrando seu Model no Admin ==

arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

admin.site.register(Subscription)
* para que as inscrições sejam apresentadas no admin, é necessário registrar o Modelo das inscrições (Subscription) no Admin. 

Navegador: http://127.0.0.1:8000/admin/
* Agora surge o item Subscriptions (com um link para Inscrições

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Ao acessar o link “inscrições”, mostra apenas uma coluna, pois está mostrando o __unicode__ do modelo (neste caso, o nome). 
* Para que as demais colunas sejam apresentadas na listagem, fornecer uma classe que herda de ModelAdmin para poder detalhar a relação entre o Modelo com o Admin do Django.


arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

class SubscriptionAdmin(admin.ModelAdmin):
    list_display = ('name', 'email', 'cpf', 'phone', 'created_at')

admin.site.register(Subscription, SubscriptionAdmin)    
* Tupla com os nomes dos atributos que devem ser apresendos (na ordem).


Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora, ao acessar o link “inscrições”, surgem os atributos solicitados na tabela (Verbose Names)






arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

class SubscriptionAdmin(admin.ModelAdmin:
    list_display = ('name', 'email', 'cpf', 'phone', 'created_at')
    date_hierarchy = 'created_at'

admin.site.register(Subscription, SubscriptionAdmin)
* Cria um agrupamento por data (dias, meses, anos… fica mais fácil filtrar).

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora surge a hierarquia de datas no topo da tabela, que possibilita a apresentação dos registros pela data de criação

* Obtive este erro: This query requires pytz, but it isn't installed.
* Tive que ajustar o USE_TZ=False em settings.py
* http://stackoverflow.com/questions/21084332/django-tutorial-improperlyconfigured-exception-pytz-isnt-installed


arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

class SubscriptionAdmin(admin.ModelAdmin:
    list_display = ('name', 'email', 'cpf', 'phone', 'created_at')
    date_hierarchy = 'created_at'
    search_fields = ('name', 'email', 'cpf', 'phone', 'created_at')

admin.site.register(Subscription, SubscriptionAdmin)    
* Quais parâmetros serão usados na busca. Tupla indicando quais atributos serão usados na busca e qual é a ordem de precedência a ser usada na busca.

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora surge a caixa de pesquisa


arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.utils.datetime_safe import datetime
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

class SubscriptionAdmin(admin.ModelAdmin:
    list_display = ('name', 'email', 'cpf', 'phone', 'created_at',
                    'subscribed_today')
    date_hierarchy = 'created_at'
    search_fields = ('name', 'email', 'cpf', 'phone', 'created_at')

    def subscribed_today(self, obj):
        return obj.created_at.date() == datetime.today().date()
        return obj.created_at.date() == datetime.utcnow().date()

admin.site.register(Subscription, SubscriptionAdmin)    
* também funcionaria: (from django.utils.timezone import now)
* O atributo subscribed_today não existe no Modelo

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora apresenta uma nova coluna na tabela, indicando se a inscrição foi feita hoje 

arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.utils.timezone import now
from django.utils.translation import ugettext as _
from django.contrib import admin
from palestrum.subscriptions.models import Subscription


class SubscriptionAdmin(admin.ModelAdmin):
    ...
    def subscribed_today(self, obj):
        return obj.created_at.date() == now().date()

    subscribed_today.short_description = _(u'Inscrito hoje?')

admin.site.register(Subscription, SubscriptionAdmin)



Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora apresenta um título diferenciado para a nova coluna (Internacionalizado)

arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.utils.datetime_safe import datetime
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

class SubscriptionAdmin(admin.ModelAdmin:
    . . .
    search_fields = ('name', 'email', 'cpf', 'phone', 'created_at')
    . . .
    subscribed_today.short_description = _(u'Inscrito hoje?')
    subscribed_today.boolean = True

admin.site.register(Subscription, SubscriptionAdmin)

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora, em vez de apresentar True ou False, apresenta um marcador gráfico booleano

arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.utils.datetime_safe import datetime
from django.contrib import admin
from palestrum.subscriptions.models import Subscription

class SubscriptionAdmin(admin.ModelAdmin:
    list_display = ('name', 'email', 'cpf', 'phone', 'created_at',
                    'subscribed_today')
    date_hierarchy = 'created_at'
    search_fields = ('name', 'email', 'cpf', 'phone', 'created_at')

    list_filter = ['created_at']
    
    def subscribe_today(self, obj):
        #return obj.created_at.date() == datetime.today().date()
        return obj.created_at.date() == datetime.utcnow().date()

admin.site.register(Subscription, SubscriptionAdmin)    

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora, acrescenta uma opção de filtragem por data de criação
* list_filter ⇒ parâmetros que serão usados para filtragem. O Django Admin já possui vários Filter Descriptors, que funcionam dependendo do tipo de dado. É possível implementar um novo.

arquivo: palestrum/settings.py
# Internationalization
# https://docs.djangoproject.com/en/1.6/topics/i18n/

LANGUAGE_CODE = 'pt-BR'

TIME_ZONE = 'America/Sao_Paulo'

USE_I18N = True

USE_L10N = True

USE_TZ = True



Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Perceber a tradução para “pt-BR” no Django Admin





== Como sei quem pagou a inscrição? ==

Não sabe! :-)

Este recurso ainda não existe no sistema. 

Programador que trabalha com testes não reclama de mudança de escopo, abraça a mudança, pois está tudo testado, tudo resolvido.


== MIGRAÇÕES DE MODELO COM South ==

http://south.aeracode.org/

=> 1o conceito enraizado ⇒ Programador não é DBA (vice e versa)

* A capacidade de migrar dados parte da premissa de que o seu sistema não é o código escrito, o software é a execução do código no ambiente em que está sendo executado.
* A organização do repositório é importante por isso. Deve-se tratar o schema do bd como parte do código também.
* Motivo do nome South: é para onde os moradores do hemisfério norte migram no inverno.


== Instalação do South ==

# Com o virtualenv ativado:
$ pip install south==0.8.4


arquivo: bvad/requirements.txt
Django==1.6
Unipath==1.0
dj-database-url==0.2.2
dj-static==0.0.5
gunicorn==18.0
psycopg2==2.5.1
django-decouple==2.1
South==0.8.4



arquivo: palestrum/settings.py
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'south',
    'palestrum.core',
    'palestrum.subscriptions',
)
* Recomendação de organização: primeiro as coisas do Django, depois outras dependências e só depois as apps.

$ manage syncdb

Syncing...
Creating tables ...
Creating table south_migrationhistory
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)

Synced:
 > django.contrib.admin
 > django.contrib.auth
 > django.contrib.contenttypes
 > django.contrib.sessions
 > django.contrib.messages
 > django.contrib.staticfiles
 > south
 > palestrum.core
 > palestrum.subscriptions

Not synced (use migrations):

-- 
(use ./manage.py migrate to migrate these)
* south_migrationhistory ⇒ tabela do South utilizada para registrar quando e qual foi a migração executada
* Em um projeto é possível ter apps controladas pelo South e outras que não são controladas pelo South  (Synced == tratadas pelo South)


== Faça o South gerenciar a app Subscriptions ==

$ manage schemamigration subscriptions --initial
Creating migrations directory at '/bvad/palestrum/subscriptions/migrations'...
Creating __init__.py in '/bvad/palestrum/subscriptions/migrations'...
 + Added model subscriptions.Subscription
Created 0001_initial.py.
You can now apply this migration with: ./manage.py migrate subscriptions

# --initial ⇒ importante, pois cria a migração inicial 
# (instruções de criação das tabelas)
# É a existência da package “migrations” dentro da app “subscriptions” 
# o que indica ao South que ele deve gerenciar a app. 
# Se não tiver a package “migrations” criada, a app passa a 
# ser gerenciada pelo syncdb

$ manage migrate --list
 subscriptions
  ( ) 0001_initial

# Mostra quais são as apps gerenciadas pelo South e quais são 
# as migrações existentes.
# Neste caso, como está desmarcada, a migração “0001_initial” não 
# consta no histórico do South (no BD tudo foi feito, mas não está 
# no histórico).

$ manage migrate subscriptions 0001 --fake
- Soft matched migration 0001 to 0001_initial.
Running migrations for subscriptions:
 - Migrating forwards to 0001_initial.
 > subscriptions:0001_initial
  (faked)
  
# não é necessário começar uma app usando South, mas quando decidir 
# usá-lo, é necessário alinhar o South com o estado do BD.
# --fake ⇒ roda a migração no estado de “drive-run” (Não roda os
# comandos DDL SQL). Considera que a migração já foi executada.

$ manage migrate --list
 subscriptions
  (*) 0001_initial

* No syncdb não dá para voltar o histórico. Cria tabelas que não existem, não atualiza tabelas.
* O migrate do South faz migrações pra frente e pra trás.


== “Bora mudar o modelo?” ==

** TEST FIRST

arquivo: palestrum/settings.py
# coding: utf-8
. . .

# Usar o South para preparar o banco nos testes?
# True: Sim (default)
# False: Não! Use o Syncdb
SOUTH_TESTS_MIGRATE = False
* Macete para trabalhar com testes e com o South
* Para rodar os testes usa sempre syncdb. Na integração do código (do branch p/ o master), altera para True, e roda os testes com o South para ver se os testes vão rodar. 

arquivo: palestrum/subscriptions/tests/test_models.py
# coding: utf-8
. . .

class SubscriptionTest(TestCase):
    . . .

    def test_unicode(self):
        self.assertEqual(u'Antonio Santos', unicode(self.obj))

    def test_paid_default_value_is_False(self):
        'By default paid must be False.'
        self.assertEqual(False, self.obj.paid)

class SubscriptionUniqueTest(TestCase):
    . . .



* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** O teste falha 
ERROR: test_paid_default_value_is_False (palestrum.subscriptions.tests.test_models.SubscriptionTest)
By default paid must be False.
----------------------------------------------------------------------
AttributeError: 'Subscription' object has no attribute 'paid'


arquivo: palestrum/subscriptions/models.py
class Subscription(models.Model):
    name = models.CharField(_('Nome'), max_length=100)
    cpf = models.CharField(_('CPF'), max_length=11, unique=True)
    email = models.EmailField(_('Email'), unique=True)
    phone = models.CharField(_('Telefone'), max_length=20, blank=True)
    created_at = models.DateTimeField(_('Criado em'), auto_now_add==True)
    paid = models.BooleanField(_('Pago'), default=False)

    class Meta:
        . . .




** executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
** O teste falha 
FAIL: test_form_has_fields (palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
Form must have 4 fields.
----------------------------------------------------------------------
First has 0, Second has 1:  'paid'


Navegador: http://127.0.0.1:8000/inscricao/
* Ao visualizar o formulário web de inscrição, temos apenas 4 campos. Não tem um campo a mais! 




=> Ao executar o “manage shell”

$ manage shell

>>> from palestrum.subscriptions.forms import SubscriptionForm
>>> f = SubscriptionForm()
>>> print f.fields
{ 'name': <django.forms.fields.CharField object at 0x1027a37d0>,
  'cpf': <django.forms.fields.CharField object at 0x1027a3390>,
  'email': <django.forms.fields.EmailField object at 0x1027a32d0>,
  'phone': <django.forms.fields.CharField object at 0x1027a3210>,
  'paid': <django.forms.fields.BooleanField object at 0x1027a3150>}
* WTF! Falha de Segurança
* No HTML não tem o campo ‘paid’, mas se alguém fizer uma submissão (POST) com “paid=True”, a requisição vai transpassar o sistema inteiro e vai persistir a inscrição como “paga”.
* Obs.: o atributo “created_at” é um “auto_now_add”, ganha um atributo “editable” que é definido como “false”. Por isso o ModelForm nunca “pega” este atributo, pois ele não pode ser editado (ver documentação do Django)

arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms
from palestrum.subscriptions.models import Subscription

class SubscriptionForm(forms.Form):
    class Meta:
        model = Subscription
        exclude = ('paid',)
* Uma das formas de se proteger do problema é excluir o atributo do tratamento.
* A forma mais paranóica e que deveria ser usada, é usar fields. Indicaria quais atributos deveriam ser tratados no formulário, não importando as modificações no modelo.



** executar o teste
$ manage test palestrum.subscriptions
** Agora passou (Sucesso)


=> Um campo foi adicionado. É hora de fazer a migração

$ manage schemamigration subscriptions --auto

+ Added field paid on subscriptions.Subscription
Created 0002_auto__add-field_subscription_paid.py.
You can now apply this migration with: ./manage.py migrate subscriptions

$ manage migrate --list  

subscriptions
 (*) 0001_initial
 ( ) 0002_auto__add-field_subscription_paid


$ manage migrate subscriptions

Running migrations for subscriptions 
- Migrating forwards to 0002_auto__add-field_subscription_paid.
> subscriptions: 0002_auto__add-field_subscription_paid
- Loading initial data for subscriptions
Installed 0 object(s) from 0 fixture(s)

$ manage migrate --list  

subscriptions
 (*) 0001_initial
 (*) 0002_auto__add-field_subscription_paid









== Atualize o Admin ==

arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
. . .
 
class SubscriptionAdmin(admin.ModelAdmin):
    list_display = ('name', 'email', 'cpf', 'phone', 'created_at',
                    'subscribed_today', 'paid')
    date_hierarchy = 'created_at'
    search_fields = ('name', 'email', 'cpf', 'phone', 'created_at')
    list_filter = ['created_at']
    . . .

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora apresenta a coluna “Pago” na tabela de Inscrições



== Para o deploy no Heroku ==

# Estando em bvad, commite os códigos alterados
$ git add . 
$ git commit -m 'Migrations'

# Faça o push para o Heroku
$ git push heroku master --force

# Rode o syncdb para criar as tabelas das apps sem south.
$ heroku run python manage.py syncdb

# Sincronize o histórico do South com o estado atual do banco
$ heroku run python manage.py migrate subscriptions 0001 --fake

# Execute as migrações restantes para adicionar o campo paid
$ heroku run python manage.py syncdb --migrate




== Como o South funciona? ==

http://south.aeracode.org/


# Comandos novos
$ manage help

Available subcommands:
...
[south]
 convert_to_south
 datamigration
 graphmigrations
 migrate
 migrationcheck
 schemamigration
 startmigration
 syncdb
 test
 testserver
...


== Migrações

/bvad
  /palestrum
    /subscriptions
      /migrations
        __init__.py
        0001_initial.py
        0002_auto__add-field_subscription_paid.py

== Anatomia de um Schemamigration ==

*** Rever

== Anatomia de um Datamigration ==

*** Rever


== É possível marcar vários inscritos como pago de uma vez? ==

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Ainda não existe uma “Ação” que permita marcar vários registros como “pagos” de uma vez.



== “Bora fazer a action?” ==

** TEST FIRST

* Custom Action

# Estando no diretório bvad:
# Crie o módulo test_admin.py na app subscriptions
$ touch palestrum/subscriptions/tests/test_admin.py


arquivo: palestrum/subscriptions/tests/test_admin.py
# coding: utf-8
from django.test import TestCase
from palestrum.subscriptions.admin import SubscriptionAdmin,Subscription,admin

class MarkAsPaidTest(TestCase):
    def setUp(self):
        # Instancia o Model Admin
        self.model_admin = SubscriptionAdmin(Subscription, admin.site)
    
    def test_has_action(self):
        'Action is installed'
        self.assertIn('mark_as_paid', self.model_admin.actions)
* perceber que os objetos SubscriptionAdmin, Subscription e admin foram importados do módulo admin da app subscriptions. Não está trazendo os objs do módulo models, pois o módulo admin já fez o import do modelo, então os objetos são os mesmos (faz apenas uma referência).
* model_admin é a unidade de teste neste caso.
* Recomendação: é preciso compreender a API do que está sendo testado. Pra fazer os testes do model_admin, foi necessário ler o código e estudá-lo.



* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_has_action (palestrum.subscriptions.tests.test_admin.MarkAsPaidTest)
Action is installed
----------------------------------------------------------------------
AssertionError: 'mark_as_paid' not found in []



=> Inserção da Custom Action


arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
. . .
 
class SubscriptionAdmin(admin.ModelAdmin):
    . . .
    subscribed_today.boolean = True

    actions = ['mark_as_paid']
    
admin.site.register(Subscription, SubscriptionAdmin)    



* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)




arquivo: palestrum/subscriptions/tests/test_admin.py
# coding: utf-8
from django.test import TestCase
from mock import Mock
from palestrum.subscriptions.admin import
                   SubscriptionAdmin,Subscription,admin

class MarkAsPaidTest(TestCase):
    def setUp(self):
        # Instancia o Model Admin
        self.model_admin = SubscriptionAdmin(Subscription, admin.site)

        # Popula o banco
        Subscription.objects.create(name='Antonio Santos',
                         cpf='12345678901', email='antoniosantos@antoniosantos.net')
    . . .

    def test_mark_all(self):
        'Mark all as paid.'
        fake_request = Mock()
        queryset = Subscription.objects.all()
        self.model_admin.mark_as_paid(fake_request, queryset)

        self.assertEqual(1, Subscription.objects.filter(paid=True).count())
* (Dica) Estudar o código do Mock para aprender meta-programação


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
ERROR: palestrum.subscriptions.tests.test_admin 
(unittest.loader.ModuleImportFailure)
----------------------------------------------------------------------
ImportError: No module named mock





== Instalando o Mock ==

# Com o virtualenv ativado
$ pip install mock==1.0.1


arquivo: bvad/requirements.txt
Django==1.6
Unipath==1.0
dj-database-url==0.2.2
dj-static==0.0.5    (saiu?)
gunicorn==18.0
psycopg2==2.5.1
django-decouple==2.1 (saiu?)
South==0.8.4
mock==1.0.1



* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
ERROR: test_mark_all
(palestrum.subscriptions.tests.test_admin.MarkAsPaidTest)
Mark all as paid.
--------------------------------------------------------
AttributeError: 'SubscriptionAdmin' object has no attribute 'mark_as_paid'





arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
. . .
 
class SubscriptionAdmin(admin.ModelAdmin):
    . . .
    subscribed_today.boolean = True
    
    actions = ['mark_as_paid']

    def mark_as_paid(self, request, queryset):
        pass
    
admin.site.register(Subscription, SubscriptionAdmin)    


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_mark_all
 (palestrum.subscriptions.tests.test_admin.MarkAsPaidTest)
Mark all as paid.
----------------------------------------------------------
AssertionError: 1 != 0


arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
. . .
 
class SubscriptionAdmin(admin.ModelAdmin):
    . . .
    subscribed_today.boolean = True
    
    actions = ['mark_as_paid']

    def mark_as_paid(self, request, queryset):
        count = queryset.update(paid=True)
    
admin.site.register(Subscription, SubscriptionAdmin)    

* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora surge a opção “Mark as Paid” na listagem de ações disponíveis.


arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
. . .
 
class SubscriptionAdmin(admin.ModelAdmin):
    . . .
    subscribed_today.boolean = True
    
    actions = ['mark_as_paid']

    def mark_as_paid(self, request, queryset):
        count = queryset.update(paid=True)
    
    mark_as_paid.short_description = _('Marcar como Pago')

admin.site.register(Subscription, SubscriptionAdmin)    

Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Agora a opção “Mark as Paid” foi traduzida para “Marcar como Pago”.




== FEEDBACK DO Action -- Como faz? ==

* Estrutura de mensageria do Django.

arquivo: palestrum/subscriptions/admin.py
# coding: utf-8
from django.utils.timezone import now
from django.utils.translation import ungettext, ugettext as _
...

class SubscriptionAdmin(admin.ModelAdmin):
    ...
    def mark_as_paid(self, request, queryset):
        count = queryset.update(paid=True)

        msg = ungettext(
            u'%d inscrição foi marcada como paga.',
            u'%d inscrições foram marcadas como pagas.',
            count
        )
        self.message_user(request, msg % count)

    mark_as_paid.short_description = _('Marcar como pago')
...
* ungettext ⇒  trata também o plural. Pode usar também o texto como “chave” para buscar no dicionário de internacionalização.


Navegador: http://127.0.0.1:8000/admin/subscriptions/subscription/
* Após realizar a ação “Marcar como Pago”, a mensagem é exibida de acordo com a quantidade de itens afetados



“ All Input is Evil! “ - Writing Secure Code

* Recomenda ler o livro: Writing Secure Code
* Validação em formulário em JavaScript? Pode ser feito, mas jamais substitui a validação do form no Django (no backend). A validação em JS está mais relacionada a usabilidade do que a segurança. (A validação JS não seguraria um post forjado).
* Mas os dados estão vindo do BD, preciso tratar/criticar? Sim, pois não se sabe quem inseriu os dados lá. É preciso tratar todos os inputs como algo potencialmente maléfico (BD, sistema, API, ou qualquer elemento externo).
* Ex.: Campo de comentário que poderia aceitar um código JS malicioso.
* O ORM do Django já possui mecanismos contra SQLInjection
* O Django também já possui mecanismo de proteção contra CSRF


== Forms - Muito além de formulários. ==

* É o responsável pela sanitização dos dados das requisições


== Arquitetura dos Forms ==

Forms
Responsável pelo pipeline de validação  
* processa e valida

Fields
Valida dados da requisição e os converte para tipos Python

Widgets
Expõe os fields e seus dados como controles html, e sabe como obter os dado da requisição para o pipeline.
* gera o controle html e sabe como obter os dados da requisição.




== Form Fields ===
BooleanField 
FloatField
CharField 
ImageField
ChoiceField 
IntegerField
TypedChoiceField 
IPAddressField
DateField 
MultipleChoiceField
DateTimeField 
NullBooleanField
DecimalField 
RegexField
EmailField 
SlugField
FileField 
TimeField
FilePathField 
URLField

== Form Widgets ==
Input 
TimeInput
TextInput 
CheckboxInput
PasswordInput 
Select
HiddenInput 
NullBooleanSelect
MultipleHiddenInput 
SelectMultiple
FileInput 
RadioInput
ClearableFileInput 
RadioFieldRenderer
Textarea 
RadioSelect
DateInput 
CheckboxSelectMultiple
DateTimeInput 
MultiWidget
== Anatomia de um FormField ==

class IntegerField(Field):

    default_error_messages = {
        'invalid': _('Enter a whole number.'),
    }

    def __init__(self, max_value=None, min_value=None, *args, **kwargs):
        self.max_value, self.min_value = max_value, min_value
        kwargs.setdefault('widget', NumberInput if not
                                kwargs.get('localize') else self.widget)
        super(IntegerField, self).__init__(*args, **kwargs)

        if max_value is not None:
            self.validators.append(validators.MaxValueValidator(max_value))
        if min_value is not None:
            self.validators.append(validators.MinValueValidator(min_value))

    def to_python(self, value):
        """
        Validates that int() can be called on the input. Returns the result
        of int(). Returns None for empty values.
        """
        value = super(IntegerField, self).to_python(value)
        if value in self.empty_values:
            return None
        if self.localize:
            value = formats.sanitize_separators(value)
        try:
            value = int(str(value))
        except (ValueError, TypeError):
            raise ValidationError(self.error_messages['invalid'], 
                                    code='invalid')
        return value



* Usar os recursos do framework para simplificar. Nada de fazer validações e conversões.


== Anatomia de um Widget ==

class Textarea(Widget):
    def __init__(self, attrs=None):
        # The 'rows' and 'cols' attributes are required 
        # for HTML correctness.
        default_attrs = {'cols': '40', 'rows': '10'}
        if attrs:
            default_attrs.update(attrs)
        super(Textarea, self).__init__(default_attrs)

    def render(self, name, value, attrs=None):
        if value is None: value = ''
        final_attrs = self.build_attrs(attrs, name=name)
        return format_html('<textarea{0}>\r\n{1}</textarea>',
                            flatatt(final_attrs),
                            force_text(value))

== Dentro do form.is_valid() ==

=> O que acontece quando ocorre a validação do formulário?

1. Se Form for bounded...
2. Form full_clean()
3. Para cada Field é executado:
  3.1. clean() do Field
  3.2. validators do Field
  3.3. método clean_* se existir no Form
4. Form clean()  ⇒ (aqui se faz a validação final)
5. errors (dicionário) ou cleaned_data (dicionário de dados limpos, válidos, etc). 
* O campo estará ou no errors ou no cleaned_data, mas nunca em ambos.

* Todos os dados devem ser validados, não importa se serão persistidos ou não. (Ex.: confirmação de senha). Quem persiste é o Model, não o Form.

====================================================
Bounded SubscriptionForm(request.POST) ou seja, 
com data (dados associados ao form)
vs
Unbounded SubscriptionForm() ou seja, sem data
====================================================

== Initial não é Data ==

* Não é um “bounded form“, é um form com dados iniciais
$ manage shell

>>> from palestrum.subscriptions.forms import SubscriptionForm, Subscription
>>> s = Subscription.objects.get(pk=1)
>>> form = SubscriptionForm(initial={
...     'name': s.name,
...     'cpf': s.cpf,
...     'email': s.email,
...     'phone': s.phone,
... })

>>> form.is_bound
False

>>> form.is_valid()
False





== Dá para evitar que informem o CPF errado? ==

* Por questões didáticas, não será usado o campo CPF do LocalFlavor (https://github.com/django/django-localflavor-br)  / (https://pypi.python.org/pypi/django-localflavor)


== Validators ==

arquivo: palestrum/subscriptions/tests/test_forms.py
# coding: utf-8
...
class SubscriptionFormTest(TestCase):
   ...

   def test_cpf_is_digit(self):
      'CPF must only accept digits.'
      data = dict(name='Antonio Santos', email='antoniosantos@antoniosantos.net',
                  cpf='12345678901', phone='11-96186180')
      data.update({'cpf': 'ABCD5678901'})
      form = SubscriptionForm(data)  # bounded form, com dados
      form.is_valid()

      self.assertItemsEqual(['cpf'], form.errors)



* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_cpf_is_digit
(palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
CPF must only accept digits.
--------------------------------------------------------------
AssertionError: Element counts were not equal:
First has 0, Second has 1:  'cpf'





arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django import forms
from django.utils.translation import ugettext as _
from django.core.exceptions import ValidationError
from palestrum.subscriptions.models import Subscription

def CPFValidator(value):
    if not value.isdigit():
        raise ValidationError(_(u'CPF deve conter apenas números'))

class SubscriptionForm(forms.ModelForm):
    class Meta:
        model = Subscription
        exclude = ('paid',)

    def __init__(self, *args, **kwargs):
        super(SubscriptionForm, self).__init__(*args, **kwargs)

        self.fields['cpf'].validators.append(CPFValidator)

* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)

arquivo: palestrum/subscriptions/tests/test_forms.py
# coding: utf-8
...
class SubscriptionFormTest(TestCase):
    ...

    def test_cpf_has_11_digits(self):
        'CPF must have 11 digits.'
        data = dict(name='Antonio Santos', 
            email='antoniosantos@antoniosantos.net',
            cpf='12345678901', 
            phone='11-96186180')
        data.update({'cpf': '1234'})
        form = SubscriptionForm(data)
        form.is_valid()

        self.assertItemsEqual(['cpf'], form.errors) 
        # deve ter apenas o 'cpf' no dicionário de erros


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_cpf_has_11_digits 
(palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
CPF must have 11 digits.
‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐
AssertionError: Element counts were not equal: 
First has 0, Second has 1: 'cpf'


=> Obs.: O teste deve falhar primeiro, para que depois a implementação seja realizada


arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
...

def CPFValidator(value):
    if not value.isdigit():
        raise ValidationError(_(u'CPF deve conter apenas números'))
    if len(value) != 11:
        raise ValidationError(_(u'CPF deve ter 11 números'))

class SubscriptionForm(forms.ModelForm):
    ...



* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)



== Refatore o Teste ==

== Repetição que gera confusão! ==

...
class SubscriptionFormTest(TestCase):
    ...
    def test_cpf_is_digit(self):
        'CPF must only accept digits.'
        data = dict(name='Antonio Santos', 
            email='antoniosantos@antoniosantos.net',
            cpf='12345678901', 
            phone='11-96186180')
        data.update({'cpf': 'ABCD5678901'})
        form = SubscriptionForm(data)
        form.is_valid()

        self.assertItemsEqual(['cpf'], form.errors)

    def test_cpf_has_11_digits(self):
        'CPF must have 11 digits.'
        data = dict(name='Antonio Santos', 
            email='antoniosantos@antoniosantos.net',
            cpf='12345678901', 
            phone='11-96186180')
        data.update({'cpf': '1234'})
        form = SubscriptionForm(data)
        form.is_valid()

        self.assertItemsEqual(['cpf'], form.errors)


arquivo: palestrum/subscriptions/tests/test_forms.py
...
class SubscriptionFormTest(TestCase):
    ...
    def test_cpf_is_digit(self):
        'CPF must only accept digits.'
        form = self.make_validated_form(cpf='ABCD5678901')
        self.assertItemsEqual(['cpf'], form.errors)

    def test_cpf_has_11_digits(self):
        'CPF must have 11 digits.'
        form = self.make_validated_form(cpf='1234')
        self.assertItemsEqual(['cpf'], form.errors)

    # método auxiliar (sempre deixar no final)
    def make_validated_form(self, **kwargs):
        data = dict(name='Antonio Santos', 
            email='antoniosantos@antoniosantos.net',
            cpf='12345678901', 
            phone='11-96186180')
        data.update(kwargs)
        form = SubscriptionForm(data)
        form.is_valid()
        return form


* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)




== Dá para mudar o requisito? O email pode ser opcional? ==

arquivo: palestrum/subscriptions/tests/test_forms.py
...
class SubscriptionFormTest(TestCase):
    ...
    def test_cpf_has_11_digits(self):
        'CPF must have 11 digits.'
        form = self.make_validated_form(cpf='1234')
        self.assertItemsEqual(['cpf'], form.errors)

    def test_email_is_optional(self):
        'Email is optional.'
        form = self.make_validated_form(email='')
        self.assertFalse(form.errors)

    def make_validated_form(self, **kwargs):
        ...

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_email_is_optional (palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
Email is optional.
-----------------------------------------------------------------------------------
AssertionError: {'email': [u'Este campo \xe9 obrigat\xf3rio.']} is not false



arquivo: palestrum/subscriptions/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _

class Subscription(models.Model):
    name = models.CharField(_('Nome'), max_length=100)
    cpf = models.CharField(_('CPF'), max_length=11, unique=True)
    email = models.EmailField(_('Email'), blank=True)
    phone = models.CharField(_('Telefone'), max_length=20, blank=True)
    created_at = models.DateTimeField(_('Criado em'), auto_now_add=True)
    paid = models.BooleanField(_('Pago'))

    class Meta:
    ...


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_email_unique
(palestrum.subscriptions.tests.test_models.SubscriptionUniqueTest)
Email must be unique
­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐
AssertionError: IntegrityError not raised

arquivo: palestrum/subscriptions/tests/test_models.py
...
class SubscriptionUniqueTest(TestCase):
    def setUp(self):
        # Create a first entry to force the colision
        Subscription.objects.create(name='Antonio Santos',
                                    cpf='012345678901',
                                    email='antoniosantos@antoniosantos.net',
                                    phone='11-96186180')

    def test_cpf_unique(self):
        'CPF must be unique'
        s = Subscription(name='Antonio Santos', cpf='012345678901',
                        email='outro@email.com', phone='11-96186180')
        self.assertRaises(IntegrityError, s.save)

    def test_email_unique(self):
        . . .

    # transforma em erro de regressão
    # (adaptar: está dando erro, quer ajustar para não dar o erro)
    # antes era: teste_email_unique
    # não removeu o teste, apenas modificou o sentido dele
    def test_email_can_repeat(self):
        'Email is not unique anymore'
        s = Subscription.objects.create(name='Antonio Santos',
                                    cpf='109876543210',
                                    email='antoniosantos@antoniosantos.net')
        self.assertEqual(2, s.pk)

* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)

=> agora é necessário criar uma migração para remover a constraint de unicidade

$ manage schemamigration subscriptions -­‐auto

­‐ Deleted unique constraint for ['email'] on subscriptions.Subscription
Created 0003_auto__del_unique_subscription_email.py.
You can now apply this migration with: ./manage.py migrate subscriptions




== Para o deploy no Heroku ==

# Estando em bvad, commite os códigos alterados
$ git add .
$ git commit -m 'Email opcional'

# Faça o push para o Heroku
$ git push heroku master --force

# Atualize o banco de dados
$ heroku run python manage.py syncdb --migrate






== Dá para forçar os nomes a ficarem Capitalizados? ==

arquivo: palestrum/subscriptions/tests/test_forms.py
...
class SubscriptionFormTest(TestCase):
    ...
    def test_email_is_optional(self):
        'Email is optional.'
        form = self.make_validated_form(email='')
        self.assertFalse(form.errors)

    def test_name_must_be_capitalized(self):
        'Name must be capitalized.'
        form = self.make_validated_form(name='ANTONIO santos')
        self.assertEqual('Antonio Santos', form.cleaned_data['name'])

    def make_validated_form(self, **kwargs):
        ...




* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_name_must_be_capitalized (palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
Name must be capitalized.
----------------------------------------------------------------------
AssertionError: 'Antonio Santos' != u'ANTONIO santos'






arquivo: palestrum/subscriptions/forms.py
...
class SubscriptionForm(forms.ModelForm):
    class Meta:
        model = Subscription
        exclude = ('paid',)

    def __init__(self, *args, **kwargs):
        super(SubscriptionForm, self).__init__(*args, **kwargs)

        self.fields['cpf'].validators.append(CPFValidator)

    def clean_name(self):
        name = self.cleaned_data['name']
        words = name.split()
        for index, word in enumerate(words):
            words[index] = word.capitalize()
        capitalized_name = ' '.join(words)
        return capitalized_name


* Como é só para o Form, foi implementado no clean_name do form 
* Quando entra no “clean_name”, já existe uma versão do “cleaned_data”. Então o trabalho será feito já no dado validado.
* ao fazer o return do dado corrigido, o próprio fluxo do form atualizará o “cleaned_data”
* Dica: há uma biblioteca Python para tratamento de nomes



* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)




== Refatore o clean_name ==

arquivo: palestrum/subscriptions/forms.py    # Bônus!
...
class SubscriptionForm(forms.ModelForm):
    class Meta:
        model = Subscription
        exclude = ('paid',)

    def __init__(self, *args, **kwargs):
        super(SubscriptionForm, self).__init__(*args, **kwargs)

        self.fields['cpf'].validators.append(CPFValidator)

    def clean_name(self):
        name = self.cleaned_data['name']
        words = map(lambda w: w.capitalize(), name.split())
        capitalized_name = ' '.join(words)
        return capitalized_name
* usando um lambda



* executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)



== Preciso de ao menos uma forma de contato: email OU telefone  ==

arquivo: arquivo: palestrum/subscriptions/tests/test_forms.py
...
class SubscriptionFormTest(TestCase):
    ...
    def test_email_is_optional(self):
        'Email is optional.'
        form = self.make_validated_form(email='')
        self.assertFalse(form.errors)

    def test_must_inform_email_or_phone(self):
        'Email and Phone are optional, but one must be informed.'
        form = self.make_validated_form(email='', phone='')
        self.assertItemsEqual(['__all__'], form.errors)

    def make_validated_form(self, **kwargs):
    ...
* ‘__all__’ ⇒ todo erro que ocorre no clean do form é anotado neste campo (erro do formulário, não pertence a um campo específico).


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_must_inform_email_or_phone
(palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
Email and Phone are optional, but one must be informed.
-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-
AssertionError: Element counts were not equal:First has 0, Second has 1: '__all__'



arquivo: palestrum/subscriptions/forms.py
...
class SubscriptionForm(forms.ModelForm):
    ...
    def clean_name(self):
        ...

    def clean(self):
        super(SubscriptionForm, self).clean()  

        if not self.cleaned_data['email'] and \
           not self.cleaned_data['phone']:
                raise ValidationError(_(u'Informe seu e-mail ou telefone'))

        return self.cleaned_data
* Tem que retornar o “cleaned_data”. Caso contrário, será substituído por None e todos os dados validados serão perdidos.



** executar o teste
$ manage test palestrum.subscriptions
** Agora passou (Sucesso)



== REFATORAÇÃO ==    # Dica
...
class SubscriptionForm(forms.ModelForm):
    ...
    def clean_name(self):
        ...

    def clean(self):
        super(SubscriptionForm, self).clean()

        if not self.cleaned_data.get('email') and \
           not self.cleaned_data.get('phone'):
                raise ValidationError(_(u'Informe seu e-mail ou telefone'))

        return self.cleaned_data
* Se no POST não vier o ‘email’ ou ‘phone’, e tentarmos obter o elemento pela chave, vai gerar uma falha “KeyError”. Pelo “get”, caso isso ocorra, retorna None.

Navegador: http://127.0.0.1:8000/inscricao/
* Ao fazer a submissão do formulário informando apenas o nome e o cpf: # Cadê o erro?

arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
...
class SubscribeInvalidPostTest(TestCase):
    ...

class TemplateRegressionTest(TestCase):
    def test_template_has_non_field_errors(self):
        'Check if non_field_errors are shown in template.'
        invalid_data = dict(name='Antonio Santos', cpf='12345678901')
        response = self.client.post(r('subscriptions:subscribe'),
                                invalid_data)
        self.assertContains(response, '<ul class="errorlist">')

* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_template_has_non_field_errors
(palestrum.subscriptions.tests.test_views_subscribe.RegressionTest)
Check if non_field_errors are shown in template.
­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐
AssertionError: Couldn't find '<ul class="errorlist">' in response


arquivo: palestrum/subscriptions/templates/subscriptions/subscription_form.html
{% extends 'base.html' %}
{% block content %}
   <form action="." method="POST">
      {% csrf_token %}
      {{ form.non_field_errors }}
      <p>
         <label for="{{ form.name.id_for_label }}">
            {{ form.name.label }}:
         </label>
         {{ form.name }}
         {{ form.name.errors }}
      </p>
      ...


** executar o teste
$ manage test palestrum.subscriptions
* Agora passou (Sucesso)


Navegador: http://127.0.0.1:8000/inscricao/
* Ao fazer a submissão do formulário informando apenas o nome e o cpf: a mensagem solicitando e-mail ou telefone é apresentada






== Tem como separar o DDD do nr. do telefone? ==

Navegador: http://127.0.0.1:8000/inscricao/
* apresentação dos campos DDD e Telefone separados
* O que se quer é apenas um elemento no modelo (no BD é um campo só), mas na apresentação (usabilidade) sejam exibidos dois campos.
* No Form tem apenas um Field, um campo só, mas o Field terá dois Widgets

* Apenas demonstração: não é para alterar nada ainda
<form action="." method="post">
 <div style="display:none">
   <input type="hidden" name="csrfmiddlewaretoken" value="f9fc...">
 </div>
 <p>
   <label for="id_name">Nome:</label>
   <input id="id_name" type="text" name="name" value="" maxlength="100">
 </p>
 <p>
   <label for="id_cpf">CPF:</label>
   <input id="id_cpf" type="text" name="cpf" value="" maxlength="11">
 </p>
 <p> 
   <label for="id_email">Email:</label>
   <input id="id_email" type="text" name="email" value="" maxlength="75">
 </p>
 <p>
   <label for="id_phone_0">Phone:</label>
   <input type="text" name="phone_0" value="" id="id_phone_0">
   <input type="text" name="phone_1" value="" id="id_phone_1">
 </p>
 <input type="submit" value="Enviar!"
 class="button">
</form>




arquivo: palestrum/subscriptions/tests/test_views_subscribe.py
...
class SubscribeTest(TestCase):
    ...
    def test_template(self):
        ...

    def test_html(self):
        'Html must contain input controls.'
        self.assertContains(self.resp, '<form')
        self.assertContains(self.resp, '<input', 7)
        self.assertContains(self.resp, 'type="text"', 4)
        self.assertContains(self.resp, 'type="email"')
        self.assertContains(self.resp, 'type="submit"')






* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_html
(palestrum.subscriptions.tests.test_views_subscribe.SubscribeTest)
Html must contain input controls.
-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐
AssertionError: Found 6 instances of '<input' in response (expected 7)



=>  Criação do Widget
arquivo: palestrum/subscriptions/forms.py
def CPFValidator(value):
    ...
class PhoneWidget(forms.MultiWidget):
    def __init__(self, attrs=None):
        widgets = (
            forms.TextInput(attrs=attrs),
            forms.TextInput(attrs=attrs))
        super(PhoneWidget, self).__init__(widgets, attrs)

    def decompress(self, value):
        if not value:
            return [None, None]
        return value.split('-')

class SubscriptionForm(forms.ModelForm):
    ...

arquivo: palestrum/subscriptions/forms.py
# coding: utf-8
from django.core.validators import EMPTY_VALUES
...
class PhoneField(forms.MultiValueField):
    widget = PhoneWidget

    def __init__(self, *args, **kwargs):
        fields = (forms.IntegerField(),
                forms.IntegerField())
        super(PhoneField, self).__init__(fields, *args, **kwargs)

    def compress(self, data_list):
        if not data_list:
            return ''
        if data_list[0] in EMPTY_VALUES:
            raise forms.ValidationError(_(u'DDD inválido.'))
        if data_list[1] in EMPTY_VALUES:
            raise forms.ValidationError(_(u'Número inválido.'))
        return '%s-%s' % tuple(data_list)

    class SubscriptionForm(forms.ModelForm):
        phone = PhoneField(label=_('Telefone'), required=False)
        ...


* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_email_is_optional
(palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
Email is optional.
---------------------------------------------------------------
AssertionError: {'__all__': [u'Informe seu e-­‐mail ou telefone']} is not false




arquivo: palestrum/subscriptions/tests/test_forms.py
...
class SubscriptionFormTest(TestCase):
    ...

    def make_validated_form(self, **kwargs):
        data = dict(name='Antonio Santos', email='antoniosantos@antoniosantos.net',
                cpf='12345678901', phone_0='11', phone_1='76486182')
        data.update(kwargs)
        form = SubscriptionForm(data)
        form.is_valid()
        return form



* executar os testes pra ver se está tudo em ordem
$ manage test palestrum.subscriptions
* O teste falha 
FAIL: test_must_inform_email_or_phone
(palestrum.subscriptions.tests.test_forms.SubscriptionFormTest)
Email and Phone are optional, but one must be informed.
----------------------------------------------------------------
AssertionError: Element counts were not equal:First has 0, Second has 1: '__all__'



arquivo: palestrum/subscriptions/tests/test_forms.py
...
class SubscriptionFormTest(TestCase):
    ...
    def test_must_inform_email_or_phone(self):
        'Email and Phone are optional, but one must be informed.'
        form = self.make_validated_form(email='', phone_0='', phone_1='')
        self.assertItemsEqual(['__all__'], form.errors)
    ...


** executar o teste
$ manage test palestrum.subscriptions
** Agora passou (Sucesso)


== Para o deploy no Heroku… ==

# Estando em bvad, commite os códigos alterados
$ git add .
$ git commit -m 'Forms features'

# Faça o push para o Heroku
$ git push heroku master --force

# Rode o syncdb e migrações.
$ heroku run python manage.py syncdb --migrate





================================================
Autenticação e Autorização?





== Como divulgo os palestrantes? ==

=> Apresentar página com informações básicas do palestrante (nome e mini-bio).

“Bora implementar?” ⇒ TEST FIRST

=> 1o. teste a ser feito ⇒ Teste de acesso a URL da página

# Estando em bvad, crie o package tests na app core.

# Crie o diretório tests.
$ mkdir palestrum/core/tests

# Transforme o diretório em um package.
$ touch palestrum/core/tests/__init__.py

# Mova os testes atuais para o package.
$ mv palestrum/core/{tests,tests/test_home}.py


# Estando em bvad.

# Crie o módulo para testar a página do palestrante.
$ touch palestrum/core/tests/test_views_speaker_detail.py


arquivo: palestrum/core/tests/test_views_speaker_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class SpeakerDetailTest(TestCase):
    def setUp(self):
        url = r('core:speaker_detail', kwargs={'slug': 'antonio-santos'})
        self.resp = self.client.get(url)

    def test_get(self):
        'GET should result in 200.'
        self.assertEqual(200, self.resp.status_code)
* slug ⇒ texto em formatação específica para construir urls amigáveis. Não possui espaço em branco, se necessário utilizar hífen.

* Importante criar o hábito de criar o teste e fazê-lo falhar. Não apenas criar o teste e já ir direto para a implementação da solução, sem antes ter visto o teste falhar.

** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_get
 (palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
GET should result in 200.
---------------------------------------------------------------------
NoReverseMatch: Reverse for 'speaker_detail' with arguments '()' and keyword
arguments '{'slug': 'antonio-santos'}' not found.


arquivo: palestrum/core/urls.py
# coding: utf-8
from django.conf.urls import patterns, include, url

urlpatterns = patterns('palestrum.core.views',
    url(r'^$', 'home', name='home'),
    url(r'^palestrantes/(?P<slug>[\w-]+)/$', 'speaker_detail',
                                              name='speaker_detail'),
)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_get  
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
GET  should  result  in  200.
------------------------------------------------------------------
ViewDoesNotExist:  Could  not  import  palestrum.core.views.speaker_detail. 
 View does  not  exist  in  module  palestrum.core.views.



arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render
from django.http import HttpResponse

def home(request):
    return render(request, template='index.html')

def speaker_detail(request):
    return HttpResponse()


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_get  
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
GET should result in 200.
-----------------------------------------------------------------
TypeError:  speaker_detail()  got  an  unexpected  keyword  argument  'slug'


arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render
from django.http import HttpResponse

def home(request):
    return render(request, template='index.html')

def speaker_detail(request, slug):
    return HttpResponse()

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




arquivo: palestrum/core/tests/test_views_speaker_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class SpeakerDetailTest(TestCase):
    def setUp(self):
        url = r('core:speaker_detail', kwargs={'slug': 'antonio-santos'})
        self.resp = self.client.get(url)

    def test_get(self):
        'GET should result in 200.'
        self.assertEqual(200, self.resp.status_code)

    def test_template(self):
        'Template should be core/speaker_detail.html'
        self.assertTemplateUsed(self.resp, 'core/speaker_detail.html')


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_template
 (palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
Template should be core/speaker_detail.html
---------------------------------------------------------------------
AssertionError: No templates used to render the response


# Estando em bvad.

# Crie o diretório de templates da app core.
$ mkdir palestrum/core/templates/core

# Crie o templates.
$ touch palestrum/core/templates/core/speaker_detail.html




arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render
from django.http import HttpResponse

def home(request):
    return render(request, template='index.html')

def speaker_detail(request, slug):
    return render(request, 'core/speaker_detail.html')

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


Navegador: Executando o runserver, ao acessar a URL de exibição dos dados do palestrante, nada é exibido. Ex.: http://127.0.0.1:8000/palestrantes/antonio-santos


arquivo: palestrum/core/tests/test_views_speaker_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class SpeakerDetailTest(TestCase):
    . . .

    def test_html(self):
        'Html must contain data.'
        self.assertContains(self.resp, 'Antonio Santos')
        self.assertContains(self.resp, 'Passionate software developer!')
        self.assertContains(self.resp, 'http://antoniosantos.net')



** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
Html must contain data.
-------------------------------------------------------------------
AssertionError: Couldn't find 'Antonio Santos' in response


arquivo: palestrum/core/templates/core/speaker_detail.html
{% extends 'base.html' %}

{% block content %}
    <h4><a href="http://antoniosantos.net">Antonio Santos</a></h4>
    <p>Passionate software developer!</p>
{% endblock content %}

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


Navegador: Ao acessar a URL http://127.0.0.1:8000/palestrantes/antonio-santos/, os dados do palestrantes são exibidos (mas ainda são dados estáticos).


arquivo: palestrum/core/tests/test_views_speaker_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r
from palestrum.core.models import Speaker

class SpeakerDetailTest(TestCase):
    . . .

    def test_context(self):
        'Speaker must be in context.'
        speaker = self.resp.context['speaker']
        self.assertIsInstance(speaker, Speaker)   


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: palestrum.core.tests.test_views_speaker_detail
(unittest.loader.ModuleImportFailure)
---------------------------------------------------------------
ImportError: cannot import name Speaker




arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models

class Speaker(object):
    pass


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_context
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
Speaker must be in context.
-----------------------------------------------------------------
KeyError: 'speaker'

* Quem prepara o contexto é a View

arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render

def home(request):
    return render(request, template='index.html')

def speaker_detail(request, slug):
    context = {'speaker': None}
    return render(request, 'core/speaker_detail.html', context)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_context
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
Speaker must be in context.
-----------------------------------------------------------------
AssertionError: None is not an instance of
 <class 'palestrum.core.models.Speaker'>



arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render
from palestrum.core.models import Speaker

def home(request):
    return render(request, template='index.html')

def speaker_detail(request, slug):
    context = {'speaker': Speaker()}
    return render(request, 'core/speaker_detail.html', context)

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!



== Refatore o Template - Use os dados do contexto ==


arquivo: palestrum/core/templates/core/speaker_detail.html
{% extends 'base.html' %}

{% block content %}
    <h4><a href="{{ speaker.url }}">{{ speaker.name }}</a></h4>
    <p>{{ speaker.description }}</p>
{% endblock content %}




** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
Html must contain data.
------------------------------------------------------------------
AssertionError: Couldn't find 'Antonio Santos' in response



arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models

class Speaker(object):
    name = 'Antonio Santos'
    url = 'http://antoniosantos.net'
    description = 'Passionate software developer!'
* Antes mesmo de ter o Model funcionando, usamos atributos de classe para ver tudo funcionando.


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


== Perfil dos Palestrantes ==================

Name
Slug
Url
Description


# Estando em bvad crie um módulo para testar os models.
$ touch palestrum/core/tests/test_models.py

arquivo: palestrum/core/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Speaker

class SpeakerModelTest(TestCase):
    def setUp(self):
        self.speaker = Speaker(name='Antonio Santos',
                        slug='antonio-santos',
                        url='http://antoniosantos.net',
                        description='Passionate software developer!')
        self.speaker.save()

    def test_create(self):
        'Speaker instance should be saved.'
        self.assertEqual(1, self.speaker.pk)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_create
 (palestrum.core.tests.test_models.SpeakerModelTest)
Speaker instance should be saved.
-------------------------------------------------------------
TypeError: object() takes no parameters


arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _

class Speaker(models.Model):
    name = models.CharField(_('Nome'), max_length=255)
    slug = models.SlugField(_('Slug'))
    url = models.URLField(_('Url'))
    description = models.TextField(_(u'Descrição'), blank=True)

** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html
(palestrum.core.tests.test_views_speaker_detail.SpeakerDetailTest)
Html must contain data.
----------------------------------------------------------------------
AssertionError: Couldn't find 'Antonio Santos' in response


arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render
from palestrum.core.models import Speaker

def home(request):
    return render(request, template='index.html')

def speaker_detail(request, slug):
    speaker = Speaker.objects.get(slug=slug)
    context = {'speaker': speaker}
    return render(request, 'core/speaker_detail.html', context)

arquivo: palestrum/core/tests/test_views_speaker_detail.py
...

class SpeakerDetailTest(TestCase):
    def setUp(self):
        Speaker.objects.create(
            name='Antonio Santos',
            slug='antonio-santos',
            url='http://antonio-santos.net',
            description='Passionate software developer!')

        url = r('core:speaker_detail', kwargs={'slug': 'antonio-santos'})
        self.resp = self.client.get(url)

    def test_get(self):
        'GET should result in 200.'
        self.assertEqual(200, self.resp.status_code)

    ...


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

arquivo: palestrum/core/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Speaker

class SpeakerModelTest(TestCase):
    ...
    def test_unicode(self):
        'Speaker string representation should be the name.'
        self.assertEqual(u'Antonio Santos', unicode(self.speaker))


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_unicode
 (palestrum.core.tests.test_models.SpeakerModelTest)
Speaker string repr should be the name.
---------------------------------------------------------
AssertionError: u'Antonio Santos' != u'Speaker object'
- Antonio Santos
+ Speaker object
arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _

class Speaker(models.Model):
    name = models.CharField(_('Nome'), max_length=255)
    slug = models.SlugField(_('Slug'))
    url = models.URLField(_('Url'))
    description = models.TextField(_(u'Descrição'), blank=True)

    def __unicode__(self):
        return self.name

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


== Regressão para 404 ==

Navegador: Ao acessar a URL http://127.0.0.1:8000/palestrantes/antonio-santos, um erro “DoesNotExist at /palestrantes/antonio-santos/” é exibido. Pois o registro não existe no BD ainda. O macete é fazer com que essa exceção de BD seja transformada em um erro HTTP 404.

arquivo: palestrum/core/tests/test_views_speaker_detail.py
# coding: utf-8
...

class SpeakerDetailTest(TestCase):
    ...

class SpeakerDetailNotFound(TestCase):
    def test_not_found(self):
        url = r('core:speaker_detail', kwargs={'slug': 'john-doe'})
        response = self.client.get(url)
        self.assertEqual(404, response.status_code)



** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_not_found
 (palestrum.core.tests.test_views_speaker_detail.SpeakerDetailNotFound)
---------------------------------------------------------------------
DoesNotExist: Speaker matching query does not exist.
arquivo: palestrum/core/views.py


# coding: utf-8
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from palestrum.core.models import Speaker

def home(request):
    return render(request, 'index.html')

def speaker_detail(request, slug):
    speaker = get_object_or_404(Speaker, slug=slug)
    context = {'speaker': speaker}
    return render(request, 'core/speaker_detail.html', context)


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




== Dá para um palestrante ter vários contatos? ===

1 Speaker tem N Contacts
Contact tem ForeignKey para Speaker


arquivo: palestrum/core/tests/test_models.py
* toda a expectativa está neste teste
* A descrição do teste já diz tudo o que precisamos saber sobre o Modelo
* O teste não está pedindo que algum campo algum campo seja Null=true ou Blank=true
* O desafio do software não é escrever o software direito, é decidir que software não será escrito.
...
class ContactModelTest(TestCase):
    def setUp(self):
        self.speaker = Speaker.objects.create(name='Antonio Santos',
            slug='antonio-santos', url='http://antoniosantos.net',
            description='Passionate software developer!')

    def test_email(self):
        contact = Contact.objects.create(speaker=self.speaker, kind='E',
                                        value='antoniosantos@antoniosantos.net')
        self.assertEqual(1, contact.pk)

    def test_phone(self):
        contact = Contact.objects.create(speaker=self.speaker, kind='P',
                                        value='11-996186180')
        self.assertEqual(1, contact.pk)

    def test_fax(self):
        contact = Contact.objects.create(speaker=self.speaker, kind='F',
                                        value='11-12345678')
        self.assertEqual(1, contact.pk)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_contact_email
 (palestrum.core.tests.test_models.ContactModelTest)
---------------------------------------------------------
NameError: global name 'Contact' is not defined




arquivo: palestrum/core/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Speaker, Contact

class SpeakerModelTest(TestCase):
    ...

class ContactModelTest(TestCase):
    ...


arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _

...

class Contact(models.Model):
    speaker = models.ForeignKey('Speaker', verbose_name=_('palestrante'))
    kind = models.CharField(_('tipo'), max_length=1)
    value = models.CharField(_('valor'), max_length=255)


* (Macete): 'Speaker'(primeiro parâmetro de ForeignKey) é um objeto String. Não é o Modelo para o qual faz referência, não é uma variável, ou name. Neste caso estamos delegando para o Django a responsabilidade de encontrar este modelo. A primeira coisa que o Django faz quando é carregado e validar os modelos, criando um cache e um dicionário destes modelos. Por isso, podemos pedir ao Django que encontre o modelo a partir do nome (chave do dicionário). Não é necessário fazer o import do modelo / poluir o código.
* Evita “acoplamento”



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




arquivo: palestrum/core/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from django.core.exceptions import ValidationError
from palestrum.core.models import Speaker, Contact

...

class ContactModelTest(TestCase):

    ...
    def test_kind(self):
        'Contact kind should be limited to E, P or F.'
        contact = Contact(speaker=self.speaker, kind='A', value='B')
        self.assertRaises(ValidationError, contact.full_clean)

* lembrando: full_clean ⇒ mecanismo de validação de campos. Existe no form e no modelo, mas não é a mesma coisa. Não é recomendável fazer validação do “save”, pois deve ser tratado como um processo de serialização do banco (no “save” podem ser tratado campos dinamicamente estabelecidos, hashes, etc); Neste caso, a validação feita aqui é pra saber se está sendo criada uma instância válida do modelo. Normalmente as validações feitas no model forçam uma exceção, para que não haja quebra de integridade do BD.



** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_kind
 (palestrum.core.tests.test_models.ContactModelTest)
Contact kind should be limited to E, P or F.
-------------------------------------------------------
AssertionError: ValidationError not raised




arquivo: palestrum/core/models.py
...

class Contact(models.Model):
    KINDS = (
        ('P', _('Telefone')),
        ('E', _('E-mail')),
        ('F', _('Fax')),
    )

    speaker = models.ForeignKey('Speaker', verbose_name=_('palestrante'))
    kind = models.CharField(_('tipo'), max_length=1, choices=KINDS)
    value = models.CharField(_('valor'), max_length=255)
* KINDS não é uma constante, pois não há constantes em Python.
* Obs. feita sobre a não necessidade de se criar um “modelo” Kind. É um “choices”, com quantidade limitada de elementos. Isso serviria apenas para impactar negativamente no desempenho da aplicação. Quanto menos JOIN melhor.
* Boa observação sobre “previsibilidade”: Qualquer que seja o problema, a solução será sempre a menor. Quem se prepara para qualquer coisa que possa acontecer, nunca vive o presente e fica perdido no fututo, pois tudo acontecer, até o fato de um cliente que pede tudo e não dá prazo deixar de pagar.



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!



arquivo: palestrum/core/tests/test_models.py
# coding: utf-8
from django.test import TestCase
from django.core.exceptions import ValidationError
from palestrum.core.models import Speaker, Contact

...

class ContactModelTest(TestCase):
    ...

    def test_unicode(self):
        'Contact string representation should be value'
        contact = Contact(speaker=self.speaker, kind='E',
                            value='antoniosantos@antoniosantos.net')
        self.assertEqual(u'antoniosantos@antoniosantos.net', unicode(contact))


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_unicode
 (palestrum.core.tests.test_models.ContactModelTest)
Contact string representation should be value
-----------------------------------------------------
AssertionError: u'antoniosantos@antoniosantos.net' != u'Contact object'
- antoniosantos@antoniosantos.net
+ Contact object


arquivo: palestrum/core/models.py
...

class Contact(models.Model):
    ...

    def __unicode__(self):
        return self.value

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

* E como é a tabela?
$ manage sqlall core

CREATE TABLE "core_speaker" (
    "id" integer NOT NULL PRIMARY KEY,
    "name" varchar(255) NOT NULL,
    "slug" varchar(50) NOT NULL,
    "url" varchar(200) NOT NULL,
    "description" text NOT NULL
);

CREATE TABLE "core_contact" (
    "id" integer NOT NULL PRIMARY KEY,
    "speaker_id" integer NOT NULL REFERENCES "core_speaker" ("id"),
    "kind" varchar(1) NOT NULL,
    "value" varchar(255) NOT NULL
);

CREATE INDEX "core_speaker_56ae2a2a" ON "core_speaker" ("slug");
CREATE INDEX "core_contact_7171bad0" ON "core_contact" ("speaker_id");
* Por ser muito utilizado, um índice já é criado para o slug. Poder semântico do framework.
$ manage sqlall core

CREATE TABLE "core_speaker" (
    "id" integer NOT NULL PRIMARY KEY,
    "name" varchar(255) NOT NULL,
    "slug" varchar(50) NOT NULL,
    "url" varchar(200) NOT NULL,
    "description" text NOT NULL
);

CREATE TABLE "core_contact" (
    "id" integer NOT NULL PRIMARY KEY,
    "speaker_id" integer NOT NULL REFERENCES "core_speaker" ("id"),
    "kind" varchar(1) NOT NULL,
    "value" varchar(255) NOT NULL
);

CREATE INDEX "core_speaker_56ae2a2a" ON "core_speaker" ("slug");
CREATE INDEX "core_contact_7171bad0" ON "core_contact" ("speaker_id");




$ manage sqlall core

CREATE TABLE "core_speaker" (
    "id" integer NOT NULL PRIMARY KEY,
    "name" varchar(255) NOT NULL,
    "slug" varchar(50) NOT NULL,
    "url" varchar(200) NOT NULL,
    "description" text NOT NULL
);

CREATE TABLE "core_contact" (
    "id" integer NOT NULL PRIMARY KEY,
    "speaker_id" integer NOT NULL REFERENCES "core_speaker" ("id"),
    "kind" varchar(1) NOT NULL,
    "value" varchar(255) NOT NULL
);

CREATE INDEX "core_speaker_56ae2a2a" ON "core_speaker" ("slug");
CREATE INDEX "core_contact_7171bad0" ON "core_contact" ("speaker_id");
* Como o contato não é exposto no site, não foram criados view ou form pra ele. Apenas o modelo.
* Será usado apenas no Admin




== Inline Admin ===

Navegador: Ao acessar os dados do speaker pelo Admin (Ex.: URL http://127.0.0.1:8000/admin/core/speaker/1/) - quer-se que sejam apresentados os dados do palestrante, e logo abaixo dos dados básicos do assinante, será aberto um quadro de gestão para os dados de contato.


arquivo: palestrum/core/admin.py
# coding: utf-8
from django.contrib import admin
from palestrum.core.models import Speaker, Contact

class ContactInline(admin.TabularInline):
    model = Contact
    extra = 1

class SpeakerAdmin(admin.ModelAdmin):
    inlines = [ContactInline,]
    prepopulated_fields = {'slug': ('name',)}

admin.site.register(Speaker, SpeakerAdmin)
* extra ⇒ quantas linhas em branco são abertas automaticamente para o usuário digitar.
* prepopulate_fields ⇒ Ex.: Quando se edita o nome do usuário, o slug é modificado automaticamente, em tempo real.


== Migração para app Core ==

$ manage schemamigration core --initial

Creating migrations directory at '/bvad/palestrum/core/migrations'...
Creating __init__.py in '/bvad/palestrum/core/migrations'...
 + Added model core.Speaker
 + Added model core.Contact
Created 0001_initial.py.
You can now apply this migration with: ./manage.py migrate core

$ manage migrate core

Running migrations for core:
 - Migrating forwards to 0001_initial.
 > core:0001_initial
 - Loading initial data for core.
Installed 0 object(s) from 0 fixture(s)


== Para o deploy no Heroku… == 
# Estando em bvad, commite os códigos alterados
$ git add .
$ git commit -m 'Speaker e Contact'

# Faça o push para o Heroku
$ git push heroku master --force

# Atualize o schema do banco
$ heroku run python manage.py syncdb --migrate


== Relacionando Objetos ==

* Dado um Speaker “s”...
$ manage shell

>>> from palestrum.core.models import Speaker, Contact

>>> # Criando um Speaker
>>> s = Speaker(name='Antonio Santos',
...             slug='antonio-santos',
...             url='http://antoniosantos.net')
>>> s.save()

* Adicione Contacts. . . (há 03 formas)
>>> # 1. Criando um Contact informando o Speaker
>>> cp = Contact(speaker=s, kind='P', value='11-996186180')
>>> cp.save()

>>> # 2. Criando um Contact via RelatedManager do Speaker
>>> s.contact_set.create(kind='F', value='11-12345678')
<Contact: 11-12345678>

>>> # 3. Associando um Contact via RelatedManager do Speaker
>>> ce = Contact(kind='E', value='antoniosantos@antoniosantos.net')
>>> s.contact_set.add(ce)
* Contact.objects.filter(speaker=s)   #faz a mesma coisa que...
* s.contact_set.all()

* Como ficou?
>>> s.contact_set.all()
[<Contact: 11-996186180>,
 <Contact: 11-12344321>,
 <Contact: antoniosantos@antoniosantos.net>]

== RelatedManager - outros métodos bacanas ======

create(self, **kwargs)
get_or_create(self, **kwargs)
remove(self, *objs)  # desassocia / desliga a relação, não é um delete
clear()   # desassocia todos os elementos associados

== Managers ==

$ manage shell

>>> from palestrum.core.models import Contact, Speaker

>>> Contact.objects.all()
[<Contact: antoniosantos@antoniosantos.net>,
 <Contact: 11-996186180>,
 <Contact: 11-12345678>]

>>> Contact.objects.filter(kind='E')
[<Contact: antoniosantos@antoniosantos.net>]

>>> Contact.objects.filter(kind='P')
[<Contact: 11-996186180>]

>>> Contact.objects.filter(kind='F')
[<Contact: 11-12345678>]

* Dica - o que se quer é isso
* serão criados CustomManagers (visões dos dados)
$ manage shell

>>> from palestrum.core.models import Contact, Speaker

>>> Contact.objects.all()
[<Contact: antoniosantos@antoniosantos.net>,
 <Contact: 11-996186180>,
 <Contact: 11-12345678>]

>>> Contact.emails.all()
[<Contact: antoniosantos@antoniosantos.net>]

>>> Contact.phones.all()
[<Contact: 11-996186180>]

>>> Contact.faxes.all()
[<Contact: 11-12345678>]






# Estando em bvad, crie um módulo para os testes dos managers.
$ touch palestrum/core/tests/test_managers.py

arquivo: palestrum/core/tests/test_managers.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Contact, Speaker

class ContactManagerTest(TestCase):

    def setUp(self):
        s = Speaker.objects.create(name='Antonio Santos',
            slug='antonio-santos', url='http://antoniosantos.net')

        s.contact_set.add(Contact(kind='E', value='antoniosantos@antoniosantos.net'))

    def test_emails(self):
        qs = Contact.emails.all()
        expected = ['<Contact: antoniosantos@antoniosantos.net>']
        self.assertQuerysetEqual(qs, expected)
* __repr__  ⇒ representation


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_emails
 (palestrum.core.tests.test_models.ContactManagerTest)
--------------------------------------------------------
AttributeError: type object 'Contact' has no attribute 'emails'



# Estando em bvad, crie um módulo para managers.
$ touch palestrum/core/managers.py


arquivo: palestrum/core/managers.py
# coding: utf-8
from django.db import models

class EmailContactManager(models.Manager):
    def get_query_set(self):
        qs = super(EmailContactManager, self).get_query_set()
        qs = qs.filter(kind='E')
        return qs


arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _
from palestrum.core.managers import EmailContactManager

...
class Contact(models.Model):
    KINDS = ...

    speaker = models.ForeignKey('Speaker', verbose_name=_('palestrante'))
    kind = models.CharField(_('tipo'), max_length=1, choices=KINDS)
    value = models.CharField(_('valor'), max_length=255)

    objects = models.Manager()
    emails = EmailContactManager()

    def __unicode__(self):
        return self.value
* por que foi declarado o objects? R: Se na declaração do modelo não for declarado nenhum Manager, o Django cria um Manager padrão. Se no modelo tiver qualquer Manager (ou subclasse), o Django não cria um padrão. É uma boa prática ter o “objects” como sendo o Manager padrão, e criar outros managers necessários.

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




arquivo: palestrum/core/tests/test_managers.py
...
class ContactManagerTest(TestCase):
    def setUp(self):
        s = Speaker.objects.create(name='Antonio Santos',
            slug='antonio-santos', url='http://antoniosantos.net')

        s.contact_set.add(Contact(kind='E', value='antoniosantos@antoniosantos.net'),
             Contact(kind='P', value='11-996186180'),
             Contact(kind='F', value='11-12345678'))

    def test_emails(self):
        ...

    def test_phones(self):
        qs = Contact.phones.all()
        expected = ['<Contact: 11-996186180>']
        self.assertQuerysetEqual(qs, expected)

    def test_faxes(self):
        qs = Contact.faxes.all()
        expected = ['<Contact: 11-12345678>']
        self.assertQuerysetEqual(qs, expected)



** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_faxes
 (palestrum.core.tests.test_managers.ContactManagerTest)
----------------------------------------------------------------------
AttributeError: type object 'Contact' has no attribute 'faxes'
===================================================
ERROR: test_phones
 (palestrum.core.tests.test_managers.ContactManagerTest)
----------------------------------------------------------------------
AttributeError: type object 'Contact' has no attribute 'phones'









arquivo: palestrum/core/managers.py
# coding: utf-8
from django.db import models

class EmailContactManager(models.Manager):
    ...

class PhoneContactManager(models.Manager):
    def get_query_set(self):
        qs = super(PhoneContactManager, self).get_query_set()
        qs = qs.filter(kind='P')
        return qs

class FaxContactManager(models.Manager):
    def get_query_set(self):
        qs = super(FaxContactManager, self).get_query_set()
        qs = qs.filter(kind='F')
        return qs

arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _
from palestrum.core.managers import (EmailContactManager, PhoneContactManager,
                                   FaxContactManager)

...

class Contact(models.Model):
    KINDS = ...

    speaker = models.ForeignKey('Speaker', verbose_name=_('palestrante'))
    kind = models.CharField(_('tipo'), max_length=1, choices=KINDS)
    value = models.CharField(_('valor'), max_length=255)

    objects = models.Manager()
    emails = EmailContactManager()
    phones = PhoneContactManager()
    faxes = FaxContactManager()

    def __unicode__(self):
        return self.value

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


== Refatore os Managers == 
* o código dos Managers ficaram muito repetitivos.

arquivo: palestrum/core/managers.py
# coding: utf-8
from django.db import models

class KindContactManager(models.Manager):
    def __init__(self, kind):
        super(KindContactManager, self).__init__()
        self.kind = kind

    def get_query_set(self):
        qs = super(KindContactManager, self).get_query_set()
        qs = qs.filter(kind=self.kind)
        return qs

arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _
from palestrum.core.managers import KindContactManager

...

class Contact(models.Model):
    KINDS = ...

    speaker = models.ForeignKey('Speaker', verbose_name=_('palestrante'))
    kind = models.CharField(_('tipo'), max_length=1, choices=KINDS)
    value = models.CharField(_('valor'), max_length=255)

    objects = models.Manager()
    emails = KindContactManager('E')
    phones = KindContactManager('P')
    faxes = KindContactManager('F')

    def __unicode__(self):
        return self.value

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

* Os CustomManagers são criados para evitar que a lógica de interação com o BD fiquem esparramadas nas views, criando assim views enormes, e para evitar que elas sejam repetidas/replicadas, tornando as views muito grandes. O ideal é encapsular as queries, criando novas classes de QuerySet e Managers.





== Como divulgo a agenda do evento? ==

Navegador: Ao acessar a URL http://127.0.0.1:8000/palestras/ , a agenda das palestras deverá ser apresentada, contendo: período, horário, título da palestra, nome do palestrante e link para a descrição da palestra


# Estando em bvad crie um módulo para testar a view talk_list
$ touch palestrum/core/tests/test_views_talk_list.py



arquivo: palestrum/core/tests/test_views_talk_list.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class TalkListTest(TestCase):
    def setUp(self):
        self.resp = self.client.get(r('core:talk_list'))

    def test_get(self):
        'GET must result in 200.'
        self.assertEqual(200, self.resp.status_code)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_get 
(palestrum.core.tests.test_views_talk_list.TalkListTest)
GET must result in 200.
---------------------------------------------------------------
NoReverseMatch: Reverse for 'talk_list' with arguments '()' and keyword arguments '{}' not found.



arquivo: palestrum/core/urls.py
# coding: utf-8
from django.conf.urls import patterns, include, url

urlpatterns = patterns('palestrum.core.views',
    url(r'^$', 'home', name='home'),
    url(r'^palestrantes/(?P<slug>[\w-]+)/$', 'speaker_detail', name='speaker_detail'),
    url(r'^palestras/$', 'talk_list', name='talk_list'),
)

arquivo: palestrum/core/views.py
...

def talk_list(request):
    from django.http import HttpResponse  # macete (preguiça), pois é temporário
    return HttpResponse()



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


arquivo: palestrum/core/tests/test_views_talk_list.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class TalkListTest(TestCase):
    ...

    def test_template(self):
        'Template should be core/talk_list.html'
        self.assertTemplateUsed(self.resp, 'core/talk_list.html')



** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_template 
(palestrum.core.tests.test_views_talk_list.TalkListTest)
Template should be core/talk_list.html
---------------------------------------------------------------
AssertionError: No templates used to render the response


# Estando em bvad, crie o template
$ touch palestrum/core/templates/core/talk_list.html


arquivo: palestrum/core/views.py
# coding: utf-8
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from palestrum.core.models import Speaker
...

def talk_list(request):
    return render(request, 'core/talk_list.html')



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


Navegador: Ao acessar a URL http://127.0.0.1:8000/palestras/ , a agenda das palestras deverá ser apresentada por período, contendo: período (manhã e tarde), horário, título da palestra, nome do palestrante e link para a descrição da palestra

arquivo: palestrum/core/tests/test_views_talk_list.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class TalkListTest(TestCase):
    ...

    def test_html(self):
        'Html should list talks.'
        self.assertContains(self.resp, u'Título da palestra', 2)
        self.assertContains(self.resp, u'10:00')
        self.assertContains(self.resp, u'13:00')
        self.assertContains(self.resp, u'/palestras/1/')
        self.assertContains(self.resp, u'/palestras/2/')
        self.assertContains(self.resp, u'/palestrantes/antonio-santos/', 2)
        self.assertContains(self.resp, u'Passionate software developer!', 2)
        self.assertContains(self.resp, u'Antonio Santos', 2)
        self.assertContains(self.resp, u'Descrição da palestra', 2)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html 
(palestrum.core.tests.test_views_talk_list.TalkListTest)
Html should list talks.
---------------------------------------------------------------
AssertionError: Found 0 instances of 'Título da palestra' in
response (expected 2)


arquivo: palestrum/core/templates/core/talk_list.html
{% extends 'base.html' %}

{% block content %}
  <h3>Manhã</h3>
    <div class="palestra">
      <h4><a href="/palestras/1/">10:00 - Título da palestra</a></h4>
      <h5><a href="/palestrantes/antonio-santos/"
            title="Passionate software developer!">
            Antonio Santos
          </a></h5>
          <p>Descrição da palestra</p>
    </div>
  <h3>Tarde</h3>
    <div class="palestra">
      <h4><a href="/palestras/2/">13:00 - Título da palestra</a></h4>
      <h5><a href="/palestrantes/antonio-santos/"
            title="Passionate software developer!">
            Antonio Santos
          </a></h5>
          <p>Descrição da palestra</p>
    </div>
{% endblock content %}


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




# Estando em bvad, crie um módulo de testes para o model Talk
$ touch palestrum/core/tests/test_models_talk.py

arquivo: palestrum/core/tests/test_models_talk.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Talk

class TalkModelTest(TestCase):
    def setUp(self):
        self.talk = Talk.objects.create(
            title=u'Introdução ao Django',
            description=u'Descrição da palestra.',
            start_time='10:00')

    def test_create(self):
        self.assertEqual(1, self.talk.pk)

    def test_unicode(self):
        self.assertEqual(u'Introdução ao Django', unicode(self.talk))


** executar os testes 
$ manage test palestrum.core
** O teste falha 
Traceback (most recent call last):
 ...
 File "/bvad/palestrum/core/tests/test_models_talk.py", line 3, in <module>
     from palestrum.core.models import Talk
ImportError: cannot import name Talk


arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    title = models.CharField(_(u'Título'), max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)

    def __unicode__(self):
        return self.title

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!
* palestras de manhã e a tarde. Critério de corte: pelo horário.

arquivo: palestrum/core/tests/test_views_talk_list.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r

class TalkListTest(TestCase):
    ...

    def test_morning_talks_in_context(self):
        self.assertIn('morning_talks', self.resp.context)

    def test_afternoon_talks_in_context(self):
        self.assertIn('afternoon_talks', self.resp.context)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_afternoon_talks_in_context (palestrum.core.tests.test_views_talk_list.TalkListTest)
---------------------------------------------------------------
AssertionError: 'afternoon_talks' not found in [...]
============================================================
FAIL: test_morning_talks_in_context 
(palestrum.core.tests.test_views_talk_list.TalkListTest)
---------------------------------------------------------------
AssertionError: 'morning_talks' not found in [...]


arquivo: palestrum/core/views.py
# coding: utf-8
from datetime import time
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from palestrum.core.models import Speaker, Talk

...

def talk_list(request):
    midday = time(12)
    context = {
        'morning_talks': Talk.objects.filter(start_time__lt=midday),
        'afternoon_talks': Talk.objects.filter(start_time__gte=midday),
    }
    return render(request, 'core/talk_list.html', context)


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


========================================
1 Talk tem n Speakers?
ou
1 Speaker tem n Talks?
Onde declarar o campo ManyToMany?
========================================
* Depende de como se quer usar o Admin

Navegador: No Admin (URL http://127.0.0.1:8000/admin/core/talk/5/), optou-se cadastrar a Palestra e dentro dela associar o palestrante. Por isso, o ManyToMany foi inserido no model de palestras (Talk)

arquivo: palestrum/core/tests/test_models_talk.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Talk

class TalkModelTest(TestCase):
    ...

    def test_speakers(self):
        'Talk has many Speakers and vice-versa.'
        self.talk.speakers.create(name='Antonio Santos',
                        slug='antonio-santos',
                        url='http://antoniosantos.net')
        self.assertEqual(1, self.talk.speakers.count())


** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_speakers
(palestrum.core.tests.test_models_talk.TalkModelTest)
Talk has many Speakers and vice-versa.
---------------------------------------------------------------
AttributeError: 'Talk' object has no attribute 'speakers'





arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    title = models.CharField(_(u'Título'),max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrantes'))

    def __unicode__(self):
        return self.title



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

* ocorreu modificação no modelo, gerar uma migração
$ manage schemamigration core --auto
 + Added model core.Talk
 + Added M2M table for speakers on core.Talk
Created 0002_auto__add_talk.py. You can now apply this migration with: ./
manage.py migrate core

$ manage syncdb --migrate
Syncing...
Creating tables ...
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)
Migrating...
Running migrations for core:
 - Migrating forwards to 0002_auto__add_talk.
 > core:0002_auto__add_talk
 - Loading initial data for core.
Installed 0 object(s) from 0 fixture(s)











== Como fica no SQL? == 

$ manage sqlall core

CREATE TABLE "core_speaker" (
   "id" integer NOT NULL PRIMARY KEY,
   ...
);

CREATE TABLE "core_talk_speakers" (
   "id" integer NOT NULL PRIMARY KEY,
   "talk_id" integer NOT NULL,
   "speaker_id" integer NOT NULL REFERENCES "core_speaker" ("id"),
   UNIQUE ("talk_id", "speaker_id")
);

CREATE TABLE "core_talk" (
   "id" integer NOT NULL PRIMARY KEY,
   "title" varchar(200) NOT NULL,
   "description" text NOT NULL,
   "start_time" time NOT NULL
);


== Many To Many == 

$ manage shell
>>> from palestrum.core.models import Speaker, Talk

>>> s = Speaker.objects.get(pk=1)
>>> s.talk_set.all()
[<Talk: Empreendendo Comunidades de Sucesso>, ...]

>>> t = s.talk_set.all()[0]
>>> t
<Talk: Empreendendo Comunidades de Sucesso>

>>> t.speakers.all()
[<Speaker: Antonio Santos>]
* um QuerySet só é resolvido quando necessário



== Talk no Admin ==

arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    title = models.CharField(_(u'Título'),max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrantes'))

    class Meta:
        verbose_name = _('palestra')
        verbose_name_plural = _('palestras')

    def __unicode__(self):
        return self.title


arquivo: palestrum/core/admin.py
# coding: utf-8
from django.contrib import admin
from palestrum.core.models import Speaker, Contact, Talk

class ContactInline(admin.TabularInline):
    model = Contact
    extra = 1

class SpeakerAdmin(admin.ModelAdmin):
    inlines = [ContactInline,]
    prepopulated_fields = {'slug': ('name',)}

    admin.site.register(Speaker, SpeakerAdmin)
    admin.site.register(Talk)


Navegador: No Admin (URL http://127.0.0.1:8000/admin/core/talk/5/), a funcionalidade passa a ser apredentada e já está funcionando





== Refatore o Template - Use os dados do contexto ==

O que temos?
{% extends 'base.html' %}

{% block content %}
  <h3>Manhã</h3>
    <div class="palestra">
      <h4><a href="/palestras/1/">10:00 - Título da palestra</a></h4>
      <h5><a href="/palestrantes/antonio-santos/"
             title="Passionate software developer!">
        Antonio Santos
       </a></h5>
       <p>Descrição da palestra</p>
    </div>
  <h3>Tarde</h3>
    <div class="palestra">
      <h4><a href="/palestras/2/">13:00 - Título da palestra</a></h4>
      <h5><a href="/palestrantes/antonio-santos/"
             title="Passionate software developer!">
        Antonio Santos
      </a></h5>
      <p>Descrição da palestra</p>
    </div>
{% endblock content %}




arquivo: palestrum/core/tests/test_views_talk_list.py
...
from palestrum.core.models import Speaker, Talk

class TalkListTest(TestCase):
    def setUp(self):
        s = Speaker.objects.create(name='Antonio Santos', slug='antonio-santos',
            url='http://antoniosantos.net', 
            description='Passionate software developer!')
        t1 = Talk.objects.create(description=u'Descrição da palestra',
            title=u'Título da palestra', start_time='10:00')
        t2 = Talk.objects.create(description=u'Descrição da palestra',
            title=u'Título da palestra', start_time='13:00')
        t1.speakers.add(s)
        t2.speakers.add(s)
        self.resp = self.client.get(r('core:talk_list'))

...

def test_html(self):
    self.assertContains(self.resp, u'Título da palestra', 2)
    self.assertContains(self.resp, u'10:00')
    self.assertContains(self.resp, u'13:00')
    self.assertContains(self.resp, u'/palestras/1/')
    self.assertContains(self.resp, u'/palestras/2/')
    self.assertContains(self.resp, u'/palestrantes/antonio-santos', 2)
    self.assertContains(self.resp, u'Passionate software developer!', 2)
    self.assertContains(self.resp, u'Antonio Santos', 2)
    self.assertContains(self.resp, u'Descrição da palestra', 2)


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!
arquivo: palestrum/core/templates/core/talk_list.html
{% extends 'base.html' %}

{% block content %}
  <h3>Manhã</h3>
  {% for talk in morning_talks %}
    {% include 'core/talk_list_snippet.html' %}
  {% empty %}
    <p>Não existem palestras durante a manhã.</p>
  {% endfor %}

  <h3>Tarde</h3>
  {% for talk in afternoon_talks %}
    {% include 'core/talk_list_snippet.html' %}
  {% empty %}
    <p>Não existem palestras durante a tarde.</p>
  {% endfor %}
{% endblock content %}
* polêmica: uso do include
O uso do include é recomendável apenas com um Snipet.
Include que aparece em “30 lugares” não é bacana. Reduzir ao máximo o uso do include. Dar preferência ao extensão de template.
Como neste caso trata-se de um bloco de código que se repete em dois lugares do mesmo arquivo, deu-se a preferência de usar o include.






* Extração dos dois blocos repetitivos para um snippet.

# Estando em bvad, crie o template do snippet
$ touch palestrum/core/templates/core/talk_list_snippet.html


arquivo: palestrum/core/templates/core/talk_list_snippet.html
<div class="palestra">
  <h4>
    <a href="{{ talk.get_absolute_url }}">
      {{ talk.start_time }} - {{ talk.title }}
    </a>
  </h4>
  {% for speaker in talk.speakers.all %}
    <h5>
      <a href="{{ speaker.get_absolute_url }}"
            title="{{ speaker.description|truncatewords:30 }}">
        {{ speaker.name }}
      </a>
    </h5>
  {% endfor %}
  <p>{{ talk.description }}</p>
</div>


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html (palestrum.core.tests.test_views_talk_list.TalkListTest)
Html should list talks.
---------------------------------------------------------------
AssertionError: Found 0 instances of '/palestras/1/' in response (expected 1)



arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    title = models.CharField(_(u'Título'),max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrantes'))

    class Meta:
        verbose_name = _('palestra')
        verbose_name_plural = _('palestras')

    def __unicode__(self):
        return self.title

    def get_absolute_url(self):
        # TODO: Use reverse.
        return '/palestras/%d/' % self.pk
* Por que não usou o reverse? R: Ainda não existe a tela que apresenta o detalhe da palestra. 
* Mas não poderia ter implementado a tela antes? R: Depende do cliente, do que ele precisa (listagem ou o detalhe).
* Resumindo: Está sendo utilizada a interpolação ao invés do reverse, pois ainda não existe uma rota criada para isso.
* Outro motivo para se evitar includes: o include precisa das variáveis de contexto. Se o include for usado em vários lugares, alguém tem que fornecer as variáveis de contexto para que ele possa ser renderizado de forma correta.

* TDD não é uma sequência de passos. TDD é uma estratégia/técnica de programação, em que só se programa o que deve ser programado. Não cair no purismo (fazer o que não precisa só porque deveria ser testado antes).


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html (palestrum.core.tests.test_views_talk_list.TalkListTest)
Html should list talks.
---------------------------------------------------------------
AssertionError: Found 0 instances of '/palestrantes/antonio-santos/' in response (expected 2)




arquivo: palestrum/core/models.py
...

class Speaker(models.Model):
    name = models.CharField(_('Nome'), max_length=255)
    slug = models.SlugField(_('Slug'))
    url = models.URLField(_('Url'))
    description = models.TextField(_(u'Descrição'), blank=True)

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('core:speaker_detail', (), {'slug': self.slug})
* @models.permalink ⇒ decorator

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




== Custom Default Manager - Encampsulando a macarronada da view. == 

O que temos?
# coding: utf-8
from datetime import time
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from palestrum.core.models import Speaker, Talk

...

def talk_list(request):
    midday = time(12)
    context = {
        'morning_talks': Talk.objects.filter(start_time__lt=midday),
        'afternoon_talks': Talk.objects.filter(start_time__gte=midday),
    }
    return render(request, 'core/talk_list.html', context)
* A “regra” para decidir a quebra de períodos (manhã/tarde) não deveria ser tratada na View. Deveria estar no manager.
* Transferir então para o Manager (custom manager → PeriodManager)

arquivo: palestrum/core/tests/test_models_talk.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Talk
from palestrum.core.managers import PeriodManager

class TalkModelTest(TestCase):
    ...

    def test_period_manager(self):
        'Talk default manager must be instance of PeriodManager.'
        self.assertIsInstance(Talk.objects, PeriodManager)



** executar os testes 
$ manage test palestrum.core
** O teste falha 
Traceback (most recent call last):
 ...
 File "/bvad/palestrum/core/tests/test_models_talk.py", line 4, in <module>
 from palestrum.core.managers import PeriodManager
ImportError: cannot import name PeriodManager


arquivo: palestrum/core/managers.py
# coding: utf-8
from django.db import models

class KindContactManager(models.Manager):
    ...

class PeriodManager(models.Manager):
    pass

** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_period_manager (palestrum.core.tests.test_models_talk.TalkModelTest)
Talk default manager must be instance of PeriodManager.
---------------------------------------------------------------
AssertionError: <django.db.models.manager.Manager object at 0x101ef9d10> is not an instance of <class 'palestrum.core.managers.PeriodManager'>


arquivo: palestrum/core/models.py
# coding: utf-8
from django.db import models
from django.utils.translation import ugettext_lazy as _
from palestrum.core.managers import KindContactManager, PeriodManager

...

class Talk(models.Model):
    title = models.CharField(_(u'Título'),max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrantes'))

    objects = PeriodManager()

    class Meta:
        verbose_name = _('palestra')
        verbose_name_plural = _('palestras')

    ...

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

arquivo: palestrum/core/tests/test_managers.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Contact, Speaker, Talk

...

class PeriodManagerTest(TestCase):
    def setUp(self):
        Talk.objects.create(title='Morning Talk', start_time='10:00')
        Talk.objects.create(title='Afternoon Talk', start_time='12:00')

    def test_morning(self):
        'Should return only talks before 12:00.'
        self.assertQuerysetEqual(
            Talk.objects.at_morning(), ['Morning Talk'],
                lambda t: t.title)

    def test_afternoon(self):
        'Should return only talks after 11:59:59.'
        self.assertQuerysetEqual(
            Talk.objects.at_afternoon(), ['Afternoon Talk'],
                lambda t: t.title)



** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_afternoon 
(palestrum.core.tests.test_managers.PeriodManagerTest)
Should return only talks after 11:59:59.
---------------------------------------------------------------
AttributeError: 'PeriodManager' object has no attribute 'at_afternoon'
==========================================================
ERROR: test_morning (palestrum.core.tests.test_managers.PeriodManagerTest)
Should return only talks before 12:00.
---------------------------------------------------------------
AttributeError: 'PeriodManager' object has no attribute 'at_morning'




arquivo: palestrum/core/managers.py
# coding: utf-8
from datetime import time
from django.db import models

...

class PeriodManager(models.Manager):

    midday = time(12)

    def at_morning(self):
        qs = self.filter(start_time__lt=self.midday)
        qs = qs.order_by('start_time')
        return qs

    def at_afternoon(self):
        qs = self.filter(start_time__gte=self.midday)
        qs = qs.order_by('start_time')
        return qs


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!



== Refatore a view talk_list - Use os métodos do PeriodManager ==

arquivo: palestrum/core/views.py
# coding: utf-8
from datetime import time
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from palestrum.core.models import Speaker, Talk

...

def talk_list(request):
    midday = time(12)
    context = {
        'morning_talks': Talk.objects.at_morning(),
        'afternoon_talks': Talk.objects.at_afternoon(),
    }
    return render(request, 'core/talk_list.html', context)



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!



== Para o deploy no Heroku… ==

# Estando em bvad, commite os códigos alterados
$ git add .
$ git commit -m 'Talk'

# Faça o push para o Heroku
$ git push heroku master --force

# Atualize o schema do banco
$ heroku run python manage.py syncdb --migrate



*********************************

== E os mini-cursos? ==
* Um minicuro é basicamente uma palestra com a quantidade de vagas limitadas

Herança de Modelos - Qual usar?
Abstract Base Class
Multi-Table Inheritance
Proxy

Atividades do palestrum
Talk
Title
Start Time
Description
Course
Title
Description
Start Time
Slots
Notes

arquivo (expectativas): palestrum/core/tests/test_models_talk.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Talk, Course
from palestrum.core.managers import PeriodManager
...

class CourseModelTest(TestCase):
    def setUp(self):
        self.course = Course.objects.create(title=u'Tutorial Django',
            description=u'Descrição do curso.', start_time='10:00', slots=20)

    def test_create(self):
        self.assertEqual(1, self.course.pk)

    def test_unicode(self):
        self.assertEqual(u'Tutorial Django', unicode(self.course))

    def test_speakers(self):
        'Course has many Speakers and vice-versa.'
        self.course.speakers.create(name='Antonio Santos',
            slug='antonio-santos', url='http://antoniosantos.net')
        self.assertEqual(1, self.course.speakers.count())

    def test_period_manager(self):
        'Course default manager must be instance of PeriodManager.'
        self.assertIsInstance(Course.objects, PeriodManager)


** executar os testes 
$ manage test palestrum.core
** O teste falha 
Traceback (most recent call last):
 ...
 File "/bvad/palestrum/core/tests/test_models_talk.py", line 3, in <module>
 from palestrum.core.models import Talk, Course
ImportError: cannot import name Course



== Abstract Base Class == 
* um experimento
* é um template de modelo
* é um modelo que não tem tabela no banco de dados.Somente a herança é que criará uma tabela no bd.

arquivo: palestrum/core/models.py
...
class Activity(models.Model):
    title = models.CharField(max_length=200)
    description = models.TextField()
    start_time = models.TimeField(blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrante'))

    objects = PeriodManager()

    class Meta:
        abstract = True
        verbose_name = _('palestra')
        verbose_name_plural = _('palestras')

    def __unicode__(self):
        return self.title

    def get_absolute_url(self):
        return '/palestras/%d/' % self.pk




arquivo: palestrum/core/models.py
...

class Talk(Activity):
    pass

class Course(Activity):
    slots = models.IntegerField(_('vagas'))
    notes = models.TextField(_(u'observações'))
* Activity é um modelo abstrato
* Talk e Course são modelos concretos



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


$ manage sqlall core

CREATE TABLE "core_talk" (
   "id" integer NOT NULL PRIMARY KEY,
   "title" varchar(200) NOT NULL,
   "description" text NOT NULL,
   "start_time" time NOT NULL
);

CREATE TABLE "core_course" (
   "id" integer NOT NULL PRIMARY KEY,
   "title" varchar(200) NOT NULL,
   "description" text NOT NULL,
   "start_time" time NOT NULL,
   "slots" integer NOT NULL,
   "notes" text NOT NULL
)
* são duas tabelas que possuem colunas que se repetem, mas uma não têm nenhuma relação com a outra. 




== Abstract não serve para o que queremos. - Volte atrás! ==

== Multi-Table Inheritance (MTI) ==
* quando um modelo concreto herda de um modelo concreto

arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    title = models.CharField(_(u'Título'),max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrantes'))

    objects = PeriodManager()

    class Meta:
        verbose_name = _('palestra')
        verbose_name_plural = _('palestras')
    ...

class Course(Talk):
    slots = models.IntegerField(_('vagas'))
    notes = models.TextField(_(u'observações'))


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_period_manager 
(palestrum.core.tests.test_models_talk.CourseModelTest)
Course default manager must be instance of PeriodManager.
---------------------------------------------------------------
AssertionError: <django.db.models.manager.Manager object at 0x101f02390> is not an instance of <class 'palestrum.core.managers.PeriodManager'>



arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    title = models.CharField(_(u'Título'),max_length=200)
    description = models.TextField(_(u'Descrição'))
    start_time = models.TimeField(_(u'Horário'), blank=True)
    speakers = models.ManyToManyField('Speaker', verbose_name=_('palestrantes'))

    objects = PeriodManager()

    class Meta:
        verbose_name = _('palestra')
        verbose_name_plural = _('palestras')
    ...

class Course(Talk):
    slots = models.IntegerField(_('vagas'))
    notes = models.TextField(_(u'observações'))

    objects = PeriodManager()
* Course herda Talk

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!



== Multi-Table Inheritance ==

$ manage sqlall core

CREATE TABLE "core_talk" (
   "id" integer NOT NULL PRIMARY KEY,
   "title" varchar(200) NOT NULL,
   "description" text NOT NULL,
   "start_time" time NOT NULL
);

CREATE TABLE "core_course" (
   "talk_ptr_id" integer NOT NULL PRIMARY KEY REFERENCES "core_talk" ("id"),
   "slots" integer NOT NULL,
   "notes" text NOT NULL
);

$ manage sqlall core

CREATE TABLE "core_talk" (
   "id" integer NOT NULL PRIMARY KEY,
   "title" varchar(200) NOT NULL,
   "description" text NOT NULL,
   "start_time" time NOT NULL
);

CREATE TABLE "core_course" (
   "talk_ptr_id" integer NOT NULL PRIMARY KEY REFERENCES "core_talk" ("id"),
   "slots" integer NOT NULL,
   "notes" text NOT NULL
);

== Multi-Table Inheritance ==

>>> # Cria um Talk
>>> Talk.objects.create(title='A Talk', start_time='15:00')
<Talk: A Talk>

>>> # Cria um Course
>>> Course.objects.create(title='Some Course', start_time='09:00', slots=20)
<Course: Some Course>

>>> # Lista todos os Talks
>>> Talk.objects.all()
[<Talk: A Talk>, <Talk: Some Course>]

>>> # Lista todos os Courses
>>> Course.objects.all()
[<Course: Some Course>]
== Proxy Inheritance == 
* outra alternativa, pouco usada pelos desenvolvedores por desconhecimento.
* quando se quer fazer a herança de um modelo concreto, mudando apenas o comportamento Python dele (“um Model virtual”)

Proxy Inheritance - Exemplo
class CodingCourse(Course):
    class Meta:
        proxy = True

    def do_some_python_stuff(self):
        return "Let's hack! at %s" % self.title
* Perceber que CodingCourse não tem campos adicionais (não mexe no modelo concreto, apenas herda), mas implementa métodos diferentes. No nível do Python ela tem um comportamento diferente. É uma classe que herda do Model concreto e marcada como Proxy. Nenhuma tabela é criada para esta classe, usa a tabela do modelo concreto.
É uma forma de adicionar métodos Python que não estarão presentes no Model “pai”.


Proxy Inheritance
>>> type(Course.objects)
<class 'core.models.PeriodManager'>

>>> type(CodingCourse.objects)
<class 'core.models.PeriodManager'>


== Migração para Talk ==

$ manage schemamigration core --auto

 + Added model core.Course
Created 0003_auto__add_course.py.
You can now apply this migration with: ./manage.py migrate core

$ manage migrate core

Running migrations for core:
 - Migrating forwards to 0003_auto__add_course.
 > core:0003_auto__add_course
 - Loading initial data for core.
Installed 0 object(s) from 0 fixture(s)



== Para o deploy no Heroku… == 

# Estando em bvad, commite os códigos alterados
$ git add .
$ git commit -m 'Course'

# Faça o push para o Heroku
$ git push heroku master --force

# Atualize o schema do banco
$ heroku run python manage.py syncdb --migrate


== One to One == 

Exemplo: User e Profile

class User(models.Model)
    login = models.CharField()
    senha = models.CharField()

class Profile(models.Model)
    user = models.OneToOneField(‘User’)
    idade = modes.IntegerField()







== Cada palestra poderia ter uma tela para mostrar slides e videos? ==


Navegador: Ao acessar o site (Ex.: URL http://127.0.0.1:8000/palestra/2/), os detalhes da palestra deverão ser apresentado, contendo: título da palestra, descrição, vídeo, etc.


# Estando em bvad, crie um módulo para testar a view talk_detail.
$ touch palestrum/core/tests/test_views_talk_detail.py



arquivo: palestrum/core/tests/test_views_talk_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r
from palestrum.core.models import Talk

class TalkDetailTest(TestCase):
    def setUp(self):
        t = Talk.objects.create(title='Talk', start_time='10:00')
        t.speakers.create(name='Antonio Santos', slug='antonio-santos')
        self.resp = self.client.get(r('core:talk_detail', args=[1]))

    def test_get(self):
        self.assertEqual(200, self.resp.status_code)

    def test_template(self):
        self.assertTemplateUsed(self.resp, 'core/talk_detail.html')

    def test_talk_in_context(self):
        talk = self.resp.context['talk']
        self.assertIsInstance(talk, Talk)

    def test_not_found(self):
        response = self.client.get(r('core:talk_detail', args=[0]))
        self.assertEqual(404, response.status_code)



** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_get (palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
NoReverseMatch: Reverse for 'talk_detail' with arguments '(1,)' and keyword arguments '{}' not found.
===============================================================
ERROR: test_not_found (palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
NoReverseMatch: Reverse for 'talk_detail' with arguments '(1,)' and keyword arguments '{}' not found.
===============================================================
ERROR: test_talk_in_context (palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
NoReverseMatch: Reverse for 'talk_detail' with arguments '(1,)' and keyword arguments '{}' not found.
===============================================================
ERROR: test_template (palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
NoReverseMatch: Reverse for 'talk_detail' with arguments '(1,)' and keyword arguments '{}' not found.

arquivo: palestrum/core/urls.py
# coding: utf-8
from django.conf.urls import patterns, include, url

urlpatterns = patterns('palestrum.core.views',
    url(r'^$', 'home', name='home'),
    url(r'^palestrantes/(?P<slug>[\w-]+)/$', 'speaker_detail', name='speaker_detail'),
    url(r'^palestras/$', 'talk_list', name='talk_list'),
    url(r'^palestras/(?P<pk>\d+)/$', 'talk_detail', name='talk_detail'),
)

arquivo: palestrum/core/views.py
...

def talk_detail(request, pk):
    talk = get_object_or_404(Talk, pk=pk)
    context = {
        'talk': talk,
    }
    return render(request, 'core/talk_detail.html', context)



# Estando em bvad, crie o template do detalhe da talk
$ touch palestrum/core/templates/core/talk_detail.html



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!



== Refatore Talk.get_absolute_url - Use o reverse! ==

O que temos?

class Talk(models.Model):
    ...

    def get_absolute_url(self):
        # TODO: Use reverse.
        return '/palestras/%d/' % self.pk



arquivo: palestrum/core/models.py
class Talk(models.Model):
    ...

    @models.permalink
    def get_absolute_url(self):
        return ('core:talk_detail', (), {'pk': self.pk})




arquivo: palestrum/core/tests/test_views_talk_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r
from palestrum.core.models import Talk

class TalkDetailTest(TestCase):
    ...

    def test_html(self):
        self.assertContains(self.resp, 'Talk')
        self.assertContains(self.resp, '/palestrantes/antonio-santos/')
        self.assertContains(self.resp, 'Antonio Santos')


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_html 
(palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
AssertionError: Couldn't find 'Talk' in response



arquivo: palestrum/core/templates/core/talk_detail.html
{% extends 'base.html' %}

{% block content %}
  <h4>{{talk.title }}</h4>
  {% for speaker in talk.speakers.all %}
    <h5>
      <a href="{{ speaker.get_absolute_url }}"
         title="{{ speaker.description|truncatewords:20 }}">  
         {{ speaker.name }}
      </a>
    </h5>
  {% endfor %}
  <p>{{ talk.description }}</p>
{% endblock content %}


** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!


# Estando em bvad, crie um módulo para testar o model Media
$ touch palestrum/core/tests/test_models_media.py


arquivo: palestrum/core/tests/test_models_media.py
# coding: utf-8
from django.test import TestCase
from palestrum.core.models import Talk, Media

class MediaModelTest(TestCase):
    def setUp(self):
        t = Talk.objects.create(title='Talk', start_time='10:00')
        self.media = Media.objects.create(talk=t, kind='YT',
            media_id='QjA5faZF1A8', title='Video')

    def test_create(self):
        self.assertEqual(1, self.media.pk)

    def test_unicode(self):
        self.assertEqual('Talk - Video', unicode(self.media))



** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_create (palestrum.core.tests.test_models_media.MediaModelTest)
---------------------------------------------------------------
AttributeError: 'Talk' object has no attribute 'media_set'
===============================================================
ERROR: test_unicode (palestrum.core.tests.test_models_media.MediaModelTest)
---------------------------------------------------------------
AttributeError: 'Talk' object has no attribute 'media_set'



arquivo: palestrum/core/models.py
...
class Media(models.Model):
    MEDIAS = (
        ('YT', _('YouTube')),
        ('SL', _('SlideShare')),
    )

    talk = models.ForeignKey('Talk', verbose_name=_('palestra'))
    kind = models.CharField(_('tipo'), max_length=2, choices=MEDIAS)
    title = models.CharField(_(u'título'), max_length=255)
    media_id = models.CharField(_('ref'), max_length=255)

    def __unicode__(self):
        return u'%s - %s' % (self.talk.title, self.title)
* Por que o __unicode__ foi implementado desta forma? Apenas para chamar a atenção: supondo que uma querie obteve apenas o Media, ao fazer a chamada do método __unicode__, se não tiver o Talk (pois só encontrou o Media) o Django resolve isso e faz a consulta no banco através da FK, dinamicamente.
* Dica: usar o Django Debug Toolbar, fazendo um log de quais queries foram executadas na view oara evitar queries ocultas.
* No caso apresentado, a solução seria indicar que para qualquer querie do Media deve trazer o Talk como select related. Todas as vezes que fizer uma query no Media, já traz o Talk como join. Daí seria apenas uma query.



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!





arquivo: palestrum/core/tests/test_views_talk_detail.py
# coding: utf-8
from django.test import TestCase
from django.core.urlresolvers import reverse as r
from palestrum.core.models import Talk

class TalkDetailTest(TestCase):
    ...

    def test_videos_in_context(self):
        self.assertIn('videos', self.resp.context)

    def test_slides_in_context(self):
        self.assertIn('slides', self.resp.context)
* insere no contexto


** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_slides_in_context 
(palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
AssertionError: 'slides' not found in [...]
===============================================================
FAIL: test_videos_in_context 
(palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
AssertionError: 'videos' not found in [...]

arquivo: palestrum/core/views.py
...

def talk_detail(request, pk):
    talk = get_object_or_404(Talk, pk=pk)
    context = {
        'talk': talk,
        'slides': talk.media_set.filter(kind='SL'),
        'videos': talk.media_set.filter(kind='YT'),
    }
    return render(request, 'core/talk_detail.html', context)

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

* criar template tag
* Muito raro ser criado. Criar TT além dos que o Django já oferece, traz uma certa preocupação.
# Estando em bvad, crie o package templatetags na app core.
$ mkdir -p palestrum/core/templatetags
$ touch palestrum/core/templatetags/__init__.py

# Estando em bvad, crie um módulo para testar o templatetag.
$ touch palestrum/core/tests/test_templatetags.py



arquivo: palestrum/core/tests/test_templatetags.py
# coding: utf-8
from django.test import TestCase
from django.template import Template, Context

class YoutubeTagTest(TestCase):
    def setUp(self):
        context = Context({'ID': 1})
        template = Template('{% load youtube %}{% youtube ID %}')
        self.content = template.render(context)

    def test_output(self):
        self.assertIn('<object', self.content)
        self.assertIn('/1', self.content)




** executar os testes 
$ manage test palestrum.core
** O teste falha 
ERROR: test_tag (palestrum.core.tests.test_templatetags.YoutubeTagTest)
---------------------------------------------------------------
TemplateSyntaxError: Invalid block tag: 'youtube'





arquivo: palestrum/core/templatetags/youtube.py
# coding: utf-8
from django.template import (Context, Template, Node, TemplateSyntaxError,
                             Variable, VariableDoesNotExist, Library)

TEMPLATE = """
<object width="480" height="385">
    <param name="movie" value="http://www.youtube.com/v/{{ id }}" />
    <param name="allowFullScreen" value="true" />
    <param name="allowscriptaccess" value="always" />
    <embed src="http://www.youtube.com/v/{{ id }}"
        type="application/x-shockwave-flash" allowscriptaccess="always"
        allowfullscreen="true" width="480" height="385">
    </embed>
</object>
"""

def do_youtube(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, id_ = token.split_contents()
    except ValueError:
        raise TemplateSyntaxError, "%r tag requires 1 argument" % \
            token.contents.split()[0]
    return YoutubeNode(id_)

class YoutubeNode(Node):
    def __init__(self, id_):
        self.id = Variable(id_)

    def render(self, context):
        try:
            actual_id = self.id.resolve(context)
        except VariableDoesNotExist:
            actual_id = self.id

        t = Template(TEMPLATE)
        c = Context({'id': actual_id}, autoescape=context.autoescape)
        return t.render(c)

register = Library()
register.tag('youtube', do_youtube)
* Os dois momentos do template do Django: O momento de Parsing e o momento de Rendering
Parsing ⇒ quando se faz o load do template e faz o parse para um objeto Template. Não é uma string, é um objeto de alto nível que possui uma árvore de nós (todos os nós do template).
Rendering ⇒ ocorre quando é feita uma chamada ao render, passando um contexto. Neste momento,  a árvore de nós do template é percorrida, e o método render de cada nó é chamado.
No Template Tag funciona do mesmo jeito (Parsing e Rendering).

* Regra: No render, nunca disparar uma exceção. Caso ocorra algum problema, devolve uma string vazia.
* O Template do Django não é uma mera substituição de string. É uma linguagem de template (um compilador).

** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!

⇒ slideshare.py
https://gist.github.com/2944274

from django import template
from django.template import Context, Template, Node
 
 
TEMPLATE = """
<object id="__sse{{ id }}" width="425" height="355">
  <param name="movie"
    value="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc={{ doc }}" />
  <param name="allowFullScreen" value="true"/>
  <param name="allowScriptAccess" value="always"/>
  <embed name="__sse{{ id }}"
    src="http://static.slidesharecdn.com/swf/ssplayer2.swf?doc={{ doc }}"
    type="application/x-shockwave-flash"
    allowscriptaccess="always"
    allowfullscreen="true"
    width="425"
    height="355">
  </embed>
</object>
"""
 
def do_slideshare(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, id_, doc = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError, "%r tag requires 2 arguments" % token.contents.split()[0]
    return SlideShareNode(id_, doc)




⇒ slideshare.py (continua)
https://gist.github.com/2944274
class SlideShareNode(Node):
    def __init__(self, id_, doc):
        self.id = template.Variable(id_)
        self.doc = template.Variable(doc)
 
    def render(self, context):
        try:
            actual_id = self.id.resolve(context)
        except template.VariableDoesNotExist:
            actual_id = self.id
 
        try:
            actual_doc = self.doc.resolve(context)
        except template.VariableDoesNotExist:
            actual_doc = self.doc
 
        t = Template(TEMPLATE)
        c = Context({'id': actual_id, 'doc': actual_doc}, autoescape=context.autoescape)
        return t.render(c)
 
 
register = template.Library()
register.tag('slideshare', do_slideshare)

arquivo: palestrum/core/templates/core/talk_detail.html
{% extends 'base.html' %}
{% load youtube slideshare %}

{% block content %}
  <h4>{{talk.title }}</h4>
  {% for speaker in talk.speakers.all %}
    <h5>
      <a href="{{ speaker.get_absolute_url }}"
        title="{{ speaker.description|truncatewords:20 }}">
        {{ speaker.name }}
      </a>
    </h5>
  {% endfor %}
  <p>{{ talk.description }}</p>
  {% for video in videos %}
    <p>{% youtube video.media_id %}</p>
  {% endfor %}
  {% for slide in slides %}
    <p>{% slideshare slide.media_id slide.title %}</p>
  {% endfor %}
{% endblock content %}

Navegador: Ao acessar a URL http://127.0.0.1:8000/palestra/2/ , os detalhes da palestra são apresentados, agora com o vídeo/slideshare.




== Refatore a view talk_detail - Encapsule videos e slides no model ==

O que temos?

...

def talk_detail(request, pk):
    talk = get_object_or_404(Talk, pk=pk)
    context = {
        'talk': talk,
        'slides': talk.media_set.filter(kind='SL'),
        'videos': talk.media_set.filter(kind='YT'),
    }
    return render(request, 'core/talk_detail.html', context)

arquivo:palestrum/core/views.py
...

def talk_detail(request, pk):
    talk = get_object_or_404(Talk, pk=pk)
    context = {
        'talk': talk,
        'slides': talk.media_set.filter(kind='SL'),
        'videos': talk.media_set.filter(kind='YT'),
    }
    return render(request, 'core/talk_detail.html', context)

arquivo: palestrum/core/models.py
...

class Talk(models.Model):
    ...

    @property
    def slides(self):
        return self.media_set.filter(kind='SL')

    @property
    def videos(self):
        return self.media_set.filter(kind='YT')

arquivo: palestrum/core/templates/core/talk_detail.html
{% extends 'base.html' %}
{% load youtube slideshare %}

{% block content %}
  <h4>{{ talk.title }}</h4>
  {% for speaker in talk.speakers.all %}
    <h5>
      <a href="{% url speaker %}"
        title="{{ speaker.description|truncatewords:20 }}">
        {{ speaker.name }}
      </a>
    </h5>
  {% endfor %}
  <p>{{ talk.description }}</p>
  {% for video in talk.videos %}
    <p>{% youtube video.media_id %}</p>
  {% endfor %}
  {% for slide in talk.slides %}
    <p>{% slideshare slide.media_id slide.title %}</p>
  {% endfor %}
{% endblock content %}




** executar os testes 
$ manage test palestrum.core
** O teste falha 
FAIL: test_slides_in_context 
(palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
AssertionError: 'slides' not found in [...]
=============================================================
FAIL: test_videos_in_context 
(palestrum.core.tests.test_views_talk_detail.TalkDetailTest)
---------------------------------------------------------------
AssertionError: 'videos' not found in [...]



arquivo: palestrum/core/tests/test_views_talk_detail.py
...

class TalkDetailTest(TestCase):
    ...

    def test_not_found(self):
        response = self.client.get(r('core:talk_detail', args=[0]))
        self.assertEqual(404, response.status_code)

    def test_videos_in_context(self):
        self.assertIn('videos', self.resp.context)

    def test_slides_in_context(self):
        self.assertIn('slides', self.resp.context)

    def test_html(self):
        ...



** executar os testes 
$ manage test palestrum.core
** OK - Sucesso!




== Migração para Talk ==

$ manage schemamigration core --auto

 + Added model core.Media
Created 0004_auto__add_media.py.
You can now apply this migration with: ./manage.py migrate core


$ manage migrate core

Running migrations for core:
 - Migrating forwards to 0004_auto__add_media.
 > core:0004_auto__add_media
 - Loading initial data for core.
Installed 0 object(s) from 0 fixture(s)



== Para o deploy no Heroku… ==

# Estando em bvad, commite os códigos alterados
$ git add .
$ git commit -m 'Media'

# Faça o push para o Heroku
$ git push heroku master --force

# Atualize o schema do banco
$ heroku run python manage.py syncdb --migrate




== Username é fora de moda. Dá para acessar o admin com email? ==

$ cd bvad/palestrum
$ manage startapp myauth


arquivo: palestrum/settings.py
INSTALLED_APPS = [
   "django.contrib.auth",
   "django.contrib.contenttypes",
   "django.contrib.sessions", 
   ...
   "palestrum.core",
   "palestrum.subscriptions",
   "palestrum.myauth",
 ]


# Estando em bvad, crie o package tests na app myauth.
# Crie o diretório tests.
$ mkdir palestrum/myauth/tests

# Transforme o diretório em um package.
$ touch palestrum/myauth/tests/__init__.py

# Remova o módulo de teste padrão.
$ rm palestrum/myauth/tests.py


bvad/
    manage.py
    palestrum/
        __init__.py
        settings.py
        urls.py
        wsgi.py
        core/...
        subscriptions/...
        myauth/
            __init__.py
            admin.py
            models.py
            tests/
                __init__.py
            views.py


== Authentication Backend - 1o experimento ==

Backend? 
Uma classe
Que implementa um método authenticate
e um método get_user
e está no settings AUTH_BACKENDS
O Django permite enfileirar backends de autenticação. Um mesmo site é capaz de prover autenticação por:
login e senha
e-mail e senha
github
Facebook
LDAP
etc.



# Estando em bvad, crie o módulo myauth/backends.py.
$ touch palestrum/myauth/backends.py

# Crie o módulo de testes
$ touch palestrum/myauth/tests/test_backends.py




arquivo: palestrum/myauth/tests/test_backends.py
# coding: utf-8
from django.contrib.auth import get_user_model
from django.test import TestCase
from palestrum.myauth.backends import EmailBackend

class EmailBackendTest(TestCase):
    def setUp(self):
        UserModel = get_user_model()
        UserModel.objects.create_user(username='antonio',
                            email='antoniosantos@antoniosantos.net',
                            password='abracadabra')
        self.backend = EmailBackend()

    def test_authenticate_with_email(self):
        user = self.backend.authenticate(email='antoniosantos@antoniosantos.net',
                            password='abracadabra')
        self.assertIsNotNone(user)
* get_user_model ⇒ função nova no Django (1.5 ou 1.6). Agora o Django permite trocar o usermodel, implementar o próprio usermodel. 



** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ImportError: cannot import name EmailBackend



arquivo: palestrum/myauth/backends.py
# coding: utf-8

class EmailBackend(object):
    pass


** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ERROR: test_authenticate_with_email 
(palestrum.myauth.tests.test_backends.EmailBackendTest)
---------------------------------------------------------------
AttributeError: 'EmailBackend' object has no attribute 'authenticate'

arquivo: palestrum/myauth/backends.py
# coding: utf-8

class EmailBackend(object):
    def authenticate(self, email, password, **kwargs):
        pass



** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
FAIL: test_authenticate_with_email 
(palestrum.myauth.tests.test_backends.EmailBackendTest)
---------------------------------------------------------------
AssertionError: unexpectedly None



arquivo: palestrum/myauth/backends.py
# coding: utf-8
from django.contrib.auth import get_user_model

class EmailBackend(object):
    def authenticate(self, email, password, **kwargs):
        UserModel = get_user_model()
        user = UserModel.objects.get(email=email)
        return user
* Teste pra passar de um jeito fácil (não está verificando senha) - só pra ver funcionar



** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!





arquivo: palestrum/myauth/tests/test_backends.py
...

class EmailBackendTest(TestCase):

    ...
    def test_wrong_password(self):
        user = self.backend.authenticate(email='antoniosantos@antoniosantos.net',
                                        password='wrong')
        self.assertIsNone(user)
* provoca a contradição para evoluir… teste que cerca.


** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
FAIL: test_wrong_password 
(palestrum.myauth.tests.test_backends.EmailBackendTest)
---------------------------------------------------------------
AssertionError: <User: antonio> is not None



arquivo: palestrum/myauth/backends.py
# coding: utf-8
from django.contrib.auth import get_user_model

class EmailBackend(object):
    def authenticate(self, email, password, **kwargs):
        UserModel = get_user_model()
        user = UserModel.objects.get(email=email)
        if not user.check_password(password):
            return None
        return user
* Todo usermodel


** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!





arquivo: palestrum/myauth/tests/test_backends.py
...

class EmailBackendTest(TestCase):
    ...
    def test_unknown_user(self):
        user = self.backend.authenticate(email='unknown@email.com',
                                    password='abracadabra')
        self.assertIsNone(user)
* usuário inválido / inexistente no banco


** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ERROR: test_unknown_user 
(palestrum.myauth.tests.test_backends.EmailBackendTest)
---------------------------------------------------------------
DoesNotExist: User matching query does not exist. Lookup parameters were {'email': 'unknown@email.com'}


arquivo: palestrum/myauth/backends.py
# coding: utf-8
from django.contrib.auth import get_user_model

class EmailBackend(object):
    def authenticate(self, email, password, **kwargs):
        UserModel = get_user_model()

        try:
            user = UserModel.objects.get(email=email)
        except UserModel.DoesNotExist:
            return None

        if not user.check_password(password):
            return None
        return user



** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!


arquivo: palestrum/myauth/tests/test_backends.py
...

class EmailBackendTest(TestCase):
    ...

class MultipleEmailsTest(TestCase):
    def setUp(self):
        UserModel = get_user_model()
        UserModel.objects.create_user(username='user1',
            email='antoniosantos@antoniosantos.net', password='abracadabra')
        UserModel.objects.create_user(username='user2',
            email='antoniosantos@antoniosantos.net', password='abracadabra')
        self.backend = EmailBackend()

    def test_multiple_emails(self):
        user = self.backend.authenticate(email='antoniosantos@antoniosantos.net',
                                    password='abracadabra')
        self.assertIsNone(user)
* O e-mail não é unique...




** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ERROR: test_multiple_emails 
(palestrum.myauth.tests.test_backends.MultipleEmailsTest)
---------------------------------------------------------------
MultipleObjectsReturned: get() returned more than one User -- it returned 2! Lookup parameters were {'email': 'antoniosantos@antoniosantos.net'}




arquivo: palestrum/myauth/backends.py
# coding: utf-8
from django.contrib.auth import get_user_model

class EmailBackend(object):
    def authenticate(self, email, password, **kwargs):
        UserModel = get_user_model()

        try:
            user = UserModel.objects.get(email=email)
        except (UserModel.DoesNotExist,
                UserModel.MultipleObjectsReturned):
            return None

        if not user.check_password(password):
            return None
        return user


** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!



* Configurando o Django para usar o Authentication Backend

arquivo: palestrum/settings.py
...

AUTHENTICATION_BACKENDS = (
    'palestrum.myauth.backends.EmailBackend',
)


$ manage runserver

Validating models...

0 errors found
Jan 01, 2013 - 00:00:01
Django version 1.6, using settings 'palestrum.settings'
Development server is running at http://127.0.0.1:8000/
Quit the server with CONTROL-C.



Navegador: Ao acessar a tela de login do admin e inserir o usuário e senha (admin@admin.com e admin), apresenta mensagem de erro (insira um usuário e senha corretos).

Navegador: “Inspect” do elemento. O name do input do formulário é “username”, mas o backend está esperando um parâmetro de nome “email”. 

* Como resolver…
* será feita uma gambiarra.




arquivo: palestrum/myauth/tests/test_backends.py
from django.test.utils import override_settings
...

@override_settings(AUTHENTICATION_BACKENDS=('palestrum.myauth.backends.EmailBackend',))
class FunctionalEmailBackendTest(TestCase):
    def setUp(self):
        UserModel = get_user_model()
        UserModel.objects.create_user(username='antonio',
                    email='antoniosantos@antoniosantos.net',
                    password='abracadabra')

    def test_login_with_email(self):
        result = self.client.login(email='antoniosantos@antoniosantos.net',
                    password='abracadabra')
        self.assertTrue(result)

    def test_login_with_username(self):
        result = self.client.login(username='antoniosantos@antoniosantos.net',
                    password='abracadabra')
        self.assertTrue(result)
* Teste funcional
* override_settings ⇒ bom para testar coisas que dependem de configuração do settings. Neste caso, está dizendo que para execução deste cenário, o Authentication Backend passa a ser o EmailBackend


** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
FAIL: test_login_with_username 
(palestrum.myauth.tests.test_backends.FunctionalEmailBackendTest)
---------------------------------------------------------------
AssertionError: False is not true




* Implementando uma solução para o segundo teste

arquivo: palestrum/myauth/backends.py
# coding: utf-8
from django.contrib.auth import get_user_model

class EmailBackend(object):
    def authenticate(self, email=None, password=None, **kwargs):
        UserModel = get_user_model()

        if email is None:
            email = kwargs.get(UserModel.USERNAME_FIELD)

        try:
            user = UserModel.objects.get(email=email)
        except (UserModel.DoesNotExist, UserModel.MultipleObjectsReturned):
            return None

        if not user.check_password(password):
            return None
        return user
* pulo do gato… 
* Sem testes é “Gambiarra”, com testes é “Criatividade Técnica”.



** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!


Navegador: Tentativa de autenticação incorreta. Apresentação de erro no navegador: “AttributeError at /admin/”

* ‘EmailBackend’ object has no attribute ‘get_user’





arquivo: palestrum/myauth/tests/test_backends.py
...

class EmailBackendTest(TestCase):
    ...

    def test_get_user(self):
        self.assertIsNotNone(self.backend.get_user(1))

** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ERROR: test_get_user 
(palestrum.myauth.tests.test_backends.EmailBackendTest)
---------------------------------------------------------------
AttributeError: 'EmailBackend' object has no attribute 'get_user'


arquivo: palestrum/myauth/backends.py
...
class EmailBackend(object):
    ...
    
    def get_user(self, user_id):
        try:
            UserModel = get_user_model()
            return UserModel.objects.get(pk=user_id)
        except UserModel.DoesNotExist:
            return None


** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!

== O login pode ser o username ou email? ==

arquivo: palestrum/settings.py
...

AUTHENTICATION_BACKENDS = (
    'palestrum.myauth.backends.EmailBackend',
    'django.contrib.auth.backends.ModelBackend',
)






== Custom User Model - 2o experimento ==

arquivo: palestrum/settings.py    (Rollback)
...

AUTHENTICATION_BACKENDS = (
    'palestrum.myauth.backends.EmailBackend',
    'django.contrib.auth.backends.ModelBackend',
)



Custom User?
Um model que herda de AbstractUserModel
atributo de classe USERNAME_FIELD
atributo de classe REQUIRED_FIELDS
field ou property is_active
método get_full_name e get_short_name
manager que herda de CustomUserManager



# Estando em bvad, crie o módulo de testes.
$ touch palestrum/myauth/tests/test_custom_user.py



arquivo: palestrum/myauth/tests/test_custom_user.py
# coding: utf-8
from django.test import TestCase
from django.contrib.auth import get_user_model
from django.test.utils import override_settings

@override_settings(AUTH_USER_MODEL='myauth.User')
class FunctionalCustomUserTest(TestCase):
    def setUp(self):
        UserModel = get_user_model()
        u = UserModel(cpf='12345678901')
        u.set_password('abracadabra')
        u.save()

    def test_login_with_cpf(self):
        self.assertTrue(self.client.login(cpf='12345678901', password='abracadabra'))



** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ERROR: test_login_with_cpf 
(palestrum.myauth.tests.test_custom_user.FunctionalCustomUserTest)
---------------------------------------------------------------
ImproperlyConfigured: AUTH_USER_MODEL refers to model 'myauth.User' that has not been installed


arquivo: palestrum/myauth/models.py
# coding:utf-8
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager
from django.db import models

class UserManager(BaseUserManager):
    pass

class User(AbstractBaseUser):
    cpf = models.CharField(max_length=11, unique=True, db_index=True)
    name = models.CharField(max_length=100, null=True)

    USERNAME_FIELD = 'cpf'

    objects = UserManager()

** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!


arquivo: palestrum/settings.py
...

AUTH_USER_MODEL='myauth.User'

** executar os testes 
$ manage test palestrum.myauth
** O teste falha 
ERROR: test_authenticate_with_email 
(palestrum.myauth.tests.test_backends.EmailBackendTest)
---------------------------------------------------------------
AttributeError: 'UserManager' object has no attribute 'create_user'

arquivo: palestrum/myauth/tests/test_backends.py
# coding: utf-8
from unittest import skip
...

@skip
class EmailBackendTest(TestCase):
    ...

@skip
class MultipleEmailsTest(TestCase):
    ...

@skip
@override_settings(AUTHENTICATION_BACKENDS=
('palestrum.myauth.backends.EmailBackend',))
class FunctionalEmailBackendTest(TestCase):
    ...
* decorator @skip, usado para ignorar o teste


** executar os testes 
$ manage test palestrum.myauth
** OK - Sucesso!


$ manage syncdb

Syncing...
Creating tables ...
Creating table myauth_user

You just installed Django's auth system, which means you don't have any superusers defined.
Would you like to create one now? (yes/no): yes
Cpf: 12345678901 
Password: 
Password (again): 
AttributeError: 'UserManager' object has no attribute 'create_superuser'





arquivo: palestrum/myauth/models.py
...

class UserManager(BaseUserManager):
    def create_user(self, cpf, name=None, password=None):
        user = self.model(cpf=cpf, name=name)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, **credentials):
        return self.create_user(**credentials)

class User(AbstractBaseUser):
    ...
* sem muitos detalhes, pois foi feito apenas para demonstração


$ manage dbshell

SQLite
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> drop table myauth_user;






$ manage syncdb

Syncing...
Creating tables ...
Creating table myauth_user

You just installed Django's auth system, which means you don't have any superusers defined.
Would you like to create one now? (yes/no): yes
Cpf: 12345678901
Password: 
Password (again): 
Superuser created successfully.
The following content types are stale and need to be deleted:

 auth | user

Any objects related to these content types by a foreign key will also
be deleted. Are you sure you want to delete these content types?
If you're unsure, answer 'no'.

 Type 'yes' to continue, or 'no' to cancel: yes

Installing custom SQL ...


Navegador: Tentativa de autenticação incorreta. Apresentação de erro no navegador: “AttributeError at /admin/”
* ‘User’ object has no attribute ‘is_staff’


* Explicação
Custom users and django.contrib.admin
If you want your custom User model to also work with Admin, your User model must define
some additional attributes and methods. These methods allow the admin to control access
of the User to admin content:

class models.CustomUser

is_staff
Returns True if the user is allowed to have access to the admin site.

is_active
Returns True if the user account is currently active.

has_perm(perm, obj=None):
Returns True if the user has the named permission. If obj is provided, the permission
needs to be checked against a specific object instance.

has_module_perms(app_label):
Returns True if the user has permission to access models in the given app.
https://docs.djangoproject.com/en/1.6/topics/auth/customizing/#custom-users-and-django-contrib-admin


arquivo: palestrum/myauth/models.py
class User(AbstractBaseUser):
    cpf = models.CharField(max_length=11, unique=True, db_index=True)
    name = models.CharField(max_length=100, null=True)

    USERNAME_FIELD = 'cpf'

    objects = UserManager()

    @property
    def is_staff(self):
        return True

    def has_module_perms(self, app_label):
        return True

    def has_perm(self, perm, obj=None):
        return True
* apenas pra passar

Navegador: Tentativa de autenticação incorreta. Apresentação de erro no navegador: “NotImplementedError at /admin/”
* No exception supplied  (get_short_name)



arquivo: palestrum/myauth/models.py
class User(AbstractBaseUser):
    ...

    def has_perm(self, perm, obj=None):
        return True

    def get_short_name(self):
        return self.name

    def get_full_name(self):
        return self.name


Navegador: Admin. Funciona bacana agora, usando o CPF como login…


* Ver este projeto:  http://django-userena.readthedocs.org/en/latest/
* Gerenciamento de registro de usuários





== Class-Based Generic Views ==

* complicado para quem está começando. Complexo.
* ferramenta poderosa




(03:53)













== Deploy ==

== FastCGI + Nginx ==

Pré-requisitos

⇒ FLUP
$ sudo pip install flup

⇒ Nginx
$ sudo apt-get install nginx


== Rodando o FastCGI ==

$ manage runfcgi method=threaded host=127.0.0.1 port=8080

== Algumas opções… ==

$ manage help runfcgi
 ...
 protocol=PROTOCOL     fcgi, scgi, ajp, ... (default fcgi)
 host=HOSTNAME         hostname to listen on..
 port=PORTNUM          port to listen on.
 method=IMPL           prefork or threaded (default prefork)
 maxrequests=NUMBER    number of requests a child handles before it is
                       killed and a new child is forked (0 = no limit). 
 maxspare=NUMBER       max number of spare processes / threads
 minspare=NUMBER       min number of spare processes / threads.
 maxchildren=NUMBER    hard limit number of processes / threads
 pidfile=FILE          write the spawned process-id to this file.
 workdir=DIRECTORY     change to this directory when daemonizing.
 outlog=FILE           write stdout to this file.
 errlog=FILE           write stderr to this file.





== Rodando o Nginx ==

$ sudo /etc/init.d/nginx start

arquivo: /etc/nginx/sites-enabled/django.vhost
server {
     listen 80;
     charset utf-8;
     server_name herike.com, stage.heriku.com, production.herike.com
     access_log /var/logs/nginx_access.log;
     error_log /var/logs/nginx_error.log;

     location ^~ /media/ {
          if ($query_string) {
               expires max;
          }
          access_log off;
          root /srv/herike/;
     }
     location ^~ /static/ {
          if ($query_string) {
               expires max;
          }
          access_log off;
          root /srv/herike/;
     }
     location / {
          fastcgi_pass 127.0.0.1:8080;
          fastcgi_cache off;
          include /etc/nginx/bots.conf;
          include /etc/nginx/fastcgi.conf;
     }
}


== Rodando o Nginx ==

$ sudo /etc/init.d/nginx restart





