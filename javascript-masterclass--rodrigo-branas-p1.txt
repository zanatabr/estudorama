JavaScript Masterclass Online - Rodrigo Branas - Abril/2020
==> https://www.javascriptmasterclass.com.br

== Abertura ==

== História da Linguagem ==

- 1989 - Tem Berners Lee - Criou a World Wide Web
-> Servidor + Protocolo + Navegador 
-> CERN (Laboratório)
-> Ver "Timeline of web browsers" {https://en.wikipedia.org/wiki/Timeline_of_web_browsers}
- NCSA Mosaic :: Um dos navegadores mais emblemáticos. Deu origem ao Netscape
- 1994 - Marc Andressen, criador do NCSA Mosaic, lança o Netscape
- HyperCard - plataforma da Apple que chamou a atenção de Andressen
-> Possuía uma linguagem de script embutida chamada "HyperTalk" para interagir com os documentos
-> Brendan Eich (Silicon Graphics), foi recrutado em 1995 para escrever uma linguagem de programação para o navegador. Tentou se basear na linguagem Scheme (dialeto de Lisp), mas era bem confusa. Foi solicitado algo mais popular e fácil de usar. Na época o Java estava em evidência.
-> O Java foi escolhido como modelo sintático.
-> Foi implementada em 10 dias, em maio de 1995, usando como base as linguagens Java, Scheme, Self e algumas influências de Perl.
-> Foi batizada inicialmente como "Mocha"
-> Posteriormente como "LiveScript", no Netscape 2.0
-> Guerra entre navegadores (IE vs Netscape). Em dez/1995 o nome foi modificado para JavaScript (acordo feito com a Sun contra a MS)
-> O nome "JavaScript" foi registrado pela Sun, mas era de uso excluivo da Netscape
-> MS fex engenharia reversa da linguagem, criando o JScript
-> Preocupada em perder o controle, a Netscape tentou padronizar a linguagem em diversas entidades como a W3C
-> Ver: Why was JavaScript standardized by ECMA and not W3C? {https://www.quora.com/Why-was-JavaScript-standardized-by-ECMA-and-not-W3C}
-> 1997 - Netscape padronizou a JavaScript junto a ECMA Internacional, passando a se chamar ECMAScript

Atualmente o nome oficial é: ECMAScript


== Preparação do ambiente ==

-- Instalação do Node.js
https://nodejs.org/en/

-- Console do Node.js :: REPL (Read, Eval, Print & Loop)

== Evolução das Versões ==

- TC39 - Comitê da ECMA International responsável pela especificação ECMA-262
- ES1 (1997) - ECMAScript 1 (110 páginas) - Oficialização do que já havia sido feito até o momento da padronização pela ECMA
- ES2 (1998) - ECMAScript 2 (117 páginas) - Adequação com a normativa ISO/IEC 16262
- ES3 (1999) - ECMAScript 3 (188 páginas) - Exception Handling (throw/try/catch), Regular Expression, switch, do-while,...). A que ficou mais tempo como linguagem ativa (mais de 10 anos)
- Por volta de 2005 (domínio do FLASH na web), com o surgimento do AJAX, a linguagem ganhou vida nova. Proposta de Jesse James Garrett para juntar tecnologias (DOM. Javascript, CSS, HRML e XHTMLRequest) para criar uma experiência diferente, desenvolver aplicações de outra forma.
- Antes, tudo acontecia no backend (interpolação, objetos de sessão, etc).
- ES5 (2009) - ECMAScript 5 (252 páginas) - JSON, strict mode, reserved words as property keys, multiline string, Object API, Array.prototype.*
- 10 anos depois! Isso ocorreu porque houve uma separação dos grupos que especificavam as versões 3.1 e 4.0 
- A TC39 rejeitou as versões 3.1 e 4.0. Foi direto para a 5 (Ver e-mail sobre ECMAScript Harmony de 13/ago/2008 por Brendan Eich)
- ES5.1 (2011) - ECMAScript 5.1 (258 páginas) - Adequação com a normativa ISO/IEC 16262
- Era do sucesso e popularidade
- ES6 (2015) - ECMAScript 6 (566 páginas) - Class, Arrow Function, Proxy, Reflect, Map, Set, Destructuring, Rest Parameter, Default Value, Template Literal, Spread Operator, Generators, Promises, Modules
- ES7 (2016) - ECMAScript 7 (586 páginas) - Array.prototype.includes, Exponentiation operator...
- ES8 (2017) - ECMAScript 8 (885 páginas) - Async/Await, Object.values, Object.entries, String.prototype.padStart, String.prototype.padEnd, Trailling commas in parameters list, objects and arrays...
- A partir do ES7 as versões passaram a ser anuais

- Cuidado com problemas de compatibilidade ao utilizar novas funcionalidades (ainda mais em ambiente de navegador)
- Para evitar problemas, usar um transpiler como o Babel (https://babeljs.io/)
- Ver tabela de compatibilidade do ES6 (http://kangax.github.io/compat-table/es6/)
- Transpilação (https://pt.stackoverflow.com/questions/189894/o-que-%C3%A9-transpila%C3%A7%C3%A3o)




== Variáveis ==

- Formas de declarar: var, let e const

- Ciclo de vida de uma variável
-> Declaração
-> Inicialização
-> Atribuição


-> Declaração : O nome da variável é registrado no "contexto de execução", também conhecido como "escopo", da função.

-> Inicialização : A variável é inicializada com o valor "undefined".

-> Atribuição : Um valor é atribuído para a variável.


-- var --
Ao utilizar "var", a variável é declarada e inicializada no escopo da função, "não respeitando bloco" e "permitindo a redeclaração e reatribuição"


%%% example.js - Teste 01  %%%%%%%%
var pi = 3.141592;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592


%%% example.js - Teste 02  %%%%%%%%
console.log(pi);
var pi = 3.141592;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
undefined

No "Teste 02" o que fica estranho é a apresentação do valor "undefined". Como se a variável ainda não foi declarada? Não deveria apresentar algo como "variável não declarada"?

O que acontece é que na montagem do "contexto de execução", o interpretador passa pelo código e quando encontra uma variável declarada com "var", ele faz a "declaração" (associa o nome no escopo) e nesse caso inicializa com "undefined".


%%% example.js - Teste 03  - Reatribuição %%%
var pi = 3.141592;
console.log(pi);
pi = 3;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592
3


%%% example.js - Teste 04  - Redeclaração %%%
var pi = 3.141592;
console.log(pi);
var pi = 3;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592
3

O "Teste 04" demonstra a afirmação: "permitindo a redeclaração e reatribuição"

%%% example.js - Teste 05 %%%
if (true) {}
    var pi = 3.141592;
}
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592

O "Teste 05" demonstra a afirmação: a variável é declarada e inicializada no ESCOPO da função, "não respeitando bloco".



-- let --
Ao utilizar "let", a variável é declarada no escopo da função, mas só é inicializada posteriormente, "respeitando o bloco" e "premitindo reatribuição, mas não a redeclaração".


%%% example.js - Teste 06 %%%
let pi = 3.141592;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592


%%% example.js - Teste 07 %%%
console.log(pi);
let pi = 3.141592;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... ReferenceError: pi is not defined ...


%%% example.js - Teste 08 - Reatribuição %%%
let pi = 3.141592;
console.log(pi);
pi = 3;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592
3

%%% example.js - Teste 09 - Redeclaração %%%
let pi = 3.141592;
console.log(pi);
let pi = 3;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... SyntaxError: Identifier 'pi' has already been declared...


%%% example.js - Teste 10 %%%
if (true) {}
    let pi = 3.141592;
}
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... ReferenceError: pi is not defined ...


-- const --
Ao utilizar const, a variável é declarada no escopo da função, mas só é inicializada posteriormente, "respeitando bloco" e "não permitindo reatribuição ou redeclaração"

%%% example.js - Teste 11 %%%
const pi = 3.141592;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592


%%% example.js - Teste 12 %%%
console.log(pi);
const pi = 3.141592;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... ReferenceError: pi is not defined ...


%%% example.js - Teste 13 %%%
const pi = 3.141592;
console.log(pi);
pi = 3;
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... TypeError: Assignment to constant variable...


%%% example.js - Teste 14 %%%
if (true) {}
    const pi = 3.141592;
}
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... ReferenceError: pi is not defined ...


(*) Ao declarar uma variável sem "var", "let" ou "const", "ela é criada no ESCOPO GLOBAL".
É pior que o uso do "var".


%%% example.js - Teste 15 %%%
(function () {
    var pi = 3.141592;
})();
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
... ReferenceError: pi is not defined ...
(Até aí, OK)


%%% example.js - Teste 16 %%%
(function () {
    pi = 3.141592;
})();
console.log(pi);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$ node example1.js
3.141592
(!!!! Péssima ideia)

(*) Nunca declare variáveis sem "var", "let" ou "const". "Evite a utilização de var".


-- Regra para identificadores --

Um identificador válido deve começar com [a-zA-Z_$] seguido por [a-zA-Z0-9_$]



== Tipos de Dados ==

- 02 tipos: Primitivos e Objetos

-- Primitivos --
São imutáveis, ou seja, aolongo do tempo "seu valor não é alterado".
O JS oferece 6 tipos primitivos, sendo:
* number
* string
* boolean
* symbol
* null
* undefined


$ node
n> typeof 10;
'number'
n> typeof "JavaScript";
'string'
n> typeof false
'boolean'
n> typeof Symbol();
'symbol'
n> typeof null;
'object'
n> typeof undefined;
'undefined'

-- Os tipos primitivos podem ser encapsulados (processo de autoboxing / wrapper)

$ node
n> (10).toFixed(2)
'10.00'
n> ('JavaScript').replace('a',4);
'J4vaScript'
n> (true).toString();
'true'
n> (Symbol("iterator")).toString();
'Symbol(iterator)'


-- Objetos --
Os objetos são valores que representam uma referência em "memória" que pode ser alterada

$ node
n> typeof function sum (a,b) {return a + b};
'function'
n> typeof {name: 'Linus Torvalds'};
'object'
n> typeof [1,2,3,4,5,6,7,8,9];
'object'
n> typeof /[a-zA-Z_$]/;
'object'
n> typeof new Date();
'object'


(*) Cuidado! Não confunda os operadores "typeof" e "instanceof"


== Number ==

O tipo Number é primitivo, imutável e é representado internamente pelo padrão IEEE 754 de 64 bits.

Suporta 4 sistemas de numeração:
-> decimal
-> hexadecimal
-> binário
-> octal

-- decimal --
O sistema de numeração "decimal", de base 10, deve iniciar com um dígito de 1 a 9, seguido por números de 0 a 9, com ou sem ponto, indicando se é inteiro ou decimal.

-- hexadecimal --
O sistema de numeração "hexadecimal", de base 16, deve iniciar com 0x ou 0X, seguido por dígitos de 0 a 9 e letras de A a F.

-- binário --
O sistema de numeração "binário", de base 2, deve iniciar com 0b ou 0B, seguido por números de 0 a 1

-- octal --
O sistema de numeração "octal", de base 8, deve iniciar com 0, 0o ou 0O, seguido por dígitos de 0 a 7

$ node
n> 10
10
n> 9.9
9.9
n> 0xFF
255
n> 0b11
3
n> 010
8
n> 0X1A
26
n> 0o7
7
n> 0o12
10

-- Usando a função construtora

$ node
n> new Number(10)
[Number: 10]
n> new Number(9.9)
[Number: 9.9]
n> new Number(0xFF)
[Number: 255]
n> new Number(0b10)
[Number: 2]
n> new Number(010)
[Number: 8]
n> let n = new Number(10)
undefined
n> n.
n.__defineGetter__      n.__defineSetter__      n.__lookupGetter__
n.__lookupSetter__      n.__proto__             n.constructor
n.hasOwnProperty        n.isPrototypeOf         n.propertyIsEnumerable
n.toLocaleString        n.toString              n.valueOf

n.toExponential         n.toFixed               n.toPrecision


- Os métodos "toExponential", "toFixed" e "toPrecision" podem ser utilizados para "mudar a forma como um número é representado"


$ node
n> (123.4)
123.4
n> (123.4).toExponential(10)
'1.2340000000e+2'
n> (1234.5).toExponential(10)
'1.2345000000e+3'
n> (123.4).toFixed(10)
'123.4000000000'
n> (10).toFixed(2)
'10.00'
n> (123.4).toPrecision(10)
'123.4000000'
 

== Operadores Numéricos ==

-- Operadores aritméticos: +, -, *, / e %

arquivo: number_operators_1.js

$ node
> 2 + 2
4
> 8 - 3
5
> 4 * 5
20
> 9 / 3
3
> 7 % 2
1


-- Operadores de atribuição:  +=, -=, *=, /= e %=

arquivo: number_operators_2.js

$ node
> let result = 10;
undefined
> result = result + 2
12
> result += 2
14
> result -= 5;
9
> result *= 8
72
> result /= 2
36
> result %= 6
0


-- Operador de incremento (++) e decremento (--)

arquivo: number_operators_3.js

$ node
> let result = 10;
10
> result++
10
> result
11
> ++result
12
> result--
12
> result
11
> --result
10


-- Operadores binários: |, &, ^, ~, <<, >> e >>>

arquivo: number_operators_4.js

$ node
> 4 | 3
7
> (4).toString(2)
'100'
> (3).toString(2)
'11'
> (4).toString(2).padStart(32,0)
'00000000000000000000000000000100'
> (3).toString(2).padStart(32,0)
'00000000000000000000000000000011'
> 0b111
7
>
> 3 & 1
1
> (3).toString(2).padStart(32,0)
'00000000000000000000000000000011'
> (1).toString(2).padStart(32,0)
'00000000000000000000000000000001'
> 0b1
1
>
> 5 ^ 2
7
> (5).toString(2).padStart(32,0)
'00000000000000000000000000000101'
> (2).toString(2).padStart(32,0)
'00000000000000000000000000000010'
> 0b111
7
>
> ~2
-3
> (2).toString(2).padStart(32,0)
'00000000000000000000000000000010'
> (-3 >>> 0).toString(2).padStart(32,0)
'11111111111111111111111111111101'
> 
> 4 << 2
16
> (4).toString(2).padStart(32,0)
'00000000000000000000000000000100'
> (16).toString(2).padStart(32,0)
'00000000000000000000000000010000'
> 
> 
> 128 >> 1
64
> (128).toString(2).padStart(32,0)
'00000000000000000000000010000000'
> (64).toString(2).padStart(32,0)
'00000000000000000000000001000000'
> 
> 
> -2 >>> 1
2147483647
> (-2 >>> 0).toString(2).padStart(32,0)
'11111111111111111111111111111110'
> (2147483647).toString(2).padStart(32,0)
'01111111111111111111111111111111'
> 





(*) Cuidado para "não confundir" os operadores | e & com || e &&



== Conversão Numérica ==

A forma mais simples de converter um número épor meio da "invocação da função construtora Number"

arquivo: number_conversion_1.js

$ node
> new Number(10)
[Number: 10]
> Number("10")
10
> Number("9.9")
9.9
> Number("0xFF")
255
> Number("0b10")
2
> Number("0o10")
8
> Number()
0
> Number("JavaScript")
NaN


Um outro jeito de realizar conversões é por meio dos "operadores numéricos"

arquivo: number_conversion_2.js

$ node
> ~~"10";
10
> +"10";
10
> "10" - 0;
10
> "10" * 1;
10
> "10" / 1;
10
> "10" + 0;
'100'



(*) Cuidado, nem todosos operadores numéricos realizam a conversão (baseando-se em coerção de tipos)

arquivo: number_conversion_3.js

$ node
> "10" + 0;
'100'


O métod toString de um número permite convertê-lo para qualquer sistema de numeração, bastando indicar qual é a base desejada.

arquivo: number_conversion_4.js

$ node
> (0xA).toString(10)
'10'
> (0b1010).toString(16)
'a'
> (010).toString(2)
'1000'
> (10).toString(8)
'12'


O método parseInt permite converter uma String para um número. Para isso basta indicar o número e a sua base, que caso não seja informada será 10.


arquivo: number_conversion_5.js

$ node
> parseInt("10", 10)
10
> parseInt("10")
10
> parseInt("9.9", 10)
9
> parseInt("A", 16)
10
> parseInt("A")
NaN
> parseInt("11")
11
> parseInt("11", 2)
3
> parseInt("010")
10
> parseInt("010", 8)
8


O método parseFloat é um pouco mais específico e converte apenas números no sistema de numeração decimal.

arquivo: number_conversion_6.js

$ node
> parseFloat("10")
10
> parseFloat("9.9")
9.9
> parseFloat("2.5")
2.5
> parseFloat("0xFF")
0
> parseFloat("xFF")
NaN
> parseFloat("0b10")
0



== IEEE 754 ==

O IEEE 754 é um padrão de representação numérica criado em 1985 e adotado por diversas linguagens de programação como JavaScript, Ruby, Python e Java.



-- Representação em 64 bits
-> S = Sinal (1 bit)
-> E = Expoente (11 bits)
-> F = Fração ou Mantissa (52 bits)

(*) Cuidado com "alguns tipos de operação" envolvendo números

Ao realizar operações com números decimais, podem existir resíduos decorrentes do arredondamento.


arquivo: ieee754_1.js

$ node
> 0.1 + 0.2;
0.30000000000000004
> 666.7 - 666.6
0.10000000000002274
> 33.3 * 3
99.89999999999999
> 12.2 / 0.1
121.99999999999999
> 0.5 + 0.5
1

Usar a calculadora para validar alguns casos para entender o motivo do problema de arredondamento.

--> IEEE 754 Calculator
http://weitz.de/ieee/


Infinity, que pode ser positivo ou negativo, é retornado quando uma operação ultrapassa os limites do tipo number.

arquivo: ieee754_2.js

$ node
> 1 / 0;
Infinity
> Math.pow(10, 1000);
Infinity
> Number.MAX_VALUE
1.7976931348623157e+308
> Number.MAX_VALUE * 2
Infinity
> -Number.MAX_VALUE * 2
-Infinity
> Math.log(0)
-Infinity


NaN, ou Not a Number, é retornado quando realizamos uma operação numérica onde não é possível determinar o resultado

arquivo: ieee754_3.js

$ node
> 10 * "JavaScript";
NaN
> 0 / 0
NaN
> Math.sqrt(-9)
NaN
> Math.log(-1)
NaN
> parseFloat("Texto")
NaN
> NaN == NaN
false
> isNaN(NaN)
true



== Math API ==

Math é um objeto global que contém constantes matemáticas e métodos para a realização deoperações envolvendo números.

arquivo: math_1.js

$ node
> Math.E
2.718281828459045
> Math.LN10
2.302585092994046
> Math.LN2
0.6931471805599453
> Math.LOG10E
0.4342944819032518
> Math.LOG2E
1.4426950408889634
> Math.PI
3.141592653589793
> Math.SQRT1_2
0.7071067811865476
> Math.SQRT2
1.4142135623730951


* abs: converte o sinal do número para positivo
* ceil: arredonda o número para cima
* floor: arredonda o número para baixo
* round: arredonda o número para cima se a parte decimal estiver entre 5 e 9, e para baixo se estiver entre 0 e 4
* sign: retorna 1 se o número for positivo e -1 se for negativo
* trunc: elimina a parte decimal do número, tornando-o um inteiro.


arquivo: math_2.js

$ node
> Math.abs(10)
10
> Math.abs(-10)
10
> Math.ceil(1.1)
2
> Math.ceil(-1.1)
-1
> Math.floor(9.9)
9
> Math.floor(-9.9)
-10
> Math.round(4.5)
5
> Math.round(4.6)
5
> Math.round(4.7)
5
> Math.round(4.4)
4
> Math.round(4.3)
4
> Math.round(4.2)
4
> Math.round(-4.5)
-4
> Math.round(-4.4)
-4
> Math.round(-4.3)
-4
> Math.round(-4.6)
-5
> Math.round(-4.8)
-5
> Math.sign(5)
1
> Math.sign(-5)
-1
> Math.trunc(2.3)
2
> Math.trunc(-2.3)
-2



* cbrt: raiz cúbica
* cos: coseno
* exp: "E" elevado a um expoente
* hypot: raiz quadrada dos quadrados dos números
* log: logarítmo em base natural
* pow: potência de um número
* sin: seno de um ângulo
* sqrt: raiz quadrada
* tan: tangente de um ângulo


arquivo: math_3.js

$ node
> Math.cbrt(8)
2
> Math.cos(Math.PI/3)
0.5000000000000001
> Math.exp(1)
2.718281828459045
> Math.E
2.718281828459045
> Math.hypot(3,4)
5
> Math.log(1)
0
> Math.log(Math.E)
1
> Math.pow(2,3)
8
> Math.pow(2,10)
1024
> Math.sin(Math.PI/2)
1
> Math.sqrt(4)
2
> Math.tan(Math.PI/4)
0.9999999999999999



* min: o menor número informado 
* max: o maior número informado
* random: número aleatório entre 0 e 1 (não incluindo o 1)

arquivo: math_4.js

$ node
> Math.min(1,2,3,4,5,6)
1
> Math.max(1,2,3,4,5,6)
6
> Math.random()
0.830331593540206
> Math.random()
0.4409698264387376
> Math.random()
0.28339376331387967
> Math.random() * 1000
182.22124518624548
> Math.random() * 1000
213.60162675090578
> Math.floor(Math.random() * 1000)
205
> Math.floor(Math.random() * 1000)
143
> Math.floor(Math.random() * 1000)
95
> Math.floor(Math.random() * 1000)
46
> Math.floor(Math.random() * 1000)
551



== String ==

O tipo String é primitivo, imutável e é representado internamente pelo padrão Unicode, codificado em UTF-16

Pode ser declarada de 3 formas:
-> aspas simples
-> aspas duplas
-> acento grave


arquivo: string_1.js

$ node
> 'JavaScript'
'JavaScript'
> "JavaScript"
'JavaScript'
> `JavaScript`
'JavaScript'


Tem diferença entre essas formas?

arquivo: string_2.js

$ node
> 'JavaScript' === "JavaScript";
true
> 'JavaScript' === `JavaScript`;
true
> "JavaScript" === `JavaScript`;
true


Também é possível declarar uma String por meio da sua "função construtra"



arquivo: string_3.js

$ node
> new String('JavaScript')
[String: 'JavaScript']
> new String("JavaScript")
[String: 'JavaScript']
> new String(`JavaScript`)
[String: 'JavaScript']


A "função construtora" é mais lenta e pode prejudicar a performance (obviamente para volumes muito grandes).


-- arquivo: string_4.js

let counter = 0;
console.time("performance");
while (counter < 100000) {
	"JavaScript";
	counter++;
}
console.timeEnd("performance");

-- arquivo: string_5.js

let counter = 0;
console.time("performance");
while (counter < 100000) {
	new String("JavaScript");
	counter++;
}
console.timeEnd("performance");


(*) Executar algumas vezes e comparar o tempo gasto em cada uma das versões acima 


Alguns tipos de caracteres não são permitidos e precisam ser "escapados".


-- arquivo: string_6.js

console.log("Each constructor is a function that has a property named \"prototype\" that is used to implement prototype-based inheritance and shared properties.");
console.log('An object\'s prototype chain should have finite length.');
console.log(`The proper way to cause a line terminator code point to be part of the String value of a string literal is to use an escape sequence such as \\n or \\u000A`);



Existem também "caracteres de controle" que podem ser usados para quebrar linhas, aumentar a identação, etc.

* \b : Backspace
* \f : Form Feed
* \n : New Line
* \r : Carriage Return
* \t : Horizontal Tabulator
* \v : Vertical Tabulator


-- arquivo: string_7.js

let daysOfWeek = "0 - Sun\n1 - Mon\n2 - Tue\n3 - Wed\n4 - Thu\n5 - Fri\n6 - Sat";
console.log(daysOfWeek);

$ node
> let daysOfWeek = "0 - Sun\n1 - Mon\n2 - Tue\n3 - Wed\n4 - Thu\n5 - Fri\n6 - Sat";
undefined
> console.log(daysOfWeek);
0 - Sun
1 - Mon
2 - Tue
3 - Wed
4 - Thu
5 - Fri
6 - Sat
undefined
> 



É possível escrecer caracteres utilizando os seus respectivos "code points" no padrão Unicode

-- arquivo: string_8.js

let daysOfWeekInCodePoints = "\u0030 \u002d \u0053\u0075\u006e\u000A\u0031 \u002d \u004d\u006f\u006e\u000A\u0032 \u002d \u0054\u0075\u0065\u000A\u0033 \u002d \u0057\u0065\u0064\u000A\u0034 \u002d \u0054\u0068\u0075\u000A\u0035 \u002d \u0046\u0072\u0069\u000A\u0036 \u002d \u0053\u0061\u0074";
console.log(daysOfWeekInCodePoints);

$ node
> let daysOfWeekInCodePoints = "\u0030 \u002d \u0053\u0075\u006e\u000A\u0031 \u002d \u004d\u006f\u006e\u000A\u0032 \u002d \u0054\u0075\u0065\u000A\u0033 \u002d \u0057\u0065\u0064\u000A\u0034 \u002d \u0054\u0068\u0075\u000A\u0035 \u002d \u0046\u0072\u0069\u000A\u0036 \u002d \u0053\u0061\u0074";
undefined
> console.log(daysOfWeekInCodePoints);
0 - Sun
1 - Mon
2 - Tue
3 - Wed
4 - Thu
5 - Fri
6 - Sat
undefined
> 



== Template Literal ==

Surgiu no ES6 (2015).

Um template literal é uma forma de declarar uma String que permite interpolação de expressões.


-- arquivo: template_literals_1.js

let host = "localhost";
let port = "3000";
let resource = "users";
let url = "https://" + host + ":" + port + "/" + resource;
console.log(url);


-- arquivo: template_literals_2.js

let host = "localhost";
let port = "3000";
let resource = "users";
let url = `https://${host}:${port}/${resource}`;
console.log(url);


Além da interpolação de expressões também é possível declarar uma String "multi-linha", sem a necessidade de caracteres especiais.

-- arquivo: template_literals_3.js

let monthsOfYear = "0 - Jan" + 
"1 - Feb" + 
"2 - Mar" + 
"3 - Apr" + 
"4 - May" + 
"5 - Jun" +
"6 - Jul" +
"7 - Aug" +
"8 - Sep" +
"9 - Oct" + 
"10 - Nov" +
"11 - Dec"
console.log(monthsOfYear);

-- arquivo: template_literals_4.js

let monthsOfYear = "0 - Jan\
1 - Feb\
2 - Mar\
3 - Apr\
4 - May\
5 - Jun\
6 - Jul\
7 - Aug\
8 - Sep\
9 - Oct\
10 - Nov\
11 - Dec";
console.log(monthsOfYear);

-- arquivo: template_literals_5.js
let monthsOfYear = "0 - Jan\n\
1 - Feb\n\
2 - Mar\n\
3 - Apr\n\
4 - May\n\
5 - Jun\n\
6 - Jul\n\
7 - Aug\n\
8 - Sep\n\
9 - Oct\n\
10 - Nov\n\
11 - Dec";
console.log(monthsOfYear);

-- arquivo: template_literals_6.js

let monthsOfYear = `0 - Jan
1 - Feb
2 - Mar
3 - Apr
4 - May
5 - Jun
6 - Jul
7 - Aug
8 - Sep
9 - Oct
10 - Nov
11 - Dec`;
console.log(monthsOfYear);


== String API ==

* length: Retorna o tamanho da String
* indexOf: Retorna a primeira posição em que o caractere passado como parâmetro foi encontrado
* lastIndexOf: Retorna a última posição em que o caractere passado como parâmetro foi encontrado
* toUpperCase: Retorna uma nova String convertendo as letras para maiúsculas
* toLowerCase: Retorna uma nova String convertendo as letras para minúsculas


-- arquivo: string_api_1.js

$ node
> "JavaScript".length;
10
> "PHP".indexOf("P");
0
> "PHP".lastIndexOf("P");
2
> "cobol".toUpperCase();
'COBOL'
> "ALGOL".toLowerCase();
'algol'


* charAt: Retorna o caractere na posição passada como parâmetro
* charCodeAt: Retorna o código com base na posição passada por parâmetro
* fromCharCode: Retorna um caractere com base no código passado por parâmetro

-- arquivo: string_api_2.js

$ node
> "JavaScript".charAt(1);
'a'
> "JavaScript".charCodeAt(1);
97
> String.fromCharCode(97);
'a'


* includes: Retorna verdadeiro se a String contém a String passada como parâmetro
* startsWith: Retorna verdadeiro se a String inicia com a String passada como parâmetro
* endsWith: Retorna verdadeiro se a String termina com a String passada como parâmetro

-- arquivo: string_api_3.js

$ node
> "JavaScript".includes("Java");
true
> "Ruby".startsWith("R");
true
> "Erlang".endsWith("lang");
true


* localeCompare: Retorna -1 se a String passada como parâmetro for maior, 0 se for igual e 1 se for menor


-- arquivo: string_api_4.js

$ node
> "C++".localeCompare("Ruby");
-1
> "Python".localeCompare("Java");
1
> "JavaScript".localeCompare("JavaScript");
0
> 
> "a".localeCompare("b")
-1
> "a".localeCompare("a")
0
> "b".localeCompare("a")
1
> "a" < "b"
true
> "á" < "b"
false
> "a".charCodeAt(0)
97
> "b".charCodeAt(0)
98
> "á".charCodeAt(0)
225
> "á".localeCompare("b")
-1


* match: Retorna partes da String com base na RegExp passada como parâmetro
* search: Retorna a primeira posição encontrada com base na RegExp passada como parâmetro
* replace: Retorna uma nova String resultante da substituição da String ou RegExp passada no primeiro parâmetro pelo segundo parâmetro.

-- arquivo: string_api_5.js

$ node
> "C++".match(/\+/g);
[ '+', '+' ]
> "C+++".match(/\+/g);
[ '+', '+', '+' ]
> "C+++".match(/\+/);
[ '+', index: 1, input: 'C+++' ]
> "Java".search(/a/);
1
> "JavaScript".replace("Java", "Ecma");
'EcmaScript'
> "JavaScript".replace(/a/g, 4);
'J4v4Script'



* slice: retorna uma parte da String que está invocando a função, iniciando na possição passada no primeiro parâmetro até a posição final passada no segundo parâmetro, ou da posição passada no primeiro parâmetro até o fim, caso o segundo parâmetro não seja informado.
* split: Retorna um array contendo o resultado da divisão da String original, de acordo com o critério passado como parâmetro.
* substring: similar ao slice, não aceita valores negativos como parâmetro e permite a inversão dos parâmetros.


-- arquivo: string_api_6.js

$ node
> "JavaScript".slice(0, 4);
'Java'
> "JavaScript".slice(4);
'Script'
> "JavaScript".slice(0, -6);
'Java'
> "JavaScript".slice(-6);
'Script'
> "C;Java;JavaScript;Ruby".split(";");
[ 'C', 'Java', 'JavaScript', 'Ruby' ]
> "JavaScript".substring(0, 4);
'Java'
> "JavaScript".substring(4, 0);
'Java'
> "JavaScript".substring(4);
'Script'


* concat: Retorna uma nova String resultante da concatenação da String que está invocando a função e da outra, passada por parâmetro
* padStart: Completa a String com caracteres no início
* padEnd: Completa a String com caracteres no fim
* repeat: Repete um caractere
* trim: Elimina espaços em branco no início e no fim
* trimLeft: Elimina espaços em branco no início
* trimRight: Elimina espaços em branco no fim 


-- arquivo: string_api_7.js

$ node
> "Java".concat("Script");
'JavaScript'
> "Data".concat("Flex");
'DataFlex'
> (8).toString(2)
'1000'
> (8).toString(2).padStart(32,0)
'00000000000000000000000000001000'
> "Script".padStart(10, "Java");
'JavaScript'
> "C".padEnd(3, "+");
'C++'
> "C".concat("+".repeat(2));
'C++'
> " Self ".trim();
'Self'
> " Scheme ".trimLeft();
'Scheme '
> " Perl ".trimRight();
' Perl'



== Boolean ==

O tipo Boolean é primitivo, imutável e representado pelas palavras reservas "true" e "false"

-- arquivo: boolean_1.js

$ node
> true
true
> false
false
> typeof(true)
'boolean'
> typeof true
'boolean'
> typeof false
'boolean'



-- arquivo: boolean_2.js

$ node
> new Boolean(true)
[Boolean: true]
> new Boolean(false)
[Boolean: false]
> typeof new Boolean(true)
'object'


-- arquivo: boolean_3.js

let condition = true;
if (condition) {
    console.log("The condition is true");
} else {
    console.log("The condition is false");
}

saída: The condition is true

-- arquivo: boolean_4.js

let condition = false;
if (condition) {
    console.log("The condition is true");
} else {
    console.log("The condition is false");
}

saída: The condition is false

-- arquivo: boolean_5.js

let condition = new Boolean(true);
if (condition) {
    console.log("The condition is true");
} else {
    console.log("The condition is false");
}

saída: The condition is true

-- arquivo: boolean_6.js

let condition = new Boolean(false);
if (condition) {
    console.log("The condition is true");
} else {
    console.log("The condition is false");
}

saída: saída: The condition is true
!!!! Por quê?


(*) Cuidado com a coersão de tipo

A coersão de tipo acontece quando um tipo de dado é utilizado em um contexto onde ele é convertido de forma implícita ou explícita

-- arquivo: boolean_7.js

(*) Somente esses 6 valores são avaliados como false. O restante é avaliado como true
$ node
> !!0;
false
> !!NaN;
false
> !!"";
false
> !!false;
false
> !!undefined;
false
> !!null;
false




-- arquivo: boolean_8.js

$ node
> !!-10;
true
> !!"JavaScript";
true
> !!{};
true
> !![];
true
> !!/JavaScript/;
true
> !!new Date();
true
> !!function () {};
true





== Operadores Booleanos ==


Operadores de comparação
==, ===, !=, !==, <, >, <= e >=


-- arquivo: boolean_operators_1.js

$ node
> 1 == 2;
false
> 10 === 10;
true
> 'a' != 'b';
true
> 3 !== 2;
true
> 6 > 7;
false
> 5 >= 5;
true
> 'z' < 'x';
false
> 'c' <= 'c';
true



(*) Cuidado com os operadores de comparação == e != 


-- arquivo: boolean_operators_2.js

$ node
> 0 == ''
true
> 0 == '0' 
true
> false == undefined
false
> false == null
false
> null == undefined
true
> 1 == true
true
> 0 == false
true
> 0 == '\n'
true


(*) Para evitar os problemas anteriores


Prefira sempre a utilização dos operadores === e !==

-- arquivo: boolean_operators_3.js

$ node
> 0 === ''
false
> 0 === '0' 
false
> false === undefined
false
> false === null
false
> null === undefined
false
> 1 === true
false
> 0 === false
false
> 0 === '\n'
false



Operadores lógicos || e && 

-- arquivo: boolean_operators_4.js

$ node
> 0 || 2;
2
> 1 || 2;
1
> 1 && 2;
2
> 0 && 2;
0


-- arquivo: boolean_operators_5.js

function generateSerial (max) {
    return Math.floor(Math.random() * max);
}

generateSerial(10);
generateSerial(100);
generateSerial(1000);
generateSerial();




-- arquivo: boolean_operators_6.js

function generateSerial (max) {
    if (max === undefined) {
        max = 1000;
    }
    return Math.floor(Math.random() * max);
}

generateSerial(10);
generateSerial(100);
generateSerial(1000);
generateSerial();



-- arquivo: boolean_operators_7.js

function generateSerial (max) {
    if (!max) {
        max = 1000;
    }
    return Math.floor(Math.random() * max);
}

generateSerial(10);
generateSerial(100);
generateSerial(1000);
generateSerial();



-- arquivo: boolean_operators_8.js

function generateSerial (max) {
    max = max || 1000;
    return Math.floor(Math.random() * max);
}

generateSerial(10);
generateSerial(100);
generateSerial(1000);
generateSerial();




Operador ternário
(expressão) ? true : false

-- arquivo: boolean_operators_9.js

$ node
> (10) ? 'good' : 'bad';
'good'
> (0) ? 'good' : 'bad';
'bad'



== Symbol ==

O tipo Symbol é primitivo, único e imutável, atuando como uma chave única em um objeto.

-- arquivo: symbol_1.js

$ node
> Symbol("a");
Symbol(a)
> Symbol("b");
Symbol(b)
> Symbol("c");
Symbol(c)
> 
> Symbol("a") == Symbol("a")
false
> "a" == "a"
true


-- arquivo: symbol_2.js

$node
> Symbol("a") == Symbol("a");
false
> Symbol("b") == Symbol("b");
false
> Symbol("c") == Symbol("c");
false



Além disso, é utilizado em operações realizadas pelo interpretador, como no comando for/of ou em operações da String API como match, split, replace e muitas outras


-- arquivo: symbol_3.js

$ node
> Symbol.hasInstance            
Symbol(Symbol.hasInstance)
> Symbol.isConcatSpreadable
Symbol(Symbol.isConcatSpreadable)
> Symbol.iterator
Symbol(Symbol.iterator)
> Symbol.match
Symbol(Symbol.match)
> Symbol.replace
Symbol(Symbol.replace)
> Symbol.search
Symbol(Symbol.search)
> Symbol.species
Symbol(Symbol.species)
> Symbol.split
Symbol(Symbol.split)
> Symbol.toPrimitive
Symbol(Symbol.toPrimitive)
> Symbol.toStringTag
Symbol(Symbol.toStringTag)
> Symbol.unscopables
Symbol(Symbol.unscopables)



-- arquivo: symbol_4.js

$ node
> let regexp = /JavaScript/;
undefined
> "/JavaScript/".startsWith(regexp)
TypeError: First argument to String.prototype.startsWith must not be a regular expression
    at String.startsWith (<anonymous>)
> regexp[Symbol.match] = false;
false
> "/JavaScript/".startsWith(regexp)
true



== Expressões Regulares ==

As expressões regulares são estruturas formadas por uma sequência de caracteres que especificam um padrão formal que servem para validar, extrair ou mesmo substituir caracteres dentro de uma String

-- arquivo regexp_1.js

/john@gmail.com/;


-- arquivo regexp_2.js

new RegExp("john@gmail.com");


-- arquivo regexp_3.js

let regExp = /john@gmail.com/;
let result = regExp.test("john@gmail.com");
console.log(result);


-- arquivo regexp_4.js

let regExp = /john@gmail.com/;
let result = regExp.exec("john@gmail.com");
console.log(result);


-- arquivo regexp_5.js

let regExp = /john@gmail.com/;
let result = regExp.exec("E-mail: john@gmail.com");
console.log(result[0]);
console.log(result.index);
console.log(result.input);


$ node
> /john@gmail.com/;
/john@gmail.com/
> typeof /john@gmail.com/;
'object'
> new RegExp("john@gmail.com")
/john@gmail.com/
> let regExp = /john@gmail.com/;
undefined
> let result = regExp.test("john@gmail.com");
undefined
> result
true
> result = regExp.exec("john@gmail.com");
[ 'john@gmail.com', index: 0, input: 'john@gmail.com' ]
> result
[ 'john@gmail.com', index: 0, input: 'john@gmail.com' ]
> result[0]
'john@gmail.com'
> result.index
0
> result.input
'john@gmail.com'
> result = regExp.exec("joh.doe@gmail.com");
null
> result
null



-- Metacaracteres - Parte 1
. - Representa qualquer caractere



-- arquivo regexp_6.js

let regExp = /john@gmail.com/;
let result = regExp.exec("E-Mail: john@gmailxcom");
console.log(result[0]);
console.log(result.index);
console.log(result.input);


-- Escapando caracteres especiais

\ - A barra é utilizada antes de caracteres especiais, com o objetivo de escapá-los

-- arquivo regexp_7.js

let regExp = /john@gmail\.com/;
let result = regExp.exec("E-Mail: john@gmailxcom");
console.log(result);


-- Iniciando e finalizando com um determinado caractere
^ - Inicia com um determinado caractere
$ - Finaliza com um determinado caractere


-- arquivo regexp_8.js

let regExp = /^john@gmail\.com$/;
let result1 = regExp.exec("E-Mail: john@gmail.com");
console.log(result1);
let result2 = regExp.exec("john@gmail.com");
console.log(result2);


-- Grupos de caracteres
* [abc] - Aceita qualquer caractere dentro do grupo, nesse caso a, b e c
* [^abc] - Não aceita qualquer caractere dentro do grupo, nesse caso a, b ou c
* [0-9] - Aceita qualquer caractere entre 0 e 9
* [^0-9] - Não aceita qualquer caractere entre 0 e 9


-- Quantificadores
Os quantificadores podem ser aplicados a caracteres, grupos, conjuntos ou metacaracteres.
{n} - Quantifica um número específico
{n,} - Quantifica um número mínimo
{n,m} - Quantifica um número mínimo e um número
máximo
? - Zero ou um
* - Zero ou mais
+ - Um ou mais



-- arquivo regexp_9.js

let regExp = /^[a-z]+@[a-z]+\.[a-z]{3}$/;
let result = regExp.exec("jane@hotmail.com");
console.log(result[0]);
console.log(result.index);
console.log(result.input);




-- arquivo regexp_10.js

let regExp = /^[a-z]+@[a-z]+(\.[a-z]{2,3})+$/;
let result = regExp.exec("mary@hotmail.com.br");
console.log(result[0]);
console.log(result[1]);
console.log(result.index);
console.log(result.input);


Metacaracteres
\w - Representa o conjunto [a-zA-Z0-9_]
\W - Representa o conjunto [^a-zA-Z0-9_]
\d - Representa o conjunto [0-9]
\D - Representa o conjunto [^0-9]
\s - Representa um espaço em branco
\S - Representa um não espaço em branco
\n - Representa uma quebra de linha
\t - Representa um tab

-- arquivo regexp_11.js

let regExp = /^\w+@\w+(\.\w{2,3})+$/;
let result = regExp.exec("mary@hotmail.com.br");
console.log(result[0]);
console.log(result[1]);
console.log(result.index);
console.log(result.input);


-- Grupos de Captura
() - Determina um grupo de captura para realizar a extração de valores de uma determinada String

-- arquivo regexp_12.js

let regExp = /([a-z]+)@([\.a-z]+)/;
let result = regExp.exec("mary@hotmail.com");
console.log(result[0]);
console.log(result[1]);
console.log(result[2]);
console.log(result.index);
console.log(result.input);


-- Modificadores
i - Case-insensitive matching
g - Global matching
m - Multiline matching

-- arquivo regexp_13.js

let regExp = /[a-z]+@[\.a-z]+/g;
let result1 = regExp.exec("mary@hotmail.com;john@gmail.com");
console.log(result1[0]);
console.log(result1.index);
let result2 = regExp.exec("mary@hotmail.com;john@gmail.com");
console.log(result2[0]);
console.log(result2.index);





== Exercício 1 ==

-- Objetivo
Extraia partes do comando como o nome da tabela e as colunas, armazenando-as em variáveis.

--Instruções

Dado o comando:
create table author (id number, name string, age number, city string, state string, country string)

1. Extraia o nome da tabela e armazene em uma variável chamada "tableName". 
2. Extraia as colunas da tabela e armazene em uma variável chamada "columns".
3. Manipule a variável "columns", separando cada coluna com seu respectivo tipo, em uma string separada.

-- Resultado

tableName = "author"
columns = [ 'id number',' name string',' age number',' city string',' state string',' country string']

-- Dicas

Explore ao máximo as operações disponíveis na String API como: String.prototype.match, String.prototype.replace e String.prototype.split, juntamente com expressões regulares. A operação String.prototype.split retorna uma array, então não é necessário se preocupar em criar ou adicionar as colunas no array.

-- Conteúdo abordado neste exercício

- String
- String.prototype.match
- String.prototype.split
- String.prototype.trim
- RegExp
- RegExp - Groups
- RegExp - Capture Groups
- RegExp - Quantifiers
- RegExp - Metacharacters
- RegExp - Escape


Solução apresentada:

const statement = "create table author (id number, name string, age number, city string, state string, country string)";
const regexp = /create table ([a-z]+) \((.+)\)/;
const parsedStatement = statement.match(regexp);
const tableName = parsedStatement[1];
let columns = parsedStatement[2];
columns = columns.split(", ");
console.log(tableName);
console.log(columns);





== Objects == 

Um objeto é uma coleção dinâmica de propriedades definidas por chaves, que podem ser do tipo String ou Symbol, e valores que podem ser de qualquer tipo de dado

  Chave     | Valor
  -----------------------------
  title     | Clean Code
  author    | Robert C. Martin
  pages     | 464
  language  | English
  available | true




É possível criar objetos de várias formas: pela "notação literal", por meio de uma "função construtora" ou do "método create da Object API"

-- arquivo: object_1.js

$ node
> {}
{}
> {};
undefined
> new Object();
{}
> Object.create(null);
{}


(*) Existe diferença entre essas formas? 
Não tem diferença no resultado final, mas cada forma de criar um objeto tem um objetivo específico (a ser visto).


-- Notação Literal --

Uma das diversas maneiras de atribuir propriedades a um objeto é durante a sua inicialização, pela notação literal

-- arquivo: object_2.js
const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
console.log(book);

-- Shorthand Notation -- a partir do ES6 --

-- arquivo: object_3.js
const title = "Clean Code";
const author = "Robert C. Martin";
const pages = 464;
const language = "English";
const available = true;
const book = {
    title,
    author,
    pages,
    language,
    available
};
console.log(book);


(*) Dependendo da chave é necessário declará-la diretamente como String 

-- arquivo: object_4.js
const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    "number-of-pages": 464,
    language: "English",
    available: true
};
console.log(book);


-- Chave Computada --

Também é possível computar as chaves em tempo de execução

-- arquivo: object_5.js
const key1 = "title";
const key2 = "author";
const key3 = "pages";
const key4 = "language";
const key5 = "available";
const book = {
    [key1]: "Clean Code",
    [key2]: "Robert C. Martin",
    [key3]: 464,
    [key4]: "English",
    [key5]: true
};
console.log(book);


Além da notação literal, é possível atribuir propriedades aos objetos por meio da sua referência

-- arquivo: object_6.js
const book = {};
book.title = "Clean Code";
book.author = "Robert C. Martin";
book.pages = 464;
book.language = "English";
book.available = true;
console.log(book);



Assim como na notação literal, é possível computar as chaves de um objeto em tempo de execução por meio da sua referência

-- arquivo: object_7.js
const key1 = "title";
const key2 = "author";
const key3 = "pages";
const key4 = "language";
const key5 = "available";
const book = {};
book[key1] = "Clean Code",
book[key2] = "Robert C. Martin",
book[key3] = 464,
book[key4] = "English",
book[key5] = true
console.log(book);



Cada uma das propriedades de um objeto podem ser consultadas por meio da sua referência, de forma direta

-- arquivo: object_8.js
const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
console.log(book.title);
console.log(book.author);
console.log(book.pages);
console.log(book.language);
console.log(book.available);



É possível consultar cada uma das propriedades de um objeto por meio da computação das chaves

-- arquivo: object_9.js
const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
for (let key in book) {
    console.log(book[key]);
}

-- arquivo: object_10.js
const book1 = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
const book2 = {};
for (let key in book1) {
    book2[key] = book1[key];
}
console.log(book2);



== undefined e null == 

O tipo "undefined" é retornado caso a chave não seja encontrada

-- arquivo: undefined_null_1.js

const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
console.log(book.publisher);

--> retorna "undefined"

Qual é a diferença entre os tipos "undefined" e "null"?

"null" indica a ausência de valor, enquanto "undefined" indica que a chave sequer existe.

É possível consultar uma determinada chave por meio do operador "in"


-- arquivo: undefined_null_2.js

const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
console.log("title" in book);
console.log("author" in book);
console.log("pages" in book);
console.log("language" in book);
console.log("available" in book);
console.log("publisher" in book);


(*) Não atribua para "undefined" ou "null" com a intenção de apagar uma propriedade

-- arquivo: undefined_null_3.js

const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
book.available = undefined;
console.log(book);
console.log("available" in book);

-- arquivo: undefined_null_4.js

const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
book.available = null;
console.log(book);
console.log("available" in book);


As propriedades de um objeto podem ser apagadas por meio do operador "delete"

-- arquivo: undefined_null_5.js

const book = {
    title: "Clean Code",
    author: "Robert C. Martin",
    pages: 464,
    language: "English",
    available: true
};
delete book.available;
console.log(book);
console.log("available" in book);



== Comparação de Objetos ==

A comparação dos objetos é feita por meio da sua "referência", assim, ainda que dois objetos tenham exatamente as mesmas propriedades eles serão considerados diferentes.

-- arquivo: object_comparison_1.js

const book1 = {
    title: "Clean Code",
    author: "Robert C. Martin"
};
const book2 = {
    title: "Clean Code",
    author: "Robert C. Martin"
};
console.log(book1 == book2);
console.log(book1 === book2);

--> exibe: false e false


Uma das formas para comparar os objetos é "analisando cada uma das suas propriedades" por meio da comparação das chaves e valores


-- arquivo: object_comparison_2.js

const book1 = {
    title: "Clean Code",
    author: "Robert C. Martin"
};
const book2 = {
    title: "Clean Code",
    author: "Robert C. Martin"
};
let equal = true;
for (let key in book1) {
    if (book1[key] !== book2[key]) equal = false;
}
for (let key in book2) {
    if (book2[key] !== book1[key]) equal = false;
}
console.log(equal);


(*) Para garantir que um objeto é igual ao outro é "necessário verificar os seus protótipos"




== Herança == 

O principal objetivo da herança é "permitir o reuso de código" por meio do compartilhamento de propriedades entre objetos, "evitando a duplicação"

(*) Na linguagem JavaScript a herança é realizada entre "objetos" e não classes (Herança baseada em Protótipos)

-- arquivo: inheritance_1.js

const scheme = {
    name: "Scheme",
    year: 1975,
    paradigm: "Functional"    
};
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "Functional"
};
console.log(scheme);
console.log(javascript);


-- arquivo: inheritance_2.js

const functionalLanguage = {
    paradigm: "Functional"
};
const scheme = {
    name: "Scheme",
    year: 1975,
    paradigm: "Functional"    
};
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "Functional"
};
console.log(functionalLanguage);
console.log(scheme);
console.log(javascript);



A propriedade "__proto__" é uma referência para o protótipo do objeto 
(oficial a partir do ECMA262)

-- arquivo: inheritance_3.js

const functionalLanguage = {
    paradigm: "Functional"
};
const scheme = {
    name: "Scheme",
    year: 1975,
    __proto__: functionalLanguage
};
const javascript = {
    name: "JavaScript",
    year: 1995,
    __proto__: functionalLanguage
};
console.log(functionalLanguage);
console.log(scheme);
console.log(javascript);


Porque a propriedade "paradigm" não foi exibida dentro do objeto? 

Quando fazemos o console.log, para evitar um exagero de informações, o interpretador só exibe as propriedades que estão no próprio objeto.

Mas... podemos consultar a propriedade através do objeto que herda as características de outro.

-- arquivo: inheritance_4.js

const functionalLanguage = {
    paradigm: "Functional"
};
const scheme = {
    name: "Scheme",
    year: 1975,
    __proto__: functionalLanguage
};
const javascript = {
    name: "JavaScript",
    year: 1995,
    __proto__: functionalLanguage
};
console.log(functionalLanguage);
console.log(scheme.paradigm);
console.log(javascript.paradigm);

Sempre que consultarmos uma propriedade de um objeto e ela não existir, a pesquisa é automaticamente feita no protótipo desse objeto, e assim sucessivamente, até chegar no ObjectPrototype (protótipo base de todos os objetos).




O método "hasOwnProperty" pode ser utilizado para determinar se uma propriedade pertence ao objeto

-- arquivo: inheritance_5.js

const functionalLanguage = {
    paradigm: "Functional"
};
const scheme = {
    name: "Scheme",
    year: 1975,
    __proto__: functionalLanguage
};
const javascript = {
    name: "JavaScript",
    year: 1995,
    __proto__: functionalLanguage
};
for (let key in scheme) {
    console.log(key, scheme.hasOwnProperty(key));
}




Os métodos "Object.setPrototypeOf" e "Object.getPrototypeOf" permitem a interação com o protótipo do objeto

(*) É recomendado o uso do "Object.setPrototypeOf" em vez de "__proto__". Fica mais claro.

-- arquivo: inheritance_6.js

const functionalLanguage = {
    paradigm: "Functional"
};
const scheme = {
    name: "Scheme",
    year: 1975
};
Object.setPrototypeOf(scheme, functionalLanguage);
const javascript = {
    name: "JavaScript",
    year: 1995
};
Object.setPrototypeOf(javascript, functionalLanguage);
for (let key in scheme) {
    console.log(key, scheme.hasOwnProperty(key));
}


Com o método "Object.create" é possível criar um objeto passando o seu protótipo por parâmetro


-- arquivo: inheritance_7.js

const functionalLanguage = {
    paradigm: "Functional"
};
const scheme = Object.create(functionalLanguage);
scheme.name = "Scheme";
scheme.year = 1975;
const javascript = Object.create(functionalLanguage);
javascript.name = "JavaScript";
javascript.year = 1995;
for (let key in scheme) {
    console.log(key, scheme.hasOwnProperty(key));
}



"Sem o seu protótipo" o objeto perde algumas operações importantes

-- arquivo: inheritance_8.js

const functionalLanguage = Object.create(null);
functionalLanguage.paradigm = "Functional";
const scheme = Object.create(functionalLanguage);
scheme.name = "Scheme";
scheme.year = 1975;
const javascript = Object.create(functionalLanguage);
javascript.name = "JavaScript";
javascript.year = 1995;
for (let key in scheme) {
    console.log(key, scheme.hasOwnProperty(key));
}

--> Ocorre um erro, pois a herança da ObjectPrototype não foi realizada


(Shadowing)
Caso a mesma propriedade exista no objeto e no seu protótipo, "a propriedade do próprio objeto é retornada, fazendo sombra à propriedade do protótipo"


-- arquivo: inheritance_9.js

const functionalLanguage = Object.create({});
functionalLanguage.paradigm = "Functional";
const scheme = Object.create(functionalLanguage);
scheme.name = "Scheme";
scheme.year = 1975;
const javascript = Object.create(functionalLanguage);
javascript.name = "JavaScript";
javascript.year = 1995;
javascript.paradigm = "OO";  // <----
for (let key in javascript) {
    console.log(key, javascript[key]);
}

-- arquivo: inheritance_10.js

const functionalLanguage = Object.create({});
functionalLanguage.paradigm = "Functional";
const scheme = Object.create(functionalLanguage);
scheme.name = "Scheme";
scheme.year = 1975;
const javascript = Object.create(functionalLanguage);
javascript.name = "JavaScript";
javascript.year = 1995;
javascript.paradigm = "OO";
console.log(javascript.paradigm);
console.log(javascript.__proto__.paradigm);
console.log(Object.getPrototypeOf(javascript).paradigm);




== Object API ==

O método "Object.assign" faz a cópia das propriedades dos objetos passados por parâmetro para o objeto alvo, que é retornado

-- arquivo object_api_1.js

const javascript = Object.create({});
Object.assign(javascript, {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
});
console.log(javascript);


-- arquivo object_api_2.js

const javascript = Object.create({});
Object.assign(javascript, {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
}, {
    author: "Brendan Eich",
    influencedBy: "Java, Scheme and Self"
});
console.log(javascript);

(*) "Object.assign" :: uma das características mais usadas. Muito útil. Surgiu na ES6.



O método "Object.keys" retorna as chaves das propriedades do objeto  (ES5)

-- arquivo object_api_3.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
console.log(Object.keys(javascript));



O método "Object.values" retorna os valores das propriedades do objeto 

-- arquivo object_api_4.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
console.log(Object.values(javascript));



O método "Object.entries" retorna as propriedades do objeto em pares de chave e valor

-- arquivo object_api_5.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
console.log(Object.entries(javascript));



O método "Object.is" compara dois objetos, considerando os tipos de dados, de forma similar ao operador "===""

-- arquivo object_api_6.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
console.log(Object.is(javascript, javascript));

-> Exibe: true

-- arquivo object_api_7.js
const javascript1 = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
const javascript2 = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
console.log(Object.is(javascript1, javascript2));

-> Exibe: false

-- arquivo object_api_8.js
console.log(Object.is(NaN, NaN));

-> Exibe: true

(*) Mas não faz milagre. O ideal é comparar propriedade a propriedade



-- defineProperty --
* configurable - Permite que uma determinada propriedade seja apagada
* enumerable - Permite que uma determinada propriedade seja enumerada
* value - Define o valor de uma determinada propriedade 
* writable - Permite que uma determinada propriedade tenha seu valor modificado


-- arquivo object_api_9.js
const javascript = {};
Object.defineProperty(javascript, "name", {
    value: "JavaScript"
});
console.log(javascript);
console.log(Object.keys(javascript));
console.log(Object.values(javascript));
console.log(Object.entries(javascript));


-- arquivo object_api_10.js
const javascript = {};
Object.defineProperty(javascript, "name", {
    enumerable: true,
    value: "JavaScript"
});
console.log(javascript);
console.log(Object.keys(javascript));
console.log(Object.values(javascript));
console.log(Object.entries(javascript));


-- arquivo object_api_11.js
const javascript = {};
Object.defineProperty(javascript, "name", {
    enumerable: true,
    value: "JavaScript"
});
javascript.name = "ECMAScript";
console.log(javascript);
console.log(Object.keys(javascript));
console.log(Object.values(javascript));
console.log(Object.entries(javascript));


-- arquivo object_api_12.js
const javascript = {};
Object.defineProperty(javascript, "name", {
    enumerable: true,
    value: "JavaScript",
    writable: true
});
javascript.name = "ECMAScript";
console.log(javascript);
console.log(Object.keys(javascript));
console.log(Object.values(javascript));
console.log(Object.entries(javascript));


-- arquivo object_api_13.js
const javascript = {};
Object.defineProperty(javascript, "name", {
    enumerable: true,
    value: "JavaScript",
    writable: true
});
javascript.name = "ECMAScript";
delete javascript.name;
console.log(javascript);
console.log(Object.keys(javascript));
console.log(Object.values(javascript));
console.log(Object.entries(javascript));


-- arquivo object_api_14.js
const javascript = {};
Object.defineProperty(javascript, "name", {
    configurable: true,
    enumerable: true,
    value: "JavaScript",
    writable: true
});
javascript.name = "ECMAScript";
delete javascript.name;
console.log(javascript);
console.log(Object.keys(javascript));
console.log(Object.values(javascript));
console.log(Object.entries(javascript));




-- preventExtensions, seal e freeze
* preventExtensions - Impede que o objeto tenha novas propriedades, mas permite modificar ou remover as propriedades existentes
* seal - Impede que o objeto tenha novas propriedades ou apague propriedades existentes, mas permite modificar propriedades existentes
* freeze - Impede que o objeto tenha novas propriedades, apague ou modifique propriedades existentes

                         |Create|Read |Update|Delete|
-------------------------+------+-----+------+------|
Object.preventExtensions |  no  | yes | yes  | yes  |
Object.seal              |  no  | yes | yes  | no   |
Object.freeze            |  no  | yes | no   | no   |
-----------------------------------------------------

-- arquivo object_api_15.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
Object.preventExtensions(javascript);
javascript.name = "ECMAScript";
javascript.author = "Brendan Eich";
delete javascript.year;
console.log(javascript);
console.log(Object.isExtensible(javascript));


-- arquivo object_api_16.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
Object.seal(javascript);
javascript.name = "ECMAScript";
javascript.author = "Brendan Eich";
delete javascript.year;
console.log(javascript);
console.log(Object.isExtensible(javascript));
console.log(Object.isSealed(javascript));


-- arquivo object_api_17.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
Object.freeze(javascript);
javascript.name = "ECMAScript";
javascript.author = "Brendan Eich";
delete javascript.year;
console.log(javascript);
console.log(Object.isExtensible(javascript));
console.log(Object.isSealed(javascript));
console.log(Object.isFrozen(javascript));


(*) Não é possível alterar o protótipo do objeto, que se torna imutável

-- arquivo object_api_18.js
const javascript = {
    name: "JavaScript",
    year: 1995,
    paradigm: "OO and Functional"
};
Object.freeze(javascript);
javascript.name = "ECMAScript";
javascript.author = "Brendan Eich";
delete javascript.year;
console.log(javascript);
console.log(Object.isExtensible(javascript));
console.log(Object.isSealed(javascript));
console.log(Object.isFrozen(javascript));
Object.setPrototypeOf(javascript, {});

-> Exibe erro: TypeError: #<Object> is not extensible...

== JSON ==